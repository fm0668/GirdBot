# ä¿è¯é‡‘ç‡å’Œæ æ†è®¡ç®—åˆ†æ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†åˆ†æç»´æŒä¿è¯é‡‘ç‡(MMR)ã€åˆå§‹ä¿è¯é‡‘ç‡(IMR)çš„è®¡ç®—é€»è¾‘ï¼Œä»¥åŠå¯ç”¨æ æ†çš„è®¡ç®—æ–¹æ³•ï¼Œå¹¶è¯Šæ–­"å¯ç”¨æ æ†: 1x"é—®é¢˜çš„åŸå› ã€‚

## ğŸ” 1. ç»´æŒä¿è¯é‡‘ç‡(MMR)è®¡ç®—é€»è¾‘

### å®šä¹‰
ç»´æŒä¿è¯é‡‘ç‡æ˜¯äº¤æ˜“æ‰€è¦æ±‚çš„æœ€ä½ä¿è¯é‡‘æ¯”ä¾‹ï¼Œç”¨äºç»´æŒç°æœ‰æŒä»“ä¸è¢«å¼ºåˆ¶å¹³ä»“ã€‚

### è®¡ç®—å…¬å¼
```
ç»´æŒä¿è¯é‡‘ç‡ = ç»´æŒä¿è¯é‡‘ / æŒä»“åä¹‰ä»·å€¼
```

### æ•°æ®æ¥æº
ç»´æŒä¿è¯é‡‘ç‡é€šå¸¸ä»ä»¥ä¸‹æ¥æºè·å–ï¼š

#### æ–¹æ³•1: æ æ†åˆ†å±‚è§„åˆ™ (æ¨è)
```python
# å¸å®‰æœŸè´§API
tiers = await exchange.fetch_leverage_tiers([symbol])
if symbol in tiers and tiers[symbol]:
    first_tier = tiers[symbol][0]
    mmr = first_tier.get('maintenanceMarginRate', 0.05)
```

#### æ–¹æ³•2: å¸‚åœºä¿¡æ¯
```python
market = exchange.markets[symbol]
info = market.get('info', {})
mmr = info.get('maintMarginPercent', 0.05)
```

### å¸å®‰DOGE/USDC:USDCçš„å®é™…æ•°æ®
æ ¹æ®å¸å®‰å®˜æ–¹æ–‡æ¡£ï¼ŒDOGEæ°¸ç»­åˆçº¦çš„ç»´æŒä¿è¯é‡‘ç‡åˆ†å±‚å¦‚ä¸‹ï¼š

| åä¹‰ä»·å€¼èŒƒå›´ | ç»´æŒä¿è¯é‡‘ç‡ | æœ€å¤§æ æ† |
|-------------|-------------|----------|
| 0 - 50,000 USDC | 0.65% | 75x |
| 50,000 - 250,000 USDC | 1.00% | 50x |
| 250,000 - 1,000,000 USDC | 2.50% | 20x |
| > 1,000,000 USDC | 5.00% | 10x |

## ğŸ” 2. åˆå§‹ä¿è¯é‡‘ç‡(IMR)è®¡ç®—é€»è¾‘

### å®šä¹‰
åˆå§‹ä¿è¯é‡‘ç‡æ˜¯å¼€ä»“æ—¶éœ€è¦çš„ä¿è¯é‡‘æ¯”ä¾‹ã€‚

### è®¡ç®—å…¬å¼
```
åˆå§‹ä¿è¯é‡‘ç‡ = 1 / æœ€å¤§æ æ†
```

### å…³ç³»
```
åˆå§‹ä¿è¯é‡‘ç‡ â‰¥ ç»´æŒä¿è¯é‡‘ç‡
```

### å®é™…æ•°æ®ç¤ºä¾‹
å¯¹äºDOGE/USDC:USDCç¬¬ä¸€å±‚ï¼š
- ç»´æŒä¿è¯é‡‘ç‡: 0.65%
- æœ€å¤§æ æ†: 75x
- åˆå§‹ä¿è¯é‡‘ç‡: 1/75 = 1.33%

## ğŸ” 3. å¯ç”¨æ æ†è®¡ç®—é€»è¾‘

### é¡¹ç›®ä¸­çš„è®¡ç®—æ–¹æ³•

#### å½“å‰å®ç° (core/grid_calculator.py)
```python
async def calculate_max_leverage(self, atr_result: ATRResult, mmr: Decimal, safety_factor: Decimal) -> int:
    # è®¡ç®—å¹³å‡å…¥åœºä»·æ ¼
    avg_entry_price = (atr_result.upper_bound + atr_result.lower_bound) / Decimal("2")
    
    # 1. è®¡ç®—å¤šå¤´ç†è®ºæœ€å¤§æ æ†
    long_factor = Decimal("1") + mmr - (atr_result.lower_bound / avg_entry_price)
    max_leverage_long = Decimal("1") / long_factor if long_factor > 0 else Decimal("100")
    
    # 2. è®¡ç®—ç©ºå¤´ç†è®ºæœ€å¤§æ æ†
    short_factor = (atr_result.upper_bound / avg_entry_price) - Decimal("1") + mmr
    max_leverage_short = Decimal("1") / short_factor if short_factor > 0 else Decimal("100")
    
    # 3. å–è¾ƒä¿å®ˆçš„æ æ†å¹¶åº”ç”¨å®‰å…¨ç³»æ•°
    conservative_leverage = min(max_leverage_long, max_leverage_short)
    usable_leverage = int(conservative_leverage * safety_factor)
    
    return max(1, min(usable_leverage, 100))
```

### è®¡ç®—é€»è¾‘è§£é‡Š

#### å¤šå¤´æ æ†è®¡ç®—
```
long_factor = 1 + MMR - (ä¸‹è½¨ä»·æ ¼ / å¹³å‡ä»·æ ¼)
max_leverage_long = 1 / long_factor
```

**å«ä¹‰**: è€ƒè™‘ä»·æ ¼ä¸‹è·Œåˆ°ATRä¸‹è½¨æ—¶ï¼Œå¤šå¤´æŒä»“ä¸ä¼šè¢«å¼ºåˆ¶å¹³ä»“çš„æœ€å¤§æ æ†ã€‚

#### ç©ºå¤´æ æ†è®¡ç®—
```
short_factor = (ä¸Šè½¨ä»·æ ¼ / å¹³å‡ä»·æ ¼) - 1 + MMR
max_leverage_short = 1 / short_factor
```

**å«ä¹‰**: è€ƒè™‘ä»·æ ¼ä¸Šæ¶¨åˆ°ATRä¸Šè½¨æ—¶ï¼Œç©ºå¤´æŒä»“ä¸ä¼šè¢«å¼ºåˆ¶å¹³ä»“çš„æœ€å¤§æ æ†ã€‚

## ğŸ› 4. "å¯ç”¨æ æ†: 1x" é—®é¢˜è¯Šæ–­

### é—®é¢˜ç°è±¡
æµ‹è¯•ç»“æœæ˜¾ç¤ºå¯ç”¨æ æ†ä¸º1xï¼Œè¿œä½äºé¢„æœŸçš„50xæˆ–æ›´é«˜ã€‚

### å¯èƒ½åŸå› åˆ†æ

#### åŸå› 1: ç»´æŒä¿è¯é‡‘ç‡æ•°æ®å¼‚å¸¸ â­â­â­â­â­
**ç°è±¡**: æµ‹è¯•ä¸­è·å–åˆ°çš„MMRä¸º250% (2.5)ï¼Œè€Œä¸æ˜¯é¢„æœŸçš„0.65% (0.0065)

**å½±å“**: 
```python
# å‡è®¾æ•°æ®
atr_result.upper_bound = 0.225874120
atr_result.lower_bound = 0.202245880
avg_entry_price = 0.214060000
mmr = 2.5  # å¼‚å¸¸å€¼ï¼

# å¤šå¤´è®¡ç®—
long_factor = 1 + 2.5 - (0.202245880 / 0.214060000)
long_factor = 1 + 2.5 - 0.9448 = 2.5552
max_leverage_long = 1 / 2.5552 = 0.39x

# ç©ºå¤´è®¡ç®—  
short_factor = (0.225874120 / 0.214060000) - 1 + 2.5
short_factor = 1.0552 - 1 + 2.5 = 2.5552
max_leverage_short = 1 / 2.5552 = 0.39x

# æœ€ç»ˆç»“æœ
conservative_leverage = min(0.39, 0.39) = 0.39x
usable_leverage = int(0.39 * 0.8) = 0 â†’ max(1, 0) = 1x
```

#### åŸå› 2: APIæ•°æ®æ ¼å¼é—®é¢˜ â­â­â­â­
**å¯èƒ½æƒ…å†µ**:
- APIè¿”å›çš„æ˜¯ç™¾åˆ†æ¯”å½¢å¼ (250) è€Œä¸æ˜¯å°æ•°å½¢å¼ (2.5)
- éœ€è¦é™¤ä»¥100æˆ–10000è¿›è¡Œè½¬æ¢

#### åŸå› 3: äº¤æ˜“å¯¹ä¸æ”¯æŒæˆ–æ•°æ®ç¼ºå¤± â­â­â­
**å¯èƒ½æƒ…å†µ**:
- DOGE/USDC:USDCäº¤æ˜“å¯¹çš„æ æ†åˆ†å±‚æ•°æ®è·å–å¤±è´¥
- ä½¿ç”¨äº†é»˜è®¤çš„ä¿å®ˆå€¼

### è¯Šæ–­æ­¥éª¤

#### æ­¥éª¤1: æ£€æŸ¥åŸå§‹APIå“åº”
```python
# åœ¨ ExchangeDataProvider._get_margin_info ä¸­æ·»åŠ è°ƒè¯•
try:
    if hasattr(self.exchange, 'fetch_leverage_tiers'):
        tiers = await self.exchange.fetch_leverage_tiers([symbol])
        print(f"åŸå§‹æ æ†åˆ†å±‚æ•°æ®: {tiers}")  # è°ƒè¯•è¾“å‡º
        
        if symbol in tiers and tiers[symbol]:
            first_tier = tiers[symbol][0]
            print(f"ç¬¬ä¸€å±‚æ•°æ®: {first_tier}")  # è°ƒè¯•è¾“å‡º
            
            raw_mmr = first_tier.get('maintenanceMarginRate', 0.05)
            print(f"åŸå§‹MMRå€¼: {raw_mmr}")  # è°ƒè¯•è¾“å‡º
```

#### æ­¥éª¤2: éªŒè¯æ•°æ®è½¬æ¢
```python
# æ£€æŸ¥æ˜¯å¦éœ€è¦å•ä½è½¬æ¢
if raw_mmr > 1:
    # å¯èƒ½æ˜¯ç™¾åˆ†æ¯”å½¢å¼ï¼Œéœ€è¦è½¬æ¢
    mmr = Decimal(str(raw_mmr / 100))
else:
    mmr = Decimal(str(raw_mmr))
```

#### æ­¥éª¤3: éªŒè¯è®¡ç®—é€»è¾‘
```python
# ä½¿ç”¨æ­£ç¡®çš„MMRé‡æ–°è®¡ç®—
correct_mmr = Decimal("0.0065")  # 0.65%
# é‡æ–°æ‰§è¡Œæ æ†è®¡ç®—...
```

## ğŸ”§ 5. ä¿®å¤æ–¹æ¡ˆ

### æ–¹æ¡ˆ1: ä¿®å¤æ•°æ®è·å–é€»è¾‘
```python
async def _get_margin_info(self, symbol: str) -> Dict[str, Decimal]:
    try:
        if hasattr(self.exchange, 'fetch_leverage_tiers'):
            tiers = await self.exchange.fetch_leverage_tiers([symbol])
            if symbol in tiers and tiers[symbol]:
                first_tier = tiers[symbol][0]
                
                # è·å–åŸå§‹å€¼
                raw_mmr = first_tier.get('maintenanceMarginRate', 0.05)
                raw_imr = first_tier.get('initialMarginRate', 0.1)
                
                # æ•°æ®æ ¼å¼è½¬æ¢
                if raw_mmr > 1:
                    # ç™¾åˆ†æ¯”å½¢å¼ï¼Œè½¬æ¢ä¸ºå°æ•°
                    mmr = Decimal(str(raw_mmr / 100))
                else:
                    mmr = Decimal(str(raw_mmr))
                
                if raw_imr > 1:
                    imr = Decimal(str(raw_imr / 100))
                else:
                    imr = Decimal(str(raw_imr))
                
                return {
                    'maintenance_margin_rate': mmr,
                    'initial_margin_rate': imr
                }
    except Exception as e:
        self.logger.debug(f"è·å–æ æ†åˆ†å±‚ä¿¡æ¯å¤±è´¥: {e}")
    
    # ä½¿ç”¨DOGEçš„å®é™…é»˜è®¤å€¼
    return {
        'maintenance_margin_rate': Decimal("0.0065"),  # 0.65%
        'initial_margin_rate': Decimal("0.0133")       # 1.33%
    }
```

### æ–¹æ¡ˆ2: æ·»åŠ æ•°æ®éªŒè¯
```python
def validate_margin_rates(self, mmr: Decimal, imr: Decimal) -> Tuple[Decimal, Decimal]:
    """éªŒè¯ä¿è¯é‡‘ç‡æ•°æ®çš„åˆç†æ€§"""
    
    # MMRåº”è¯¥åœ¨0.1%åˆ°10%ä¹‹é—´
    if mmr < Decimal("0.001") or mmr > Decimal("0.1"):
        self.logger.warning(f"å¼‚å¸¸çš„ç»´æŒä¿è¯é‡‘ç‡: {mmr}, ä½¿ç”¨é»˜è®¤å€¼")
        mmr = Decimal("0.0065")
    
    # IMRåº”è¯¥å¤§äºç­‰äºMMR
    if imr < mmr:
        imr = mmr * Decimal("2")  # è®¾ä¸ºMMRçš„2å€
    
    return mmr, imr
```

### æ–¹æ¡ˆ3: å¢å¼ºè°ƒè¯•ä¿¡æ¯
```python
async def calculate_max_leverage(self, atr_result: ATRResult, mmr: Decimal, safety_factor: Decimal) -> int:
    # æ·»åŠ è¯¦ç»†çš„è°ƒè¯•æ—¥å¿—
    avg_entry_price = (atr_result.upper_bound + atr_result.lower_bound) / Decimal("2")
    
    self.logger.info("æ æ†è®¡ç®—è¯¦æƒ…", extra={
        'upper_bound': str(atr_result.upper_bound),
        'lower_bound': str(atr_result.lower_bound),
        'avg_entry_price': str(avg_entry_price),
        'mmr': str(mmr),
        'safety_factor': str(safety_factor)
    })
    
    # å¤šå¤´è®¡ç®—
    long_factor = Decimal("1") + mmr - (atr_result.lower_bound / avg_entry_price)
    max_leverage_long = Decimal("1") / long_factor if long_factor > 0 else Decimal("100")
    
    # ç©ºå¤´è®¡ç®—
    short_factor = (atr_result.upper_bound / avg_entry_price) - Decimal("1") + mmr
    max_leverage_short = Decimal("1") / short_factor if short_factor > 0 else Decimal("100")
    
    self.logger.info("æ æ†è®¡ç®—ç»“æœ", extra={
        'long_factor': str(long_factor),
        'max_leverage_long': str(max_leverage_long),
        'short_factor': str(short_factor),
        'max_leverage_short': str(max_leverage_short)
    })
    
    # æœ€ç»ˆè®¡ç®—
    conservative_leverage = min(max_leverage_long, max_leverage_short)
    usable_leverage = int(conservative_leverage * safety_factor)
    final_leverage = max(1, min(usable_leverage, 100))
    
    self.logger.info("æœ€ç»ˆæ æ†", extra={
        'conservative_leverage': str(conservative_leverage),
        'usable_leverage': str(usable_leverage),
        'final_leverage': str(final_leverage)
    })
    
    return final_leverage
```

## ğŸ“Š 6. é¢„æœŸä¿®å¤æ•ˆæœ

### ä¿®å¤å‰
- ç»´æŒä¿è¯é‡‘ç‡: 250% (å¼‚å¸¸)
- å¯ç”¨æ æ†: 1x

### ä¿®å¤å
- ç»´æŒä¿è¯é‡‘ç‡: 0.65% (æ­£å¸¸)
- å¯ç”¨æ æ†: çº¦30-50x (å–å†³äºATRé€šé“å®½åº¦å’Œå®‰å…¨ç³»æ•°)

### è®¡ç®—ç¤ºä¾‹ (ä¿®å¤å)
```python
# å‡è®¾ä¿®å¤åçš„æ•°æ®
mmr = 0.0065  # 0.65%
upper_bound = 0.225874120
lower_bound = 0.202245880
avg_entry_price = 0.214060000
safety_factor = 0.8

# å¤šå¤´è®¡ç®—
long_factor = 1 + 0.0065 - (0.202245880 / 0.214060000)
long_factor = 1 + 0.0065 - 0.9448 = 0.0617
max_leverage_long = 1 / 0.0617 = 16.2x

# ç©ºå¤´è®¡ç®—
short_factor = (0.225874120 / 0.214060000) - 1 + 0.0065
short_factor = 1.0552 - 1 + 0.0065 = 0.0617
max_leverage_short = 1 / 0.0617 = 16.2x

# æœ€ç»ˆç»“æœ
conservative_leverage = min(16.2, 16.2) = 16.2x
usable_leverage = int(16.2 * 0.8) = 12x
```

## âœ… æ€»ç»“

"å¯ç”¨æ æ†: 1x"é—®é¢˜çš„ä¸»è¦åŸå› æ˜¯ç»´æŒä¿è¯é‡‘ç‡æ•°æ®å¼‚å¸¸ï¼ˆ250%è€Œä¸æ˜¯0.65%ï¼‰ã€‚é€šè¿‡ä¿®å¤æ•°æ®è·å–å’Œè½¬æ¢é€»è¾‘ï¼Œé¢„æœŸå¯ä»¥å°†å¯ç”¨æ æ†æå‡åˆ°åˆç†çš„10-50xèŒƒå›´ã€‚
