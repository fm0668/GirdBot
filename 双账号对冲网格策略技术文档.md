# 双账号对冲网格策略技术文档

## 1. 策略概述

### 1.1 策略定义
双账号对冲网格策略是一个基于ATR（平均真实波动范围）的自动化交易系统，通过在两个独立的币安期货账户中同时运行多头和空头网格交易，实现市场中性的盈利模式。

### 1.2 核心原理
- **市场中性**：通过双账户对冲，消除单向市场风险
- **波动捕获**：利用ATR指标识别价格波动区间，在其中布置网格
- **高频交易**：通过密集的网格订单捕获价格波动产生的套利机会
- **风险可控**：严格的资金管理和止损机制

### 1.3 技术架构
```
                     双账号对冲网格策略
                           |
         ┌─────────────────┴─────────────────┐
         │                                 │
    多头账户 (Long)                      空头账户 (Short)
         │                                 │
    ┌────┴────┐                       ┌────┴────┐
    │网格买单  │                       │网格卖单  │
    │网格卖单  │                       │网格买单  │
    └─────────┘                       └─────────┘
         │                                 │
         └─────────────────┬─────────────────┘
                           │
                      统一风控系统
```

## 2. 指标逻辑详解

### 2.1 ATR指标计算

#### 2.1.1 True Range (TR) 计算
```python
# 真实波动范围的三种计算方式
tr1 = high - low                    # 当前高低价差
tr2 = abs(high - prev_close)        # 当前高价与前收盘价差
tr3 = abs(low - prev_close)         # 当前低价与前收盘价差

# 取最大值作为真实波动范围
true_range = max(tr1, tr2, tr3)
```

#### 2.1.2 ATR计算 (与TradingView Pine Script一致)
```python
# 使用RMA (Rolling Moving Average) 计算ATR
# RMA(x, n) = (x + (n-1) * prev_rma) / n
# 等同于EWM with alpha = 1/n
atr = true_range.ewm(alpha=1/period, adjust=False).mean()
```

#### 2.1.3 ATR通道边界
```python
# 与TradingView完全一致的计算方式
upper_bound = high + (atr * multiplier)     # 上轨
lower_bound = low - (atr * multiplier)      # 下轨
```

**关键参数**：
- `period`: ATR计算周期，默认14
- `multiplier`: ATR倍数，默认2.0
- 使用1小时K线数据进行计算

### 2.2 网格参数计算

#### 2.2.1 网格间距计算
```python
def calculate_grid_spacing(self, atr_value: Decimal, current_price: Decimal, 
                          levels: int, volatility_factor: Decimal = Decimal("0.5")) -> Decimal:
    """
    基于ATR的自适应网格间距计算
    
    计算公式：
    base_spacing = (atr_value * volatility_factor) / levels
    adaptive_spacing = base_spacing * (1 + market_volatility_adjustment)
    """
    # 基础间距 = ATR值 * 波动性因子 / 网格层数
    base_spacing = (atr_value * volatility_factor) / Decimal(str(levels))
    
    # 价格适应性调整
    price_factor = current_price / Decimal("50000")  # 基准价格50000
    adaptive_spacing = base_spacing * price_factor
    
    # 最小间距限制（防止过密）
    min_spacing = current_price * Decimal("0.001")  # 0.1%
    
    return max(adaptive_spacing, min_spacing)
```

#### 2.2.2 网格层数计算
```python
def calculate_max_levels(self, upper_bound: Decimal, lower_bound: Decimal, 
                        grid_spacing: Decimal) -> int:
    """
    计算最大网格层数
    """
    price_range = upper_bound - lower_bound
    max_levels = int(price_range / grid_spacing)
    
    # 确保合理的层数范围
    return max(1, min(max_levels, 50))  # 限制在1-50层
```

### 2.3 杠杆计算

#### 2.3.1 安全杠杆估算
```python
def estimate_leverage(self, unified_margin: Decimal, avg_entry_price: Decimal,
                     upper_bound: Decimal, lower_bound: Decimal, 
                     mmr: Decimal, safety_factor: Decimal = Decimal("0.8")) -> int:
    """
    估算安全杠杆倍数
    
    计算逻辑：
    1. 多头最大风险：价格下跌到下轨时不爆仓
    2. 空头最大风险：价格上涨到上轨时不爆仓
    3. 最终杠杆：取两者较小值，并应用安全系数
    """
    # 多头理论最大杠杆
    long_factor = Decimal("1") + mmr - (lower_bound / avg_entry_price)
    max_leverage_long = Decimal("1") / long_factor if long_factor > 0 else Decimal("1")
    
    # 空头理论最大杠杆
    short_factor = (upper_bound / avg_entry_price) - Decimal("1") + mmr
    max_leverage_short = Decimal("1") / short_factor if short_factor > 0 else Decimal("1")
    
    # 取较小值并应用安全系数
    conservative_leverage = min(max_leverage_long, max_leverage_short)
    usable_leverage = int(conservative_leverage * safety_factor)
    
    return max(1, min(usable_leverage, 20))  # 限制在1-20倍
```

## 3. 交易逻辑详解

### 3.1 策略初始化流程

#### 3.1.1 账户初始化
```python
async def initialize_strategy(self):
    """策略初始化流程"""
    # 1. 建立双账户连接
    await self.dual_manager.initialize()
    
    # 2. 同步账户信息
    long_info, short_info = await self.dual_manager.sync_account_info()
    
    # 3. 设置持仓模式（双向持仓）
    await self.dual_manager.set_position_mode("BOTH")
    
    # 4. 调整杠杆
    await self.dual_manager.adjust_leverage(self.config.symbol, self.config.leverage)
    
    # 5. 验证资金充足性
    await self.validate_fund_adequacy()
```

#### 3.1.2 网格参数计算
```python
async def calculate_grid_parameters(self):
    """计算网格参数"""
    # 1. 获取K线数据
    klines = await self.dual_manager.get_klines(
        symbol=self.config.symbol,
        interval="1h",
        limit=100
    )
    
    # 2. 计算ATR和通道边界
    self.atr_value = await self.atr_analyzer.calculate_atr(klines)
    upper_bound, lower_bound, _ = await self.atr_analyzer.calculate_atr_channel(klines)
    
    # 3. 计算网格间距
    self.grid_spacing = await self.grid_calculator.calculate_grid_spacing(
        self.atr_value, self.current_price, self.config.max_levels
    )
    
    # 4. 计算每层网格数量
    self.grid_params = await self.grid_calculator.calculate_grid_parameters(
        symbol=self.config.symbol,
        current_price=self.current_price,
        atr_value=self.atr_value,
        unified_margin=self.unified_margin,
        upper_bound=upper_bound,
        lower_bound=lower_bound,
        max_levels=self.config.max_levels,
        leverage=self.config.leverage
    )
```

### 3.2 订单执行逻辑

#### 3.2.1 网格层级创建
```python
async def create_grid_levels(self):
    """创建网格层级"""
    current_price = await self.dual_manager.get_current_price(self.config.symbol)
    
    # 多头网格（向下买入，向上卖出）
    for i in range(self.grid_params.max_levels):
        # 买入价格（低于当前价格）
        buy_price = current_price - (self.grid_spacing * (i + 1))
        # 卖出价格（高于当前价格）
        sell_price = current_price + (self.grid_spacing * (i + 1))
        
        # 创建多头网格层
        long_grid = GridLevel(
            price=buy_price,
            quantity=self.grid_params.amount_per_grid,
            side=PositionSide.LONG,
            account_type="long_account",
            level=i + 1
        )
        
        # 创建空头网格层
        short_grid = GridLevel(
            price=sell_price,
            quantity=self.grid_params.amount_per_grid,
            side=PositionSide.SHORT,
            account_type="short_account",
            level=i + 1
        )
        
        self.grid_levels.append(long_grid)
        self.grid_levels.append(short_grid)
```

#### 3.2.2 订单下单逻辑
```python
async def place_grid_orders(self):
    """下单网格订单"""
    for grid_level in self.grid_levels:
        try:
            # 根据账户类型选择对应的连接器
            if grid_level.account_type == "long_account":
                connector = self.dual_manager.long_account
            else:
                connector = self.dual_manager.short_account
            
            # 调整精度
            adjusted_price = await self.dual_manager.adjust_price_precision(
                self.config.symbol, grid_level.price
            )
            adjusted_quantity = await self.dual_manager.adjust_quantity_precision(
                self.config.symbol, grid_level.quantity
            )
            
            # 下单
            order = await connector.place_order(
                symbol=self.config.symbol,
                side="BUY" if grid_level.side == PositionSide.LONG else "SELL",
                order_type="LIMIT",
                quantity=str(adjusted_quantity),
                price=str(adjusted_price),
                position_side=grid_level.side.value,
                time_in_force="GTC"
            )
            
            # 更新网格层状态
            grid_level.order_id = order.get("orderId")
            grid_level.open_order_status = OrderStatus.PENDING
            
        except Exception as e:
            self.logger.error(f"下单失败: {e}")
            continue
```

### 3.3 订单监控与执行

#### 3.3.1 订单状态监控
```python
async def monitor_orders(self):
    """监控订单状态"""
    while self.status == StrategyStatus.RUNNING:
        try:
            # 检查所有活跃订单
            for grid_level in self.grid_levels:
                if grid_level.order_id and grid_level.open_order_status == OrderStatus.PENDING:
                    # 查询订单状态
                    order_status = await self.dual_manager.get_order_status(
                        self.config.symbol, grid_level.order_id, 
                        grid_level.account_type
                    )
                    
                    # 处理成交订单
                    if order_status.get("status") == "FILLED":
                        await self.handle_filled_order(grid_level, order_status)
                    
                    # 处理取消订单
                    elif order_status.get("status") == "CANCELED":
                        await self.handle_canceled_order(grid_level, order_status)
            
            await asyncio.sleep(1)  # 1秒检查一次
            
        except Exception as e:
            self.logger.error(f"订单监控异常: {e}")
            await asyncio.sleep(5)
```

#### 3.3.2 成交订单处理
```python
async def handle_filled_order(self, grid_level: GridLevel, order_info: Dict):
    """处理成交订单"""
    # 更新网格层状态
    grid_level.open_order_status = OrderStatus.FILLED
    grid_level.filled_quantity = Decimal(order_info.get("executedQty", "0"))
    grid_level.avg_fill_price = Decimal(order_info.get("avgPrice", "0"))
    grid_level.filled_time = time.time()
    
    # 计算对冲订单价格
    if grid_level.side == PositionSide.LONG:
        # 多头成交后，下空头平仓单
        hedge_price = grid_level.avg_fill_price + self.grid_spacing
        hedge_side = "SELL"
        hedge_position_side = PositionSide.LONG
    else:
        # 空头成交后，下多头平仓单
        hedge_price = grid_level.avg_fill_price - self.grid_spacing
        hedge_side = "BUY"
        hedge_position_side = PositionSide.SHORT
    
    # 下对冲平仓单
    await self.place_hedge_order(grid_level, hedge_price, hedge_side, hedge_position_side)
    
    # 记录交易
    await self.record_trade(grid_level, order_info)
```

## 4. 风险控制详解

### 4.1 资金管理

#### 4.1.1 统一保证金计算
```python
async def calculate_unified_margin(self, margin_long: Decimal, margin_short: Decimal) -> Decimal:
    """
    计算统一保证金基准
    
    策略：取两个账户中较小的可用保证金作为统一基准
    目的：确保双账户资金对称，避免一方资金不足
    """
    unified_margin = min(margin_long, margin_short)
    self.logger.info(f"统一保证金: 多头={margin_long}, 空头={margin_short}, 统一={unified_margin}")
    return unified_margin
```

#### 4.1.2 资金充足性验证
```python
async def validate_fund_adequacy(self, grid_params: Dict) -> bool:
    """
    验证资金充足性（Hummingbot风格）
    
    验证项目：
    1. 每层网格所需保证金
    2. 总保证金需求
    3. 安全缓冲
    """
    # 计算每层网格所需保证金
    margin_per_grid = (grid_params["amount_per_grid"] * grid_params["avg_entry_price"]) / Decimal(str(grid_params["leverage"]))
    
    # 计算总保证金需求
    total_margin_needed = margin_per_grid * Decimal(str(grid_params["max_levels"]))
    
    # 应用安全系数（90%资金利用率）
    safety_factor = Decimal("0.9")
    required_margin = total_margin_needed / safety_factor
    
    # 验证资金充足性
    if grid_params["unified_margin"] >= required_margin:
        self.logger.info(f"资金充足性验证通过: 需要={required_margin}, 可用={grid_params['unified_margin']}")
        return True
    else:
        self.logger.error(f"资金不足: 需要={required_margin}, 可用={grid_params['unified_margin']}")
        return False
```

### 4.2 止损管理

#### 4.2.1 止损触发条件
```python
class StopLossManager:
    """止损管理器"""
    
    def __init__(self, dual_manager: DualAccountManager, symbol: str):
        self.dual_manager = dual_manager
        self.symbol = symbol
        self.stop_loss_configs = {
            "max_drawdown": Decimal("0.10"),      # 最大回撤10%
            "pnl_threshold": Decimal("-1000"),    # 绝对亏损1000USDT
            "position_ratio": Decimal("0.80"),    # 持仓比例80%
            "time_limit": 24 * 3600,              # 时间限制24小时
        }
    
    async def check_stop_loss_conditions(self) -> Optional[StopLossReason]:
        """检查止损条件"""
        # 1. 检查最大回撤
        if await self.check_max_drawdown():
            return StopLossReason.MAX_DRAWDOWN
        
        # 2. 检查绝对亏损
        if await self.check_absolute_loss():
            return StopLossReason.ABSOLUTE_LOSS
        
        # 3. 检查持仓风险
        if await self.check_position_risk():
            return StopLossReason.POSITION_RISK
        
        # 4. 检查时间限制
        if await self.check_time_limit():
            return StopLossReason.TIME_LIMIT
        
        return None
```

#### 4.2.2 紧急止损执行
```python
async def execute_emergency_stop(self, reason: StopLossReason):
    """执行紧急止损"""
    self.logger.warning(f"触发紧急止损: {reason}")
    
    try:
        # 1. 取消所有挂单
        await self.cancel_all_orders()
        
        # 2. 平仓所有持仓
        await self.close_all_positions()
        
        # 3. 更新策略状态
        self.status = StrategyStatus.EMERGENCY_STOPPED
        
        # 4. 记录止损事件
        await self.record_stop_loss_event(reason)
        
    except Exception as e:
        self.logger.error(f"紧急止损执行失败: {e}")
```

### 4.3 风险指标监控

#### 4.3.1 实时风险指标
```python
class RiskMetrics:
    """风险指标"""
    
    def __init__(self):
        self.total_pnl: Decimal = Decimal("0")
        self.unrealized_pnl: Decimal = Decimal("0")
        self.realized_pnl: Decimal = Decimal("0")
        self.max_drawdown: Decimal = Decimal("0")
        self.position_ratio: Decimal = Decimal("0")
        self.margin_ratio: Decimal = Decimal("0")
        self.daily_volume: Decimal = Decimal("0")
    
    async def calculate_risk_metrics(self, dual_manager: DualAccountManager) -> 'RiskMetrics':
        """计算风险指标"""
        # 获取账户信息
        long_info, short_info = await dual_manager.sync_account_info()
        
        # 计算总PnL
        self.total_pnl = long_info.unrealized_pnl + short_info.unrealized_pnl
        
        # 计算持仓比例
        total_position_value = long_info.total_position_value + short_info.total_position_value
        total_margin = long_info.total_margin_balance + short_info.total_margin_balance
        self.position_ratio = total_position_value / total_margin if total_margin > 0 else Decimal("0")
        
        # 计算保证金比例
        total_available = long_info.available_balance + short_info.available_balance
        self.margin_ratio = total_available / total_margin if total_margin > 0 else Decimal("0")
        
        return self
```

## 5. 性能优化

### 5.1 订单执行优化

#### 5.1.1 批量订单处理
```python
async def place_batch_orders(self, orders: List[Dict]):
    """批量下单优化"""
    # 将订单按账户类型分组
    long_orders = [o for o in orders if o["account_type"] == "long_account"]
    short_orders = [o for o in orders if o["account_type"] == "short_account"]
    
    # 并行处理
    tasks = []
    if long_orders:
        tasks.append(self.dual_manager.long_account.place_batch_orders(long_orders))
    if short_orders:
        tasks.append(self.dual_manager.short_account.place_batch_orders(short_orders))
    
    # 等待所有任务完成
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    return self.process_batch_results(results)
```

#### 5.1.2 WebSocket实时数据
```python
async def setup_websocket_streams(self):
    """设置WebSocket数据流"""
    # 价格数据流
    price_stream = await self.dual_manager.subscribe_price_stream(
        self.config.symbol,
        self.handle_price_update
    )
    
    # 用户数据流
    user_stream_long = await self.dual_manager.long_account.subscribe_user_stream(
        self.handle_long_account_update
    )
    user_stream_short = await self.dual_manager.short_account.subscribe_user_stream(
        self.handle_short_account_update
    )
    
    # 启动数据流
    await asyncio.gather(
        price_stream,
        user_stream_long,
        user_stream_short
    )
```

### 5.2 内存与性能优化

#### 5.2.1 缓存管理
```python
class CacheManager:
    """缓存管理器"""
    
    def __init__(self, max_size: int = 1000):
        self.price_cache = {}
        self.order_cache = {}
        self.max_size = max_size
    
    async def get_cached_price(self, symbol: str) -> Optional[Decimal]:
        """获取缓存价格"""
        cache_entry = self.price_cache.get(symbol)
        if cache_entry and time.time() - cache_entry["timestamp"] < 1:  # 1秒有效期
            return cache_entry["price"]
        return None
    
    async def cache_price(self, symbol: str, price: Decimal):
        """缓存价格"""
        self.price_cache[symbol] = {
            "price": price,
            "timestamp": time.time()
        }
        
        # 清理过期缓存
        if len(self.price_cache) > self.max_size:
            await self.cleanup_expired_cache()
```

## 6. 监控与运维

### 6.1 日志系统

#### 6.1.1 结构化日志
```python
import structlog

# 配置结构化日志
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer()
    ],
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)

# 使用示例
logger = structlog.get_logger()
logger.info("订单执行", 
           symbol="BTCUSDT",
           side="BUY",
           quantity=0.001,
           price=45000.0,
           order_id="12345")
```

#### 6.1.2 关键指标日志
```python
async def log_performance_metrics(self):
    """记录性能指标"""
    metrics = await self.calculate_performance_metrics()
    
    self.logger.info("性能指标", 
                    total_pnl=float(metrics.total_pnl),
                    realized_pnl=float(metrics.realized_pnl),
                    unrealized_pnl=float(metrics.unrealized_pnl),
                    max_drawdown=float(metrics.max_drawdown),
                    position_ratio=float(metrics.position_ratio),
                    margin_ratio=float(metrics.margin_ratio),
                    active_orders=len(self.active_orders["long"]) + len(self.active_orders["short"]),
                    grid_levels=len(self.grid_levels))
```

### 6.2 告警系统

#### 6.2.1 告警配置
```python
class AlertManager:
    """告警管理器"""
    
    def __init__(self, webhook_url: str):
        self.webhook_url = webhook_url
        self.alert_rules = {
            "high_drawdown": {"threshold": 0.05, "enabled": True},
            "api_error": {"threshold": 5, "enabled": True},
            "fund_shortage": {"threshold": 0.1, "enabled": True},
            "position_risk": {"threshold": 0.8, "enabled": True},
        }
    
    async def check_and_send_alerts(self, metrics: RiskMetrics):
        """检查并发送告警"""
        # 检查回撤告警
        if metrics.max_drawdown > self.alert_rules["high_drawdown"]["threshold"]:
            await self.send_alert("HIGH_DRAWDOWN", 
                                f"最大回撤达到{metrics.max_drawdown:.2%}")
        
        # 检查持仓风险告警
        if metrics.position_ratio > self.alert_rules["position_risk"]["threshold"]:
            await self.send_alert("POSITION_RISK", 
                                f"持仓比例达到{metrics.position_ratio:.2%}")
```

## 7. 部署与运维

### 7.1 配置管理

#### 7.1.1 策略配置
```python
# config/strategy_config.py
STRATEGY_CONFIG = {
    "symbol": "BTCUSDT",
    "base_currency": "BTC",
    "quote_currency": "USDT",
    
    # ATR参数
    "atr_period": 14,
    "atr_multiplier": 2.0,
    "kline_interval": "1h",
    
    # 网格参数
    "max_levels": 10,
    "leverage": 5,
    "safety_factor": 0.9,
    
    # 风险控制
    "max_drawdown": 0.10,
    "position_limit": 0.80,
    "stop_loss_threshold": -1000,
    
    # 运行参数
    "check_interval": 1,
    "sync_interval": 5,
    "log_level": "INFO",
}
```

#### 7.1.2 账户配置
```python
# config/account_config.py
ACCOUNT_CONFIG = {
    "long_account": {
        "api_key": "your_long_api_key",
        "api_secret": "your_long_api_secret",
        "testnet": False,
        "permissions": ["FUTURES_TRADING"],
    },
    "short_account": {
        "api_key": "your_short_api_key",
        "api_secret": "your_short_api_secret",
        "testnet": False,
        "permissions": ["FUTURES_TRADING"],
    }
}
```

### 7.2 启动脚本

#### 7.2.1 主启动脚本
```bash
#!/bin/bash
# start.sh

# 设置环境变量
export PYTHONPATH=/root/GirdBot:$PYTHONPATH
export LOG_LEVEL=INFO

# 创建日志目录
mkdir -p logs

# 启动策略
python3 main.py \
    --config config/strategy_config.py \
    --accounts config/account_config.py \
    --log-file logs/strategy.log \
    --daemon
```

#### 7.2.2 Docker部署
```dockerfile
FROM python:3.9-slim

WORKDIR /app

# 安装依赖
COPY requirements.txt .
RUN pip install -r requirements.txt

# 复制代码
COPY . .

# 设置环境变量
ENV PYTHONPATH=/app
ENV LOG_LEVEL=INFO

# 启动命令
CMD ["python", "main.py"]
```

### 7.3 监控面板

#### 7.3.1 关键指标监控
```python
# 监控指标
MONITORING_METRICS = {
    "strategy_status": "运行状态",
    "total_pnl": "总盈亏",
    "realized_pnl": "已实现盈亏",
    "unrealized_pnl": "未实现盈亏",
    "max_drawdown": "最大回撤",
    "position_ratio": "持仓比例",
    "margin_ratio": "保证金比例",
    "active_orders": "活跃订单数",
    "grid_levels": "网格层数",
    "api_latency": "API延迟",
    "error_rate": "错误率",
}
```

## 8. 总结

### 8.1 策略优势
1. **市场中性**：双账户对冲，降低方向性风险
2. **自适应网格**：基于ATR的动态参数调整
3. **严格风控**：多层次风险控制机制
4. **高度自动化**：全自动化交易执行
5. **完善监控**：实时监控和告警系统

### 8.2 技术特点
1. **高性能**：异步处理，WebSocket实时数据
2. **高可靠性**：重试机制，异常处理
3. **易维护**：模块化设计，清晰架构
4. **易扩展**：插件化组件，配置化参数

### 8.3 适用场景
1. **震荡市场**：适合在波动较大的市场中运行
2. **中性策略**：适合追求稳定收益的投资者
3. **自动化交易**：适合需要24小时运行的交易策略
4. **风险管理**：适合有严格风控要求的交易场景

### 8.4 注意事项
1. **资金要求**：需要充足的资金支持双账户运行
2. **API限制**：需要合理控制API调用频率
3. **网络稳定**：需要稳定的网络连接
4. **监控运维**：需要持续的监控和维护

---

*本文档详细介绍了双账号对冲网格策略的技术实现，包括指标计算、交易逻辑、风险控制等核心内容。在实际部署时，请根据具体需求调整相关参数。*
