# 双账号对冲网格策略详细说明文档

## 目录
- [策略概述](#策略概述)
- [策略指标计算详细逻辑](#策略指标计算详细逻辑)
- [策略详细的交易逻辑](#策略详细的交易逻辑)
- [策略风控逻辑](#策略风控逻辑)
- [参数配置指南](#参数配置指南)
- [实施要点](#实施要点)

---

## 策略概述

双账号对冲网格策略是一种基于币安期货的自动化交易策略，通过两个独立账户同时在相同价格点位进行多空对冲，降低方向性风险的同时获取网格震荡收益。策略采用ATR指标动态计算网格参数，结合多层风控机制确保资金安全。

### 核心理念
- **双向对冲**: 多头账户做多，空头账户做空，对冲方向性风险
- **网格补仓**: 在ATR通道内按固定间距布置买卖网格
- **动态调整**: 根据市场波动性实时调整网格参数
- **多层止损**: ATR突破、资金监控、紧急停止等多重保护

---

## 策略指标计算详细逻辑

### 1. ATR (Average True Range) 指标计算

#### 1.1 ATR计算公式
ATR采用与TradingView完全一致的RMA (Recursive Moving Average) 算法：

```python
def calculate_atr(self, klines: List, period: int = 14) -> Decimal:
    """
    计算ATR值 - 使用TradingView相同的RMA方法
    
    True Range (TR) = max(
        high - low,
        abs(high - previous_close),
        abs(low - previous_close)
    )
    
    ATR = RMA(TR, period)
    RMA = (previous_rma * (period - 1) + current_tr) / period
    """
    true_ranges = []
    
    for i in range(1, len(klines)):
        high = Decimal(str(klines[i][2]))      # 当前最高价
        low = Decimal(str(klines[i][3]))       # 当前最低价
        prev_close = Decimal(str(klines[i-1][4]))  # 前一根K线收盘价
        
        # 计算真实波幅
        tr1 = high - low
        tr2 = abs(high - prev_close) 
        tr3 = abs(low - prev_close)
        
        true_range = max(tr1, tr2, tr3)
        true_ranges.append(true_range)
    
    # 使用RMA计算ATR
    if len(true_ranges) < period:
        return None
        
    # 初始ATR = 前period个TR的简单平均
    atr = sum(true_ranges[:period]) / period
    
    # 递归计算剩余部分
    for i in range(period, len(true_ranges)):
        atr = (atr * (period - 1) + true_ranges[i]) / period
    
    return atr
```

#### 1.2 ATR通道边界计算

```python
def calculate_atr_channel(self, klines: List, multiplier: Decimal = Decimal("2.0")) -> tuple:
    """
    计算ATR通道上下边界
    
    Args:
        klines: K线数据
        multiplier: ATR倍数 (默认2.0)
    
    Returns:
        (upper_bound, lower_bound, atr_value)
    """
    atr_value = self.calculate_atr(klines)
    
    # 获取最近N根K线的最高价和最低价
    recent_highs = [Decimal(str(k[2])) for k in klines[-self.lookback_period:]]
    recent_lows = [Decimal(str(k[3])) for k in klines[-self.lookback_period:]]
    
    highest_high = max(recent_highs)
    lowest_low = min(recent_lows)
    
    # 计算通道边界
    upper_bound = highest_high + (atr_value * multiplier)
    lower_bound = lowest_low - (atr_value * multiplier)
    
    return upper_bound, lower_bound, atr_value
```

### 2. 网格间距计算

#### 2.1 网格间距公式

```python
def calculate_grid_spacing(self, atr_value: Decimal, spacing_multiplier: Decimal = Decimal("0.26")) -> Decimal:
    """
    计算网格间距
    
    网格间距 = ATR × 间距倍数
    
    Args:
        atr_value: ATR值
        spacing_multiplier: 间距倍数 (默认0.26)
    
    Returns:
        网格间距
    """
    grid_spacing = atr_value * spacing_multiplier
    return grid_spacing
```

#### 2.2 网格层数计算

```python
def calculate_max_levels(self, upper_bound: Decimal, lower_bound: Decimal, grid_spacing: Decimal) -> int:
    """
    计算最大网格层数
    
    网格层数 = (上边界 - 下边界) / 网格间距
    """
    price_range = upper_bound - lower_bound
    max_levels = int(price_range / grid_spacing)
    
    # 确保至少有1层网格
    return max(1, max_levels)
```

### 3. 资金管理计算

#### 3.1 每格投资金额计算

```python
def calculate_amount_per_grid(self, total_available: Decimal, grid_levels: int, 
                            utilization_rate: Decimal = Decimal("0.9")) -> Decimal:
    """
    计算每格投资金额
    
    每格金额 = (总可用资金 × 资金利用率) / 网格层数
    
    Args:
        total_available: 总可用资金
        grid_levels: 网格层数
        utilization_rate: 资金利用率 (默认90%)
    
    Returns:
        每格投资金额
    """
    usable_funds = total_available * utilization_rate
    amount_per_grid = usable_funds / Decimal(str(grid_levels))
    
    return amount_per_grid
```

#### 3.2 杠杆倍数动态计算

```python
def estimate_leverage(self, total_notional: Decimal, unified_margin: Decimal, 
                     mmr: Decimal, safety_factor: Decimal = Decimal("0.8")) -> int:
    """
    动态计算可用杠杆倍数
    
    理论最大杠杆 = 统一保证金 / (总名义价值 × MMR)
    实际可用杠杆 = 理论最大杠杆 × 安全系数
    
    Args:
        total_notional: 总名义价值
        unified_margin: 统一保证金
        mmr: 维持保证金率
        safety_factor: 安全系数 (默认80%)
    
    Returns:
        可用杠杆倍数
    """
    if total_notional == 0:
        return 1
        
    # 计算理论最大杠杆
    theoretical_max_leverage = unified_margin / (total_notional * mmr)
    
    # 应用安全系数
    usable_leverage = theoretical_max_leverage * safety_factor
    
    # 确保杠杆在合理范围内 (1-100倍)
    return max(1, min(100, int(usable_leverage)))
```

### 4. 精度和下单参数调整

#### 4.1 价格精度调整

```python
def adjust_price_precision(self, price: Decimal, symbol_info: Dict) -> Decimal:
    """
    调整价格精度以符合交易所要求
    
    根据tickSize调整价格到最接近的有效价格
    """
    tick_size = Decimal(str(symbol_info['filters'][0]['tickSize']))
    
    # 价格必须是tickSize的整数倍
    adjusted_price = (price / tick_size).quantize(Decimal('1'), rounding=ROUND_DOWN) * tick_size
    
    return adjusted_price
```

#### 4.2 数量精度调整

```python
def adjust_quantity_precision(self, quantity: Decimal, symbol_info: Dict) -> Decimal:
    """
    调整数量精度以符合交易所要求
    
    根据stepSize调整数量到最接近的有效数量
    """
    step_size = Decimal(str(symbol_info['filters'][1]['stepSize']))
    
    # 数量必须是stepSize的整数倍
    adjusted_quantity = (quantity / step_size).quantize(Decimal('1'), rounding=ROUND_DOWN) * step_size
    
    return adjusted_quantity
```

---

## 策略详细的交易逻辑

### 1. 双向挂单补仓策略架构

#### 1.1 策略核心理念

```
价格上涨 ← ATR上边界 ← 网格区间 → ATR下边界 → 价格下跌
    ↑              ↑                    ↑              ↑
空头止损        空头主要交易区间        多头主要交易区间      多头止损
```

#### 1.2 双账户角色分工

**多头账户 (Long Account)**:
- **交易方向**: 始终挂BUY订单
- **持仓方向**: 建立LONG仓位  
- **盈利模式**: 价格上涨时获利，下跌时通过补仓降低成本
- **挂单策略**: 在所有网格点位挂买单

**空头账户 (Short Account)**:
- **交易方向**: 始终挂SELL订单
- **持仓方向**: 建立SHORT仓位
- **盈利模式**: 价格下跌时获利，上涨时通过补仓降低成本  
- **挂单策略**: 在所有网格点位挂卖单

### 2. 网格生成和激活逻辑

#### 2.1 网格层级生成

```python
def _generate_grid_levels(self):
    """
    生成网格层级 (双向挂单补仓策略)
    
    核心逻辑:
    - 多头账户: 在所有网格点位都挂买单(BUY)，做多LONG仓位
    - 空头账户: 在所有网格点位都挂卖单(SELL)，做空SHORT仓位  
    - 无论价格高于还是低于当前价，挂单方向保持一致
    """
    self.grid_levels.clear()
    
    # 使用ATR计算得到的上下边界和网格间距
    upper_limit = self.upper_boundary
    lower_limit = self.lower_boundary  
    grid_spacing = self.grid_spacing
    
    # 计算网格层数
    price_range = upper_limit - lower_limit
    total_levels = int(price_range / grid_spacing)
    total_levels = max(1, total_levels)
    
    # 从下边界开始，按网格间距依次生成所有网格
    for i in range(total_levels):
        grid_price = lower_limit + (grid_spacing * i)
        
        # 确保不超过上边界
        if grid_price > upper_limit:
            break
            
        # 计算每格的下单数量
        grid_quantity = self.base_position_size / grid_price
        
        # 创建网格层级
        grid_level = GridLevel(
            level_id=f"grid_{i}",
            price=grid_price,
            quantity=grid_quantity,
            level=i
        )
        
        self.grid_levels.append(grid_level)
```

#### 2.2 动态网格激活管理

```python
async def manage_dynamic_grids(self):
    """
    动态网格管理 - 根据当前价格激活附近的网格
    """
    current_price = await self.get_current_price()
    
    # 按与当前价格的距离排序
    sorted_grids = sorted(self.grid_levels, 
                         key=lambda g: abs(g.price - current_price))
    
    # 分配给多头和空头账户的最大挂单数
    max_orders_per_account = self.config.max_open_orders // 2
    
    # 多头账户挂单管理
    await self.manage_long_buy_orders_bidirectional(
        current_price, max_orders_per_account
    )
    
    # 空头账户挂单管理  
    await self.manage_short_sell_orders_bidirectional(
        current_price, max_orders_per_account
    )
```

### 3. 具体挂单执行逻辑

#### 3.1 多头账户挂单逻辑

```python
async def manage_long_buy_orders_bidirectional(self, current_price: Decimal, max_orders: int):
    """
    多头账户双向挂买单管理
    
    策略逻辑:
    - 市价上方挂买单: 价格突破后的补仓单
    - 市价下方挂买单: 价格回调时的主要建仓单
    """
    # 筛选市价上方和下方的网格
    above_grids = [grid for grid in self.grid_levels if grid.price > current_price]
    below_grids = [grid for grid in self.grid_levels if grid.price < current_price]
    
    # 按距离当前价排序 (近的优先)
    above_grids.sort(key=lambda g: g.price)
    below_grids.sort(key=lambda g: g.price, reverse=True)
    
    # 计算上方和下方各分配多少个订单
    orders_above = max_orders // 2  # 上方挂单数量
    orders_below = max_orders - orders_above  # 下方挂单数量
    
    # 管理市价上方的买单 (补仓单)
    await self.manage_grid_orders(above_grids, orders_above, "long", "ABOVE")
    
    # 管理市价下方的买单 (主要交易单)
    await self.manage_grid_orders(below_grids, orders_below, "long", "BELOW")
```

#### 3.2 空头账户挂单逻辑

```python
async def manage_short_sell_orders_bidirectional(self, current_price: Decimal, max_orders: int):
    """
    空头账户双向挂卖单管理
    
    策略逻辑:
    - 市价上方挂卖单: 价格上涨时的主要建仓单
    - 市价下方挂卖单: 价格下跌后的补仓单
    """
    # 筛选市价上方和下方的网格
    above_grids = [grid for grid in self.grid_levels if grid.price > current_price]
    below_grids = [grid for grid in self.grid_levels if grid.price < current_price]
    
    # 按距离当前价排序 (近的优先)
    above_grids.sort(key=lambda g: g.price)
    below_grids.sort(key=lambda g: g.price, reverse=True)
    
    # 计算上方和下方各分配多少个订单
    orders_above = max_orders // 2  # 上方挂单数量
    orders_below = max_orders - orders_above  # 下方挂单数量
    
    # 管理市价上方的卖单 (主要交易单)
    await self.manage_grid_orders(above_grids, orders_above, "short", "ABOVE")
    
    # 管理市价下方的卖单 (补仓单)
    await self.manage_grid_orders(below_grids, orders_below, "short", "BELOW")
```

### 4. 订单执行和管理

#### 4.1 通用网格订单管理

```python
async def manage_grid_orders(self, grids: list, target_count: int, account_type: str, direction: str):
    """
    通用的网格订单管理函数
    
    Args:
        grids: 网格列表
        target_count: 目标挂单数量
        account_type: 账户类型 ("long" 或 "short")
        direction: 方向标识 ("ABOVE" 或 "BELOW")
    """
    # 检查当前活跃的订单
    active_orders = [
        grid for grid in grids 
        if grid.open_order_status == OrderStatus.PENDING
    ]
    
    # 如果活跃订单少于目标数量，添加新订单
    if len(active_orders) < target_count:
        needed_orders = target_count - len(active_orders)
        
        # 从离当前价最近的网格开始挂单
        for grid in grids[:needed_orders]:
            if grid.open_order_status == OrderStatus.NOT_ACTIVE:
                await self.place_grid_order(grid, account_type)
                self.logger.info(f"激活{direction}方向网格订单: 价格={grid.price}, 账户={account_type}")
    
    # 如果活跃订单超过目标数量，取消距离最远的订单
    elif len(active_orders) > target_count:
        excess_orders = len(active_orders) - target_count
        
        # 取消距离当前价最远的订单 (在grids列表的末尾)
        orders_to_cancel = active_orders[-excess_orders:]
        for grid in orders_to_cancel:
            await self.cancel_grid_order(grid, account_type)
            self.logger.info(f"取消{direction}方向网格订单: 价格={grid.price}, 账户={account_type}")
```

#### 4.2 具体下单执行

```python
async def place_grid_order(self, grid: GridLevel, account_type: str):
    """
    挂出网格订单 (双向挂单补仓策略)
    
    核心逻辑:
    - 多头账户(long): 始终挂买单(BUY)，建立LONG仓位
    - 空头账户(short): 始终挂卖单(SELL)，建立SHORT仓位
    """
    try:
        # 根据账户类型确定交易方向和持仓方向
        if account_type == "long":
            side = "BUY"           # 多头账户买入
            position_side = "LONG" # 建立多头仓位
            client = self.dual_manager.long_account
        else:  # account_type == "short"
            side = "SELL"          # 空头账户卖出
            position_side = "SHORT" # 建立空头仓位
            client = self.dual_manager.short_account
        
        # 精度调整
        adjusted_price, adjusted_quantity = self.adjust_order_precision(
            grid.price, grid.quantity
        )
        
        # 资金充足性检查
        if not await self.check_sufficient_funds(account_type, adjusted_quantity, adjusted_price):
            self.logger.warning(f"资金不足，跳过订单: {grid.level_id}")
            return
        
        # 下单
        result = await client.place_order(
            symbol=self.config.symbol,
            side=side,
            order_type="LIMIT",
            quantity=str(adjusted_quantity),
            price=str(adjusted_price),
            positionSide=position_side,
            timeInForce="GTC"
        )
        
        # 更新网格状态
        if result and not isinstance(result, Exception):
            grid.open_order_id = str(result["orderId"])
            grid.open_order_status = OrderStatus.PENDING
            grid.price = adjusted_price
            grid.quantity = adjusted_quantity
            
            self.logger.info(
                f"网格订单已挂出: {grid.level_id}, "
                f"方向: {side}->{position_side}, "
                f"价格: {grid.price}, "
                f"订单ID: {grid.open_order_id}"
            )
            
    except Exception as e:
        self.logger.error(f"挂出网格订单失败: {e}")
        self.logger.error(f"订单详情: 账户={account_type}, 网格={grid.level_id}, 价格={grid.price}")
```

### 5. 成交处理和止盈逻辑

#### 5.1 订单成交检测

```python
async def check_filled_orders(self):
    """
    检查已成交的订单并处理
    """
    for grid in self.grid_levels:
        if grid.open_order_status == OrderStatus.PENDING and grid.open_order_id:
            # 查询订单状态
            order_status = await self.query_order_status(grid.open_order_id, grid.account_type)
            
            if order_status == "FILLED":
                await self.handle_filled_order(grid)
```

#### 5.2 成交订单处理

```python
async def handle_filled_order(self, grid: GridLevel):
    """
    处理已成交的网格订单
    
    成交后的处理逻辑:
    1. 更新网格状态
    2. 创建止盈订单 (可选)
    3. 重新激活该网格层级
    """
    try:
        # 更新网格状态
        grid.open_order_status = OrderStatus.FILLED
        grid.filled_time = time.time()
        
        self.logger.info(f"网格订单成交: {grid.level_id}, 价格: {grid.price}")
        
        # 创建止盈订单 (可选功能)
        if self.config.enable_take_profit:
            await self.create_take_profit_order(grid)
        
        # 重新激活该网格 (为下次交易做准备)
        grid.open_order_status = OrderStatus.NOT_ACTIVE
        grid.open_order_id = None
        
        # 更新交易统计
        self.update_trading_stats(grid)
        
    except Exception as e:
        self.logger.error(f"处理成交订单失败: {e}")
```

---

## 策略风控逻辑

### 1. 多层风控架构

```
┌─────────────────────────────────────────────────────────┐
│                     风控层级架构                          │
├─────────────────────────────────────────────────────────┤
│ 第一层: 启动风控                                          │
│ ├─ 双账户连接验证                                         │
│ ├─ 账户权限检查                                          │
│ ├─ 资金充足性验证                                         │
│ └─ 持仓模式确认                                          │
├─────────────────────────────────────────────────────────┤
│ 第二层: 运行风控                                          │
│ ├─ ATR通道突破监控                                       │
│ ├─ 账户健康状态检查                                       │
│ ├─ 资金实时监控                                          │
│ └─ 订单执行监控                                          │
├─────────────────────────────────────────────────────────┤
│ 第三层: 紧急风控                                          │
│ ├─ 紧急止损触发                                          │
│ ├─ 账户异常处理                                          │
│ ├─ 网络连接监控                                          │
│ └─ 系统异常保护                                          │
└─────────────────────────────────────────────────────────┘
```

### 2. ATR通道突破止损

#### 2.1 突破检测逻辑

```python
class StopLossManager:
    """止损管理器 - 核心风控组件"""
    
    async def check_atr_breakout(self, current_price: Decimal) -> bool:
        """
        检查ATR通道突破
        
        突破条件:
        - 价格突破上边界: current_price > upper_boundary
        - 价格突破下边界: current_price < lower_boundary
        
        Args:
            current_price: 当前价格
            
        Returns:
            bool: 是否发生突破
        """
        try:
            # 获取ATR通道边界
            upper_boundary = self.upper_boundary
            lower_boundary = self.lower_boundary
            
            # 检查突破
            upper_breakout = current_price > upper_boundary
            lower_breakout = current_price < lower_boundary
            
            if upper_breakout:
                self.logger.warning(f"⚠️  ATR上轨突破! 当前价格: {current_price}, 上边界: {upper_boundary}")
                self.breakout_direction = "UPPER"
                return True
                
            elif lower_breakout:
                self.logger.warning(f"⚠️  ATR下轨突破! 当前价格: {current_price}, 下边界: {lower_boundary}")
                self.breakout_direction = "LOWER"
                return True
                
            return False
            
        except Exception as e:
            self.logger.error(f"ATR突破检测失败: {e}")
            return False
```

#### 2.2 止损执行流程

```python
async def execute_stop_loss(self, reason: str = "ATR_BREAKOUT"):
    """
    执行止损操作
    
    止损执行顺序:
    1. 立即取消所有挂单
    2. 评估账户浮动盈亏
    3. 优先平仓浮亏较大的账户
    4. 有序平仓所有持仓
    5. 停止策略运行
    """
    try:
        self.is_stop_loss_active = True
        self.logger.critical(f"🛑 执行止损操作! 原因: {reason}")
        
        # 第一步: 立即取消所有挂单
        self.logger.info("第一步: 取消所有挂单...")
        cancel_results = await self._cancel_all_orders()
        
        # 第二步: 获取当前持仓
        self.logger.info("第二步: 获取账户持仓...")
        long_positions = await self.dual_manager.long_account.get_positions(self.symbol)
        short_positions = await self.dual_manager.short_account.get_positions(self.symbol)
        
        # 第三步: 评估浮动盈亏
        long_pnl = self._calculate_unrealized_pnl(long_positions)
        short_pnl = self._calculate_unrealized_pnl(short_positions)
        
        self.logger.info(f"账户浮动盈亏: 多头={long_pnl:.4f}, 空头={short_pnl:.4f}")
        
        # 第四步: 确定平仓顺序 (浮亏大的优先)
        if long_pnl <= short_pnl:
            # 多头亏损更大，优先平多头
            await self._close_positions_orderly([
                ("long", long_positions),
                ("short", short_positions)
            ])
        else:
            # 空头亏损更大，优先平空头
            await self._close_positions_orderly([
                ("short", short_positions), 
                ("long", long_positions)
            ])
        
        # 第五步: 记录止损结果
        self._log_stop_loss_result(reason, long_pnl, short_pnl)
        
        # 第六步: 停止策略
        await self.strategy.stop_strategy()
        
    except Exception as e:
        self.logger.critical(f"止损执行失败: {e}")
        # 紧急情况下强制停止
        await self.emergency_stop()
```

### 3. 账户健康监控

#### 3.1 双账户同步检查

```python
async def check_dual_account_health(self) -> bool:
    """
    检查双账户健康状态
    
    检查项目:
    1. 连接状态
    2. API权限
    3. 账户余额
    4. 持仓状态
    5. 同步状态
    """
    try:
        # 并行检查双账户状态
        long_health, short_health = await asyncio.gather(
            self._check_single_account_health(self.dual_manager.long_account, "long"),
            self._check_single_account_health(self.dual_manager.short_account, "short"),
            return_exceptions=True
        )
        
        # 任一账户异常都触发保护
        if isinstance(long_health, Exception) or isinstance(short_health, Exception):
            self.logger.error(f"账户健康检查异常: long={long_health}, short={short_health}")
            return False
            
        if not long_health or not short_health:
            self.logger.error(f"账户健康状态异常: long={long_health}, short={short_health}")
            return False
            
        return True
        
    except Exception as e:
        self.logger.error(f"双账户健康检查失败: {e}")
        return False

async def _check_single_account_health(self, account, account_type: str) -> bool:
    """
    检查单个账户健康状态
    """
    try:
        # 检查连接
        account_info = await account.get_account_info()
        if not account_info:
            self.logger.error(f"{account_type}账户连接失败")
            return False
            
        # 检查余额
        available_balance = Decimal(account_info.get('availableBalance', '0'))
        if available_balance <= 0:
            self.logger.warning(f"{account_type}账户余额不足: {available_balance}")
            
        # 检查API权限
        permissions = account_info.get('permissions', [])
        if 'FUTURES' not in permissions:
            self.logger.error(f"{account_type}账户缺少期货权限")
            return False
            
        return True
        
    except Exception as e:
        self.logger.error(f"{account_type}账户健康检查失败: {e}")
        return False
```

#### 3.2 启动安全验证

```python
async def startup_safety_check(self) -> bool:
    """
    启动安全验证
    
    验证项目:
    1. 双账户同时健康启动
    2. 交易对配置正确
    3. 资金充足性
    4. 持仓模式正确
    5. 杠杆设置成功
    """
    try:
        self.logger.info("开始启动安全验证...")
        
        # 1. 双账户健康检查
        if not await self.check_dual_account_health():
            self.logger.error("❌ 双账户健康检查失败")
            return False
        self.logger.info("✅ 双账户健康检查通过")
        
        # 2. 交易对验证
        if not await self._verify_symbol_config():
            self.logger.error("❌ 交易对配置验证失败")
            return False
        self.logger.info("✅ 交易对配置验证通过")
        
        # 3. 资金充足性验证
        if not await self._verify_fund_adequacy():
            self.logger.error("❌ 资金充足性验证失败")
            return False
        self.logger.info("✅ 资金充足性验证通过")
        
        # 4. 持仓模式验证
        if not await self._verify_position_mode():
            self.logger.error("❌ 持仓模式验证失败")
            return False
        self.logger.info("✅ 持仓模式验证通过")
        
        # 5. 杠杆设置验证
        if not await self._verify_leverage_setting():
            self.logger.error("❌ 杠杆设置验证失败")
            return False
        self.logger.info("✅ 杠杆设置验证通过")
        
        self.logger.info("🎉 启动安全验证完成!")
        return True
        
    except Exception as e:
        self.logger.error(f"启动安全验证异常: {e}")
        return False
```

### 4. 资金风控

#### 4.1 实时资金监控

```python
async def monitor_fund_safety(self):
    """
    实时资金安全监控
    
    监控指标:
    1. 保证金比率
    2. 可用余额
    3. 未实现盈亏
    4. 强平风险
    """
    try:
        # 获取双账户资金状态
        long_info = await self.dual_manager.long_account.get_account_info()
        short_info = await self.dual_manager.short_account.get_account_info()
        
        # 计算关键指标
        long_margin_ratio = self._calculate_margin_ratio(long_info)
        short_margin_ratio = self._calculate_margin_ratio(short_info)
        
        # 保证金比率预警
        if long_margin_ratio > 0.8 or short_margin_ratio > 0.8:
            self.logger.warning(
                f"⚠️  保证金比率过高! "
                f"多头: {long_margin_ratio:.2%}, "
                f"空头: {short_margin_ratio:.2%}"
            )
            
        # 强平风险预警
        if long_margin_ratio > 0.9 or short_margin_ratio > 0.9:
            self.logger.critical(
                f"🚨 强平风险警告! "
                f"多头: {long_margin_ratio:.2%}, "
                f"空头: {short_margin_ratio:.2%}"
            )
            
            # 触发紧急减仓
            await self.emergency_reduce_positions()
            
    except Exception as e:
        self.logger.error(f"资金监控失败: {e}")

def _calculate_margin_ratio(self, account_info: Dict) -> float:
    """
    计算保证金比率
    
    保证金比率 = 已用保证金 / 总资产
    """
    total_wallet_balance = float(account_info.get('totalWalletBalance', 0))
    total_margin_balance = float(account_info.get('totalMarginBalance', 0))
    
    if total_wallet_balance == 0:
        return 1.0
        
    return total_margin_balance / total_wallet_balance
```

#### 4.2 下单前资金检查

```python
async def check_sufficient_funds(self, account_type: str, quantity: Decimal, price: Decimal) -> bool:
    """
    下单前资金充足性检查
    
    检查项目:
    1. 可用余额是否充足
    2. 保证金需求计算
    3. 最小名义价值验证
    4. 强平风险评估
    """
    try:
        # 获取账户信息
        if account_type == "long":
            account_info = await self.dual_manager.long_account.get_account_info()
        else:
            account_info = await self.dual_manager.short_account.get_account_info()
            
        available_balance = Decimal(account_info.get('availableBalance', '0'))
        
        # 计算订单所需保证金
        order_notional = quantity * price  # 名义价值
        required_margin = order_notional / self.config.leverage  # 所需保证金
        
        # 检查可用余额
        if available_balance < required_margin:
            self.logger.warning(
                f"下单前资金检查失败:\n"
                f"  订单名义价值: {order_notional:.2f} USDC\n"
                f"  订单保证金需求: {required_margin:.2f} USDC\n" 
                f"  可用余额: {available_balance:.2f} USDC\n"
                f"  跳过此订单: {account_type}"
            )
            return False
            
        # 检查最小名义价值
        min_notional = await self._get_min_notional()
        if order_notional < min_notional:
            self.logger.warning(f"订单名义价值不足最小值: {order_notional} < {min_notional}")
            return False
            
        return True
        
    except Exception as e:
        self.logger.error(f"资金检查失败: {e}")
        return False
```

### 5. 紧急风控机制

#### 5.1 紧急停止逻辑

```python
async def emergency_stop(self, reason: str = "EMERGENCY"):
    """
    紧急停止机制
    
    紧急情况处理:
    1. 立即停止所有交易活动
    2. 取消所有挂单
    3. 记录紧急停止原因
    4. 发送告警通知
    5. 安全关闭系统
    """
    try:
        self.is_emergency_stopped = True
        self.logger.critical(f"🚨 紧急停止触发! 原因: {reason}")
        
        # 1. 设置紧急停止标志
        self.strategy_status = StrategyStatus.EMERGENCY_STOPPED
        
        # 2. 并行取消所有挂单 (容错处理)
        cancel_tasks = []
        try:
            cancel_tasks.append(
                self.dual_manager.long_account.cancel_all_orders(self.config.symbol)
            )
            cancel_tasks.append(
                self.dual_manager.short_account.cancel_all_orders(self.config.symbol)
            )
            
            # 等待取消完成，但不阻塞
            await asyncio.wait_for(
                asyncio.gather(*cancel_tasks, return_exceptions=True),
                timeout=10.0
            )
        except asyncio.TimeoutError:
            self.logger.warning("取消订单超时，继续紧急停止流程")
        except Exception as e:
            self.logger.error(f"取消订单失败: {e}")
        
        # 3. 记录紧急停止信息
        self._log_emergency_stop(reason)
        
        # 4. 发送告警通知 (如果配置了)
        if hasattr(self, 'notifier'):
            await self.notifier.send_emergency_alert(reason)
            
        # 5. 安全关闭
        self.logger.critical("紧急停止完成，系统已安全关闭")
        
    except Exception as e:
        self.logger.critical(f"紧急停止执行失败: {e}")
        # 即使紧急停止失败，也要设置停止标志
        self.is_emergency_stopped = True
```

#### 5.2 异常恢复机制

```python
async def handle_strategy_exception(self, exception: Exception):
    """
    策略异常处理和恢复
    
    异常分类处理:
    1. 网络异常 -> 重试
    2. API异常 -> 限制重试
    3. 资金异常 -> 紧急停止
    4. 系统异常 -> 紧急停止
    """
    try:
        exception_type = type(exception).__name__
        exception_msg = str(exception)
        
        self.logger.error(f"策略异常: {exception_type} - {exception_msg}")
        
        # 根据异常类型分类处理
        if self._is_network_exception(exception):
            # 网络异常 - 重试机制
            await self._handle_network_exception(exception)
            
        elif self._is_api_exception(exception):
            # API异常 - 限制重试
            await self._handle_api_exception(exception)
            
        elif self._is_fund_exception(exception):
            # 资金异常 - 紧急停止
            await self.emergency_stop(f"FUND_EXCEPTION: {exception_msg}")
            
        else:
            # 未知异常 - 紧急停止
            await self.emergency_stop(f"UNKNOWN_EXCEPTION: {exception_msg}")
            
    except Exception as e:
        self.logger.critical(f"异常处理器失败: {e}")
        await self.emergency_stop("EXCEPTION_HANDLER_FAILED")

def _is_network_exception(self, exception: Exception) -> bool:
    """判断是否为网络异常"""
    network_keywords = ['timeout', 'connection', 'network', 'socket']
    exception_str = str(exception).lower()
    return any(keyword in exception_str for keyword in network_keywords)

def _is_api_exception(self, exception: Exception) -> bool:
    """判断是否为API异常"""
    api_keywords = ['rate limit', '429', 'too many requests', 'api']
    exception_str = str(exception).lower()
    return any(keyword in exception_str for keyword in api_keywords)

def _is_fund_exception(self, exception: Exception) -> bool:
    """判断是否为资金异常"""
    fund_keywords = ['insufficient', 'margin', 'balance', '2019']
    exception_str = str(exception).lower()
    return any(keyword in exception_str for keyword in fund_keywords)
```

---

## 参数配置指南

### 1. 核心策略参数

```python
# 推荐配置参数
RECOMMENDED_CONFIG = {
    # ATR指标参数
    "atr_period": 14,                    # ATR计算周期
    "atr_period_timeframe": "1h",        # ATR时间框架
    "atr_multiplier": 2.0,               # ATR通道倍数
    "grid_spacing_percent": 0.26,        # 网格间距倍数
    
    # 资金管理参数
    "leverage": 3,                       # 杠杆倍数 (推荐3-5倍)
    "max_open_orders": 6,                # 最大挂单数 (双账户总计)
    "fund_utilization_rate": 0.9,       # 资金利用率 (90%)
    "safety_factor": 0.8,                # 安全系数 (80%)
    
    # 风控参数
    "margin_ratio_warning": 0.8,         # 保证金比率预警线
    "margin_ratio_emergency": 0.9,       # 保证金比率紧急线
    "max_retry_attempts": 3,             # 最大重试次数
    "retry_delay": 2,                    # 重试延迟 (秒)
    
    # 监控参数
    "monitor_interval": 5,               # 主监控间隔 (秒)
    "health_check_interval": 30,         # 健康检查间隔 (秒)
    "fund_check_interval": 60,           # 资金检查间隔 (秒)
}
```

### 2. 不同市值代币参数调整

```python
# 大市值代币 (BTC, ETH)
LARGE_CAP_CONFIG = {
    "atr_multiplier": 1.5,               # 较小的通道
    "grid_spacing_percent": 0.2,         # 较密的网格
    "leverage": 3,                       # 较低杠杆
    "max_open_orders": 8,                # 更多挂单
}

# 中市值代币 (ADA, DOT, MATIC)
MID_CAP_CONFIG = {
    "atr_multiplier": 2.0,               # 标准通道
    "grid_spacing_percent": 0.26,        # 标准网格
    "leverage": 5,                       # 中等杠杆
    "max_open_orders": 6,                # 标准挂单
}

# 小市值代币 (风险较高)
SMALL_CAP_CONFIG = {
    "atr_multiplier": 2.5,               # 较大的通道
    "grid_spacing_percent": 0.3,         # 较疏的网格
    "leverage": 2,                       # 较低杠杆
    "max_open_orders": 4,                # 较少挂单
    "fund_utilization_rate": 0.7,        # 较低资金利用率
}
```

---

## 实施要点

### 1. 部署前检查清单

```markdown
□ 币安API权限确认 (期货交易权限)
□ 双账户资金充足性验证
□ 网络连接稳定性测试
□ 配置参数合理性检查
□ 测试环境完整验证
□ 监控告警机制配置
□ 紧急联系人设置
□ 风险承受能力评估
```

### 2. 监控要点

```python
# 关键监控指标
KEY_METRICS = {
    "price_breakout": "价格是否突破ATR通道",
    "margin_ratio": "保证金比率是否过高",
    "account_health": "双账户是否健康运行",
    "order_success_rate": "订单成功率",
    "pnl_status": "总体盈亏状况",
    "grid_efficiency": "网格成交效率",
}
```

### 3. 常见问题和解决方案

```markdown
Q: 订单经常被拒绝怎么办？
A: 检查精度设置、最小名义价值、账户余额

Q: ATR通道突破频繁触发止损？
A: 调大ATR倍数或检查市场异常波动

Q: 网格成交率低？
A: 调整网格间距或增加挂单数量

Q: 资金利用率不足？
A: 检查杠杆设置和每格金额计算

Q: 双账户不同步？
A: 检查网络连接和API权限设置
```

---

**文档版本**: v1.0  
**最后更新**: 2025-07-09  
**适用环境**: 币安期货API  
**风险提示**: 本策略涉及杠杆交易，请充分了解风险后使用
