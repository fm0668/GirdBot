# åŒè´¦å·å¯¹å†²ç½‘æ ¼ç­–ç•¥è¯¦ç»†è¯´æ˜æ–‡æ¡£

## ç›®å½•
- [ç­–ç•¥æ¦‚è¿°](#ç­–ç•¥æ¦‚è¿°)
- [ç­–ç•¥æŒ‡æ ‡è®¡ç®—è¯¦ç»†é€»è¾‘](#ç­–ç•¥æŒ‡æ ‡è®¡ç®—è¯¦ç»†é€»è¾‘)
- [ç­–ç•¥è¯¦ç»†çš„äº¤æ˜“é€»è¾‘](#ç­–ç•¥è¯¦ç»†çš„äº¤æ˜“é€»è¾‘)
- [ç­–ç•¥é£æ§é€»è¾‘](#ç­–ç•¥é£æ§é€»è¾‘)
- [å‚æ•°é…ç½®æŒ‡å—](#å‚æ•°é…ç½®æŒ‡å—)
- [å®æ–½è¦ç‚¹](#å®æ–½è¦ç‚¹)

---

## ç­–ç•¥æ¦‚è¿°

åŒè´¦å·å¯¹å†²ç½‘æ ¼ç­–ç•¥æ˜¯ä¸€ç§åŸºäºå¸å®‰æœŸè´§çš„è‡ªåŠ¨åŒ–äº¤æ˜“ç­–ç•¥ï¼Œé€šè¿‡ä¸¤ä¸ªç‹¬ç«‹è´¦æˆ·åŒæ—¶åœ¨ç›¸åŒä»·æ ¼ç‚¹ä½è¿›è¡Œå¤šç©ºå¯¹å†²ï¼Œé™ä½æ–¹å‘æ€§é£é™©çš„åŒæ—¶è·å–ç½‘æ ¼éœ‡è¡æ”¶ç›Šã€‚ç­–ç•¥é‡‡ç”¨ATRæŒ‡æ ‡åŠ¨æ€è®¡ç®—ç½‘æ ¼å‚æ•°ï¼Œç»“åˆå¤šå±‚é£æ§æœºåˆ¶ç¡®ä¿èµ„é‡‘å®‰å…¨ã€‚

### æ ¸å¿ƒç†å¿µ
- **åŒå‘å¯¹å†²**: å¤šå¤´è´¦æˆ·åšå¤šï¼Œç©ºå¤´è´¦æˆ·åšç©ºï¼Œå¯¹å†²æ–¹å‘æ€§é£é™©
- **ç½‘æ ¼è¡¥ä»“**: åœ¨ATRé€šé“å†…æŒ‰å›ºå®šé—´è·å¸ƒç½®ä¹°å–ç½‘æ ¼
- **åŠ¨æ€è°ƒæ•´**: æ ¹æ®å¸‚åœºæ³¢åŠ¨æ€§å®æ—¶è°ƒæ•´ç½‘æ ¼å‚æ•°
- **å¤šå±‚æ­¢æŸ**: ATRçªç ´ã€èµ„é‡‘ç›‘æ§ã€ç´§æ€¥åœæ­¢ç­‰å¤šé‡ä¿æŠ¤

---

## ç­–ç•¥æŒ‡æ ‡è®¡ç®—è¯¦ç»†é€»è¾‘

### 1. ATR (Average True Range) æŒ‡æ ‡è®¡ç®—

#### 1.1 ATRè®¡ç®—å…¬å¼
ATRé‡‡ç”¨ä¸TradingViewå®Œå…¨ä¸€è‡´çš„RMA (Recursive Moving Average) ç®—æ³•ï¼š

```python
def calculate_atr(self, klines: List, period: int = 14) -> Decimal:
    """
    è®¡ç®—ATRå€¼ - ä½¿ç”¨TradingViewç›¸åŒçš„RMAæ–¹æ³•
    
    True Range (TR) = max(
        high - low,
        abs(high - previous_close),
        abs(low - previous_close)
    )
    
    ATR = RMA(TR, period)
    RMA = (previous_rma * (period - 1) + current_tr) / period
    """
    true_ranges = []
    
    for i in range(1, len(klines)):
        high = Decimal(str(klines[i][2]))      # å½“å‰æœ€é«˜ä»·
        low = Decimal(str(klines[i][3]))       # å½“å‰æœ€ä½ä»·
        prev_close = Decimal(str(klines[i-1][4]))  # å‰ä¸€æ ¹Kçº¿æ”¶ç›˜ä»·
        
        # è®¡ç®—çœŸå®æ³¢å¹…
        tr1 = high - low
        tr2 = abs(high - prev_close) 
        tr3 = abs(low - prev_close)
        
        true_range = max(tr1, tr2, tr3)
        true_ranges.append(true_range)
    
    # ä½¿ç”¨RMAè®¡ç®—ATR
    if len(true_ranges) < period:
        return None
        
    # åˆå§‹ATR = å‰periodä¸ªTRçš„ç®€å•å¹³å‡
    atr = sum(true_ranges[:period]) / period
    
    # é€’å½’è®¡ç®—å‰©ä½™éƒ¨åˆ†
    for i in range(period, len(true_ranges)):
        atr = (atr * (period - 1) + true_ranges[i]) / period
    
    return atr
```

#### 1.2 ATRé€šé“è¾¹ç•Œè®¡ç®—

```python
def calculate_atr_channel(self, klines: List, multiplier: Decimal = Decimal("2.0")) -> tuple:
    """
    è®¡ç®—ATRé€šé“ä¸Šä¸‹è¾¹ç•Œ
    
    Args:
        klines: Kçº¿æ•°æ®
        multiplier: ATRå€æ•° (é»˜è®¤2.0)
    
    Returns:
        (upper_bound, lower_bound, atr_value)
    """
    atr_value = self.calculate_atr(klines)
    
    # è·å–æœ€è¿‘Næ ¹Kçº¿çš„æœ€é«˜ä»·å’Œæœ€ä½ä»·
    recent_highs = [Decimal(str(k[2])) for k in klines[-self.lookback_period:]]
    recent_lows = [Decimal(str(k[3])) for k in klines[-self.lookback_period:]]
    
    highest_high = max(recent_highs)
    lowest_low = min(recent_lows)
    
    # è®¡ç®—é€šé“è¾¹ç•Œ
    upper_bound = highest_high + (atr_value * multiplier)
    lower_bound = lowest_low - (atr_value * multiplier)
    
    return upper_bound, lower_bound, atr_value
```

### 2. ç½‘æ ¼é—´è·è®¡ç®—

#### 2.1 ç½‘æ ¼é—´è·å…¬å¼

```python
def calculate_grid_spacing(self, atr_value: Decimal, spacing_multiplier: Decimal = Decimal("0.26")) -> Decimal:
    """
    è®¡ç®—ç½‘æ ¼é—´è·
    
    ç½‘æ ¼é—´è· = ATR Ã— é—´è·å€æ•°
    
    Args:
        atr_value: ATRå€¼
        spacing_multiplier: é—´è·å€æ•° (é»˜è®¤0.26)
    
    Returns:
        ç½‘æ ¼é—´è·
    """
    grid_spacing = atr_value * spacing_multiplier
    return grid_spacing
```

#### 2.2 ç½‘æ ¼å±‚æ•°è®¡ç®—

```python
def calculate_max_levels(self, upper_bound: Decimal, lower_bound: Decimal, grid_spacing: Decimal) -> int:
    """
    è®¡ç®—æœ€å¤§ç½‘æ ¼å±‚æ•°
    
    ç½‘æ ¼å±‚æ•° = (ä¸Šè¾¹ç•Œ - ä¸‹è¾¹ç•Œ) / ç½‘æ ¼é—´è·
    """
    price_range = upper_bound - lower_bound
    max_levels = int(price_range / grid_spacing)
    
    # ç¡®ä¿è‡³å°‘æœ‰1å±‚ç½‘æ ¼
    return max(1, max_levels)
```

### 3. èµ„é‡‘ç®¡ç†è®¡ç®—

#### 3.1 æ¯æ ¼æŠ•èµ„é‡‘é¢è®¡ç®—

```python
def calculate_amount_per_grid(self, total_available: Decimal, grid_levels: int, 
                            utilization_rate: Decimal = Decimal("0.9")) -> Decimal:
    """
    è®¡ç®—æ¯æ ¼æŠ•èµ„é‡‘é¢
    
    æ¯æ ¼é‡‘é¢ = (æ€»å¯ç”¨èµ„é‡‘ Ã— èµ„é‡‘åˆ©ç”¨ç‡) / ç½‘æ ¼å±‚æ•°
    
    Args:
        total_available: æ€»å¯ç”¨èµ„é‡‘
        grid_levels: ç½‘æ ¼å±‚æ•°
        utilization_rate: èµ„é‡‘åˆ©ç”¨ç‡ (é»˜è®¤90%)
    
    Returns:
        æ¯æ ¼æŠ•èµ„é‡‘é¢
    """
    usable_funds = total_available * utilization_rate
    amount_per_grid = usable_funds / Decimal(str(grid_levels))
    
    return amount_per_grid
```

#### 3.2 æ æ†å€æ•°åŠ¨æ€è®¡ç®—

```python
def estimate_leverage(self, total_notional: Decimal, unified_margin: Decimal, 
                     mmr: Decimal, safety_factor: Decimal = Decimal("0.8")) -> int:
    """
    åŠ¨æ€è®¡ç®—å¯ç”¨æ æ†å€æ•°
    
    ç†è®ºæœ€å¤§æ æ† = ç»Ÿä¸€ä¿è¯é‡‘ / (æ€»åä¹‰ä»·å€¼ Ã— MMR)
    å®é™…å¯ç”¨æ æ† = ç†è®ºæœ€å¤§æ æ† Ã— å®‰å…¨ç³»æ•°
    
    Args:
        total_notional: æ€»åä¹‰ä»·å€¼
        unified_margin: ç»Ÿä¸€ä¿è¯é‡‘
        mmr: ç»´æŒä¿è¯é‡‘ç‡
        safety_factor: å®‰å…¨ç³»æ•° (é»˜è®¤80%)
    
    Returns:
        å¯ç”¨æ æ†å€æ•°
    """
    if total_notional == 0:
        return 1
        
    # è®¡ç®—ç†è®ºæœ€å¤§æ æ†
    theoretical_max_leverage = unified_margin / (total_notional * mmr)
    
    # åº”ç”¨å®‰å…¨ç³»æ•°
    usable_leverage = theoretical_max_leverage * safety_factor
    
    # ç¡®ä¿æ æ†åœ¨åˆç†èŒƒå›´å†… (1-100å€)
    return max(1, min(100, int(usable_leverage)))
```

### 4. ç²¾åº¦å’Œä¸‹å•å‚æ•°è°ƒæ•´

#### 4.1 ä»·æ ¼ç²¾åº¦è°ƒæ•´

```python
def adjust_price_precision(self, price: Decimal, symbol_info: Dict) -> Decimal:
    """
    è°ƒæ•´ä»·æ ¼ç²¾åº¦ä»¥ç¬¦åˆäº¤æ˜“æ‰€è¦æ±‚
    
    æ ¹æ®tickSizeè°ƒæ•´ä»·æ ¼åˆ°æœ€æ¥è¿‘çš„æœ‰æ•ˆä»·æ ¼
    """
    tick_size = Decimal(str(symbol_info['filters'][0]['tickSize']))
    
    # ä»·æ ¼å¿…é¡»æ˜¯tickSizeçš„æ•´æ•°å€
    adjusted_price = (price / tick_size).quantize(Decimal('1'), rounding=ROUND_DOWN) * tick_size
    
    return adjusted_price
```

#### 4.2 æ•°é‡ç²¾åº¦è°ƒæ•´

```python
def adjust_quantity_precision(self, quantity: Decimal, symbol_info: Dict) -> Decimal:
    """
    è°ƒæ•´æ•°é‡ç²¾åº¦ä»¥ç¬¦åˆäº¤æ˜“æ‰€è¦æ±‚
    
    æ ¹æ®stepSizeè°ƒæ•´æ•°é‡åˆ°æœ€æ¥è¿‘çš„æœ‰æ•ˆæ•°é‡
    """
    step_size = Decimal(str(symbol_info['filters'][1]['stepSize']))
    
    # æ•°é‡å¿…é¡»æ˜¯stepSizeçš„æ•´æ•°å€
    adjusted_quantity = (quantity / step_size).quantize(Decimal('1'), rounding=ROUND_DOWN) * step_size
    
    return adjusted_quantity
```

---

## ç­–ç•¥è¯¦ç»†çš„äº¤æ˜“é€»è¾‘

### 1. åŒå‘æŒ‚å•è¡¥ä»“ç­–ç•¥æ¶æ„

#### 1.1 ç­–ç•¥æ ¸å¿ƒç†å¿µ

```
ä»·æ ¼ä¸Šæ¶¨ â† ATRä¸Šè¾¹ç•Œ â† ç½‘æ ¼åŒºé—´ â†’ ATRä¸‹è¾¹ç•Œ â†’ ä»·æ ¼ä¸‹è·Œ
    â†‘              â†‘                    â†‘              â†‘
ç©ºå¤´æ­¢æŸ        ç©ºå¤´ä¸»è¦äº¤æ˜“åŒºé—´        å¤šå¤´ä¸»è¦äº¤æ˜“åŒºé—´      å¤šå¤´æ­¢æŸ
```

#### 1.2 åŒè´¦æˆ·è§’è‰²åˆ†å·¥

**å¤šå¤´è´¦æˆ· (Long Account)**:
- **äº¤æ˜“æ–¹å‘**: å§‹ç»ˆæŒ‚BUYè®¢å•
- **æŒä»“æ–¹å‘**: å»ºç«‹LONGä»“ä½  
- **ç›ˆåˆ©æ¨¡å¼**: ä»·æ ¼ä¸Šæ¶¨æ—¶è·åˆ©ï¼Œä¸‹è·Œæ—¶é€šè¿‡è¡¥ä»“é™ä½æˆæœ¬
- **æŒ‚å•ç­–ç•¥**: åœ¨æ‰€æœ‰ç½‘æ ¼ç‚¹ä½æŒ‚ä¹°å•

**ç©ºå¤´è´¦æˆ· (Short Account)**:
- **äº¤æ˜“æ–¹å‘**: å§‹ç»ˆæŒ‚SELLè®¢å•
- **æŒä»“æ–¹å‘**: å»ºç«‹SHORTä»“ä½
- **ç›ˆåˆ©æ¨¡å¼**: ä»·æ ¼ä¸‹è·Œæ—¶è·åˆ©ï¼Œä¸Šæ¶¨æ—¶é€šè¿‡è¡¥ä»“é™ä½æˆæœ¬  
- **æŒ‚å•ç­–ç•¥**: åœ¨æ‰€æœ‰ç½‘æ ¼ç‚¹ä½æŒ‚å–å•

### 2. ç½‘æ ¼ç”Ÿæˆå’Œæ¿€æ´»é€»è¾‘

#### 2.1 ç½‘æ ¼å±‚çº§ç”Ÿæˆ

```python
def _generate_grid_levels(self):
    """
    ç”Ÿæˆç½‘æ ¼å±‚çº§ (åŒå‘æŒ‚å•è¡¥ä»“ç­–ç•¥)
    
    æ ¸å¿ƒé€»è¾‘:
    - å¤šå¤´è´¦æˆ·: åœ¨æ‰€æœ‰ç½‘æ ¼ç‚¹ä½éƒ½æŒ‚ä¹°å•(BUY)ï¼Œåšå¤šLONGä»“ä½
    - ç©ºå¤´è´¦æˆ·: åœ¨æ‰€æœ‰ç½‘æ ¼ç‚¹ä½éƒ½æŒ‚å–å•(SELL)ï¼Œåšç©ºSHORTä»“ä½  
    - æ— è®ºä»·æ ¼é«˜äºè¿˜æ˜¯ä½äºå½“å‰ä»·ï¼ŒæŒ‚å•æ–¹å‘ä¿æŒä¸€è‡´
    """
    self.grid_levels.clear()
    
    # ä½¿ç”¨ATRè®¡ç®—å¾—åˆ°çš„ä¸Šä¸‹è¾¹ç•Œå’Œç½‘æ ¼é—´è·
    upper_limit = self.upper_boundary
    lower_limit = self.lower_boundary  
    grid_spacing = self.grid_spacing
    
    # è®¡ç®—ç½‘æ ¼å±‚æ•°
    price_range = upper_limit - lower_limit
    total_levels = int(price_range / grid_spacing)
    total_levels = max(1, total_levels)
    
    # ä»ä¸‹è¾¹ç•Œå¼€å§‹ï¼ŒæŒ‰ç½‘æ ¼é—´è·ä¾æ¬¡ç”Ÿæˆæ‰€æœ‰ç½‘æ ¼
    for i in range(total_levels):
        grid_price = lower_limit + (grid_spacing * i)
        
        # ç¡®ä¿ä¸è¶…è¿‡ä¸Šè¾¹ç•Œ
        if grid_price > upper_limit:
            break
            
        # è®¡ç®—æ¯æ ¼çš„ä¸‹å•æ•°é‡
        grid_quantity = self.base_position_size / grid_price
        
        # åˆ›å»ºç½‘æ ¼å±‚çº§
        grid_level = GridLevel(
            level_id=f"grid_{i}",
            price=grid_price,
            quantity=grid_quantity,
            level=i
        )
        
        self.grid_levels.append(grid_level)
```

#### 2.2 åŠ¨æ€ç½‘æ ¼æ¿€æ´»ç®¡ç†

```python
async def manage_dynamic_grids(self):
    """
    åŠ¨æ€ç½‘æ ¼ç®¡ç† - æ ¹æ®å½“å‰ä»·æ ¼æ¿€æ´»é™„è¿‘çš„ç½‘æ ¼
    """
    current_price = await self.get_current_price()
    
    # æŒ‰ä¸å½“å‰ä»·æ ¼çš„è·ç¦»æ’åº
    sorted_grids = sorted(self.grid_levels, 
                         key=lambda g: abs(g.price - current_price))
    
    # åˆ†é…ç»™å¤šå¤´å’Œç©ºå¤´è´¦æˆ·çš„æœ€å¤§æŒ‚å•æ•°
    max_orders_per_account = self.config.max_open_orders // 2
    
    # å¤šå¤´è´¦æˆ·æŒ‚å•ç®¡ç†
    await self.manage_long_buy_orders_bidirectional(
        current_price, max_orders_per_account
    )
    
    # ç©ºå¤´è´¦æˆ·æŒ‚å•ç®¡ç†  
    await self.manage_short_sell_orders_bidirectional(
        current_price, max_orders_per_account
    )
```

### 3. å…·ä½“æŒ‚å•æ‰§è¡Œé€»è¾‘

#### 3.1 å¤šå¤´è´¦æˆ·æŒ‚å•é€»è¾‘

```python
async def manage_long_buy_orders_bidirectional(self, current_price: Decimal, max_orders: int):
    """
    å¤šå¤´è´¦æˆ·åŒå‘æŒ‚ä¹°å•ç®¡ç†
    
    ç­–ç•¥é€»è¾‘:
    - å¸‚ä»·ä¸Šæ–¹æŒ‚ä¹°å•: ä»·æ ¼çªç ´åçš„è¡¥ä»“å•
    - å¸‚ä»·ä¸‹æ–¹æŒ‚ä¹°å•: ä»·æ ¼å›è°ƒæ—¶çš„ä¸»è¦å»ºä»“å•
    """
    # ç­›é€‰å¸‚ä»·ä¸Šæ–¹å’Œä¸‹æ–¹çš„ç½‘æ ¼
    above_grids = [grid for grid in self.grid_levels if grid.price > current_price]
    below_grids = [grid for grid in self.grid_levels if grid.price < current_price]
    
    # æŒ‰è·ç¦»å½“å‰ä»·æ’åº (è¿‘çš„ä¼˜å…ˆ)
    above_grids.sort(key=lambda g: g.price)
    below_grids.sort(key=lambda g: g.price, reverse=True)
    
    # è®¡ç®—ä¸Šæ–¹å’Œä¸‹æ–¹å„åˆ†é…å¤šå°‘ä¸ªè®¢å•
    orders_above = max_orders // 2  # ä¸Šæ–¹æŒ‚å•æ•°é‡
    orders_below = max_orders - orders_above  # ä¸‹æ–¹æŒ‚å•æ•°é‡
    
    # ç®¡ç†å¸‚ä»·ä¸Šæ–¹çš„ä¹°å• (è¡¥ä»“å•)
    await self.manage_grid_orders(above_grids, orders_above, "long", "ABOVE")
    
    # ç®¡ç†å¸‚ä»·ä¸‹æ–¹çš„ä¹°å• (ä¸»è¦äº¤æ˜“å•)
    await self.manage_grid_orders(below_grids, orders_below, "long", "BELOW")
```

#### 3.2 ç©ºå¤´è´¦æˆ·æŒ‚å•é€»è¾‘

```python
async def manage_short_sell_orders_bidirectional(self, current_price: Decimal, max_orders: int):
    """
    ç©ºå¤´è´¦æˆ·åŒå‘æŒ‚å–å•ç®¡ç†
    
    ç­–ç•¥é€»è¾‘:
    - å¸‚ä»·ä¸Šæ–¹æŒ‚å–å•: ä»·æ ¼ä¸Šæ¶¨æ—¶çš„ä¸»è¦å»ºä»“å•
    - å¸‚ä»·ä¸‹æ–¹æŒ‚å–å•: ä»·æ ¼ä¸‹è·Œåçš„è¡¥ä»“å•
    """
    # ç­›é€‰å¸‚ä»·ä¸Šæ–¹å’Œä¸‹æ–¹çš„ç½‘æ ¼
    above_grids = [grid for grid in self.grid_levels if grid.price > current_price]
    below_grids = [grid for grid in self.grid_levels if grid.price < current_price]
    
    # æŒ‰è·ç¦»å½“å‰ä»·æ’åº (è¿‘çš„ä¼˜å…ˆ)
    above_grids.sort(key=lambda g: g.price)
    below_grids.sort(key=lambda g: g.price, reverse=True)
    
    # è®¡ç®—ä¸Šæ–¹å’Œä¸‹æ–¹å„åˆ†é…å¤šå°‘ä¸ªè®¢å•
    orders_above = max_orders // 2  # ä¸Šæ–¹æŒ‚å•æ•°é‡
    orders_below = max_orders - orders_above  # ä¸‹æ–¹æŒ‚å•æ•°é‡
    
    # ç®¡ç†å¸‚ä»·ä¸Šæ–¹çš„å–å• (ä¸»è¦äº¤æ˜“å•)
    await self.manage_grid_orders(above_grids, orders_above, "short", "ABOVE")
    
    # ç®¡ç†å¸‚ä»·ä¸‹æ–¹çš„å–å• (è¡¥ä»“å•)
    await self.manage_grid_orders(below_grids, orders_below, "short", "BELOW")
```

### 4. è®¢å•æ‰§è¡Œå’Œç®¡ç†

#### 4.1 é€šç”¨ç½‘æ ¼è®¢å•ç®¡ç†

```python
async def manage_grid_orders(self, grids: list, target_count: int, account_type: str, direction: str):
    """
    é€šç”¨çš„ç½‘æ ¼è®¢å•ç®¡ç†å‡½æ•°
    
    Args:
        grids: ç½‘æ ¼åˆ—è¡¨
        target_count: ç›®æ ‡æŒ‚å•æ•°é‡
        account_type: è´¦æˆ·ç±»å‹ ("long" æˆ– "short")
        direction: æ–¹å‘æ ‡è¯† ("ABOVE" æˆ– "BELOW")
    """
    # æ£€æŸ¥å½“å‰æ´»è·ƒçš„è®¢å•
    active_orders = [
        grid for grid in grids 
        if grid.open_order_status == OrderStatus.PENDING
    ]
    
    # å¦‚æœæ´»è·ƒè®¢å•å°‘äºç›®æ ‡æ•°é‡ï¼Œæ·»åŠ æ–°è®¢å•
    if len(active_orders) < target_count:
        needed_orders = target_count - len(active_orders)
        
        # ä»ç¦»å½“å‰ä»·æœ€è¿‘çš„ç½‘æ ¼å¼€å§‹æŒ‚å•
        for grid in grids[:needed_orders]:
            if grid.open_order_status == OrderStatus.NOT_ACTIVE:
                await self.place_grid_order(grid, account_type)
                self.logger.info(f"æ¿€æ´»{direction}æ–¹å‘ç½‘æ ¼è®¢å•: ä»·æ ¼={grid.price}, è´¦æˆ·={account_type}")
    
    # å¦‚æœæ´»è·ƒè®¢å•è¶…è¿‡ç›®æ ‡æ•°é‡ï¼Œå–æ¶ˆè·ç¦»æœ€è¿œçš„è®¢å•
    elif len(active_orders) > target_count:
        excess_orders = len(active_orders) - target_count
        
        # å–æ¶ˆè·ç¦»å½“å‰ä»·æœ€è¿œçš„è®¢å• (åœ¨gridsåˆ—è¡¨çš„æœ«å°¾)
        orders_to_cancel = active_orders[-excess_orders:]
        for grid in orders_to_cancel:
            await self.cancel_grid_order(grid, account_type)
            self.logger.info(f"å–æ¶ˆ{direction}æ–¹å‘ç½‘æ ¼è®¢å•: ä»·æ ¼={grid.price}, è´¦æˆ·={account_type}")
```

#### 4.2 å…·ä½“ä¸‹å•æ‰§è¡Œ

```python
async def place_grid_order(self, grid: GridLevel, account_type: str):
    """
    æŒ‚å‡ºç½‘æ ¼è®¢å• (åŒå‘æŒ‚å•è¡¥ä»“ç­–ç•¥)
    
    æ ¸å¿ƒé€»è¾‘:
    - å¤šå¤´è´¦æˆ·(long): å§‹ç»ˆæŒ‚ä¹°å•(BUY)ï¼Œå»ºç«‹LONGä»“ä½
    - ç©ºå¤´è´¦æˆ·(short): å§‹ç»ˆæŒ‚å–å•(SELL)ï¼Œå»ºç«‹SHORTä»“ä½
    """
    try:
        # æ ¹æ®è´¦æˆ·ç±»å‹ç¡®å®šäº¤æ˜“æ–¹å‘å’ŒæŒä»“æ–¹å‘
        if account_type == "long":
            side = "BUY"           # å¤šå¤´è´¦æˆ·ä¹°å…¥
            position_side = "LONG" # å»ºç«‹å¤šå¤´ä»“ä½
            client = self.dual_manager.long_account
        else:  # account_type == "short"
            side = "SELL"          # ç©ºå¤´è´¦æˆ·å–å‡º
            position_side = "SHORT" # å»ºç«‹ç©ºå¤´ä»“ä½
            client = self.dual_manager.short_account
        
        # ç²¾åº¦è°ƒæ•´
        adjusted_price, adjusted_quantity = self.adjust_order_precision(
            grid.price, grid.quantity
        )
        
        # èµ„é‡‘å……è¶³æ€§æ£€æŸ¥
        if not await self.check_sufficient_funds(account_type, adjusted_quantity, adjusted_price):
            self.logger.warning(f"èµ„é‡‘ä¸è¶³ï¼Œè·³è¿‡è®¢å•: {grid.level_id}")
            return
        
        # ä¸‹å•
        result = await client.place_order(
            symbol=self.config.symbol,
            side=side,
            order_type="LIMIT",
            quantity=str(adjusted_quantity),
            price=str(adjusted_price),
            positionSide=position_side,
            timeInForce="GTC"
        )
        
        # æ›´æ–°ç½‘æ ¼çŠ¶æ€
        if result and not isinstance(result, Exception):
            grid.open_order_id = str(result["orderId"])
            grid.open_order_status = OrderStatus.PENDING
            grid.price = adjusted_price
            grid.quantity = adjusted_quantity
            
            self.logger.info(
                f"ç½‘æ ¼è®¢å•å·²æŒ‚å‡º: {grid.level_id}, "
                f"æ–¹å‘: {side}->{position_side}, "
                f"ä»·æ ¼: {grid.price}, "
                f"è®¢å•ID: {grid.open_order_id}"
            )
            
    except Exception as e:
        self.logger.error(f"æŒ‚å‡ºç½‘æ ¼è®¢å•å¤±è´¥: {e}")
        self.logger.error(f"è®¢å•è¯¦æƒ…: è´¦æˆ·={account_type}, ç½‘æ ¼={grid.level_id}, ä»·æ ¼={grid.price}")
```

### 5. æˆäº¤å¤„ç†å’Œæ­¢ç›ˆé€»è¾‘

#### 5.1 è®¢å•æˆäº¤æ£€æµ‹

```python
async def check_filled_orders(self):
    """
    æ£€æŸ¥å·²æˆäº¤çš„è®¢å•å¹¶å¤„ç†
    """
    for grid in self.grid_levels:
        if grid.open_order_status == OrderStatus.PENDING and grid.open_order_id:
            # æŸ¥è¯¢è®¢å•çŠ¶æ€
            order_status = await self.query_order_status(grid.open_order_id, grid.account_type)
            
            if order_status == "FILLED":
                await self.handle_filled_order(grid)
```

#### 5.2 æˆäº¤è®¢å•å¤„ç†

```python
async def handle_filled_order(self, grid: GridLevel):
    """
    å¤„ç†å·²æˆäº¤çš„ç½‘æ ¼è®¢å•
    
    æˆäº¤åçš„å¤„ç†é€»è¾‘:
    1. æ›´æ–°ç½‘æ ¼çŠ¶æ€
    2. åˆ›å»ºæ­¢ç›ˆè®¢å• (å¯é€‰)
    3. é‡æ–°æ¿€æ´»è¯¥ç½‘æ ¼å±‚çº§
    """
    try:
        # æ›´æ–°ç½‘æ ¼çŠ¶æ€
        grid.open_order_status = OrderStatus.FILLED
        grid.filled_time = time.time()
        
        self.logger.info(f"ç½‘æ ¼è®¢å•æˆäº¤: {grid.level_id}, ä»·æ ¼: {grid.price}")
        
        # åˆ›å»ºæ­¢ç›ˆè®¢å• (å¯é€‰åŠŸèƒ½)
        if self.config.enable_take_profit:
            await self.create_take_profit_order(grid)
        
        # é‡æ–°æ¿€æ´»è¯¥ç½‘æ ¼ (ä¸ºä¸‹æ¬¡äº¤æ˜“åšå‡†å¤‡)
        grid.open_order_status = OrderStatus.NOT_ACTIVE
        grid.open_order_id = None
        
        # æ›´æ–°äº¤æ˜“ç»Ÿè®¡
        self.update_trading_stats(grid)
        
    except Exception as e:
        self.logger.error(f"å¤„ç†æˆäº¤è®¢å•å¤±è´¥: {e}")
```

---

## ç­–ç•¥é£æ§é€»è¾‘

### 1. å¤šå±‚é£æ§æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     é£æ§å±‚çº§æ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç¬¬ä¸€å±‚: å¯åŠ¨é£æ§                                          â”‚
â”‚ â”œâ”€ åŒè´¦æˆ·è¿æ¥éªŒè¯                                         â”‚
â”‚ â”œâ”€ è´¦æˆ·æƒé™æ£€æŸ¥                                          â”‚
â”‚ â”œâ”€ èµ„é‡‘å……è¶³æ€§éªŒè¯                                         â”‚
â”‚ â””â”€ æŒä»“æ¨¡å¼ç¡®è®¤                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç¬¬äºŒå±‚: è¿è¡Œé£æ§                                          â”‚
â”‚ â”œâ”€ ATRé€šé“çªç ´ç›‘æ§                                       â”‚
â”‚ â”œâ”€ è´¦æˆ·å¥åº·çŠ¶æ€æ£€æŸ¥                                       â”‚
â”‚ â”œâ”€ èµ„é‡‘å®æ—¶ç›‘æ§                                          â”‚
â”‚ â””â”€ è®¢å•æ‰§è¡Œç›‘æ§                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç¬¬ä¸‰å±‚: ç´§æ€¥é£æ§                                          â”‚
â”‚ â”œâ”€ ç´§æ€¥æ­¢æŸè§¦å‘                                          â”‚
â”‚ â”œâ”€ è´¦æˆ·å¼‚å¸¸å¤„ç†                                          â”‚
â”‚ â”œâ”€ ç½‘ç»œè¿æ¥ç›‘æ§                                          â”‚
â”‚ â””â”€ ç³»ç»Ÿå¼‚å¸¸ä¿æŠ¤                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. ATRé€šé“çªç ´æ­¢æŸ

#### 2.1 çªç ´æ£€æµ‹é€»è¾‘

```python
class StopLossManager:
    """æ­¢æŸç®¡ç†å™¨ - æ ¸å¿ƒé£æ§ç»„ä»¶"""
    
    async def check_atr_breakout(self, current_price: Decimal) -> bool:
        """
        æ£€æŸ¥ATRé€šé“çªç ´
        
        çªç ´æ¡ä»¶:
        - ä»·æ ¼çªç ´ä¸Šè¾¹ç•Œ: current_price > upper_boundary
        - ä»·æ ¼çªç ´ä¸‹è¾¹ç•Œ: current_price < lower_boundary
        
        Args:
            current_price: å½“å‰ä»·æ ¼
            
        Returns:
            bool: æ˜¯å¦å‘ç”Ÿçªç ´
        """
        try:
            # è·å–ATRé€šé“è¾¹ç•Œ
            upper_boundary = self.upper_boundary
            lower_boundary = self.lower_boundary
            
            # æ£€æŸ¥çªç ´
            upper_breakout = current_price > upper_boundary
            lower_breakout = current_price < lower_boundary
            
            if upper_breakout:
                self.logger.warning(f"âš ï¸  ATRä¸Šè½¨çªç ´! å½“å‰ä»·æ ¼: {current_price}, ä¸Šè¾¹ç•Œ: {upper_boundary}")
                self.breakout_direction = "UPPER"
                return True
                
            elif lower_breakout:
                self.logger.warning(f"âš ï¸  ATRä¸‹è½¨çªç ´! å½“å‰ä»·æ ¼: {current_price}, ä¸‹è¾¹ç•Œ: {lower_boundary}")
                self.breakout_direction = "LOWER"
                return True
                
            return False
            
        except Exception as e:
            self.logger.error(f"ATRçªç ´æ£€æµ‹å¤±è´¥: {e}")
            return False
```

#### 2.2 æ­¢æŸæ‰§è¡Œæµç¨‹

```python
async def execute_stop_loss(self, reason: str = "ATR_BREAKOUT"):
    """
    æ‰§è¡Œæ­¢æŸæ“ä½œ
    
    æ­¢æŸæ‰§è¡Œé¡ºåº:
    1. ç«‹å³å–æ¶ˆæ‰€æœ‰æŒ‚å•
    2. è¯„ä¼°è´¦æˆ·æµ®åŠ¨ç›ˆäº
    3. ä¼˜å…ˆå¹³ä»“æµ®äºè¾ƒå¤§çš„è´¦æˆ·
    4. æœ‰åºå¹³ä»“æ‰€æœ‰æŒä»“
    5. åœæ­¢ç­–ç•¥è¿è¡Œ
    """
    try:
        self.is_stop_loss_active = True
        self.logger.critical(f"ğŸ›‘ æ‰§è¡Œæ­¢æŸæ“ä½œ! åŸå› : {reason}")
        
        # ç¬¬ä¸€æ­¥: ç«‹å³å–æ¶ˆæ‰€æœ‰æŒ‚å•
        self.logger.info("ç¬¬ä¸€æ­¥: å–æ¶ˆæ‰€æœ‰æŒ‚å•...")
        cancel_results = await self._cancel_all_orders()
        
        # ç¬¬äºŒæ­¥: è·å–å½“å‰æŒä»“
        self.logger.info("ç¬¬äºŒæ­¥: è·å–è´¦æˆ·æŒä»“...")
        long_positions = await self.dual_manager.long_account.get_positions(self.symbol)
        short_positions = await self.dual_manager.short_account.get_positions(self.symbol)
        
        # ç¬¬ä¸‰æ­¥: è¯„ä¼°æµ®åŠ¨ç›ˆäº
        long_pnl = self._calculate_unrealized_pnl(long_positions)
        short_pnl = self._calculate_unrealized_pnl(short_positions)
        
        self.logger.info(f"è´¦æˆ·æµ®åŠ¨ç›ˆäº: å¤šå¤´={long_pnl:.4f}, ç©ºå¤´={short_pnl:.4f}")
        
        # ç¬¬å››æ­¥: ç¡®å®šå¹³ä»“é¡ºåº (æµ®äºå¤§çš„ä¼˜å…ˆ)
        if long_pnl <= short_pnl:
            # å¤šå¤´äºæŸæ›´å¤§ï¼Œä¼˜å…ˆå¹³å¤šå¤´
            await self._close_positions_orderly([
                ("long", long_positions),
                ("short", short_positions)
            ])
        else:
            # ç©ºå¤´äºæŸæ›´å¤§ï¼Œä¼˜å…ˆå¹³ç©ºå¤´
            await self._close_positions_orderly([
                ("short", short_positions), 
                ("long", long_positions)
            ])
        
        # ç¬¬äº”æ­¥: è®°å½•æ­¢æŸç»“æœ
        self._log_stop_loss_result(reason, long_pnl, short_pnl)
        
        # ç¬¬å…­æ­¥: åœæ­¢ç­–ç•¥
        await self.strategy.stop_strategy()
        
    except Exception as e:
        self.logger.critical(f"æ­¢æŸæ‰§è¡Œå¤±è´¥: {e}")
        # ç´§æ€¥æƒ…å†µä¸‹å¼ºåˆ¶åœæ­¢
        await self.emergency_stop()
```

### 3. è´¦æˆ·å¥åº·ç›‘æ§

#### 3.1 åŒè´¦æˆ·åŒæ­¥æ£€æŸ¥

```python
async def check_dual_account_health(self) -> bool:
    """
    æ£€æŸ¥åŒè´¦æˆ·å¥åº·çŠ¶æ€
    
    æ£€æŸ¥é¡¹ç›®:
    1. è¿æ¥çŠ¶æ€
    2. APIæƒé™
    3. è´¦æˆ·ä½™é¢
    4. æŒä»“çŠ¶æ€
    5. åŒæ­¥çŠ¶æ€
    """
    try:
        # å¹¶è¡Œæ£€æŸ¥åŒè´¦æˆ·çŠ¶æ€
        long_health, short_health = await asyncio.gather(
            self._check_single_account_health(self.dual_manager.long_account, "long"),
            self._check_single_account_health(self.dual_manager.short_account, "short"),
            return_exceptions=True
        )
        
        # ä»»ä¸€è´¦æˆ·å¼‚å¸¸éƒ½è§¦å‘ä¿æŠ¤
        if isinstance(long_health, Exception) or isinstance(short_health, Exception):
            self.logger.error(f"è´¦æˆ·å¥åº·æ£€æŸ¥å¼‚å¸¸: long={long_health}, short={short_health}")
            return False
            
        if not long_health or not short_health:
            self.logger.error(f"è´¦æˆ·å¥åº·çŠ¶æ€å¼‚å¸¸: long={long_health}, short={short_health}")
            return False
            
        return True
        
    except Exception as e:
        self.logger.error(f"åŒè´¦æˆ·å¥åº·æ£€æŸ¥å¤±è´¥: {e}")
        return False

async def _check_single_account_health(self, account, account_type: str) -> bool:
    """
    æ£€æŸ¥å•ä¸ªè´¦æˆ·å¥åº·çŠ¶æ€
    """
    try:
        # æ£€æŸ¥è¿æ¥
        account_info = await account.get_account_info()
        if not account_info:
            self.logger.error(f"{account_type}è´¦æˆ·è¿æ¥å¤±è´¥")
            return False
            
        # æ£€æŸ¥ä½™é¢
        available_balance = Decimal(account_info.get('availableBalance', '0'))
        if available_balance <= 0:
            self.logger.warning(f"{account_type}è´¦æˆ·ä½™é¢ä¸è¶³: {available_balance}")
            
        # æ£€æŸ¥APIæƒé™
        permissions = account_info.get('permissions', [])
        if 'FUTURES' not in permissions:
            self.logger.error(f"{account_type}è´¦æˆ·ç¼ºå°‘æœŸè´§æƒé™")
            return False
            
        return True
        
    except Exception as e:
        self.logger.error(f"{account_type}è´¦æˆ·å¥åº·æ£€æŸ¥å¤±è´¥: {e}")
        return False
```

#### 3.2 å¯åŠ¨å®‰å…¨éªŒè¯

```python
async def startup_safety_check(self) -> bool:
    """
    å¯åŠ¨å®‰å…¨éªŒè¯
    
    éªŒè¯é¡¹ç›®:
    1. åŒè´¦æˆ·åŒæ—¶å¥åº·å¯åŠ¨
    2. äº¤æ˜“å¯¹é…ç½®æ­£ç¡®
    3. èµ„é‡‘å……è¶³æ€§
    4. æŒä»“æ¨¡å¼æ­£ç¡®
    5. æ æ†è®¾ç½®æˆåŠŸ
    """
    try:
        self.logger.info("å¼€å§‹å¯åŠ¨å®‰å…¨éªŒè¯...")
        
        # 1. åŒè´¦æˆ·å¥åº·æ£€æŸ¥
        if not await self.check_dual_account_health():
            self.logger.error("âŒ åŒè´¦æˆ·å¥åº·æ£€æŸ¥å¤±è´¥")
            return False
        self.logger.info("âœ… åŒè´¦æˆ·å¥åº·æ£€æŸ¥é€šè¿‡")
        
        # 2. äº¤æ˜“å¯¹éªŒè¯
        if not await self._verify_symbol_config():
            self.logger.error("âŒ äº¤æ˜“å¯¹é…ç½®éªŒè¯å¤±è´¥")
            return False
        self.logger.info("âœ… äº¤æ˜“å¯¹é…ç½®éªŒè¯é€šè¿‡")
        
        # 3. èµ„é‡‘å……è¶³æ€§éªŒè¯
        if not await self._verify_fund_adequacy():
            self.logger.error("âŒ èµ„é‡‘å……è¶³æ€§éªŒè¯å¤±è´¥")
            return False
        self.logger.info("âœ… èµ„é‡‘å……è¶³æ€§éªŒè¯é€šè¿‡")
        
        # 4. æŒä»“æ¨¡å¼éªŒè¯
        if not await self._verify_position_mode():
            self.logger.error("âŒ æŒä»“æ¨¡å¼éªŒè¯å¤±è´¥")
            return False
        self.logger.info("âœ… æŒä»“æ¨¡å¼éªŒè¯é€šè¿‡")
        
        # 5. æ æ†è®¾ç½®éªŒè¯
        if not await self._verify_leverage_setting():
            self.logger.error("âŒ æ æ†è®¾ç½®éªŒè¯å¤±è´¥")
            return False
        self.logger.info("âœ… æ æ†è®¾ç½®éªŒè¯é€šè¿‡")
        
        self.logger.info("ğŸ‰ å¯åŠ¨å®‰å…¨éªŒè¯å®Œæˆ!")
        return True
        
    except Exception as e:
        self.logger.error(f"å¯åŠ¨å®‰å…¨éªŒè¯å¼‚å¸¸: {e}")
        return False
```

### 4. èµ„é‡‘é£æ§

#### 4.1 å®æ—¶èµ„é‡‘ç›‘æ§

```python
async def monitor_fund_safety(self):
    """
    å®æ—¶èµ„é‡‘å®‰å…¨ç›‘æ§
    
    ç›‘æ§æŒ‡æ ‡:
    1. ä¿è¯é‡‘æ¯”ç‡
    2. å¯ç”¨ä½™é¢
    3. æœªå®ç°ç›ˆäº
    4. å¼ºå¹³é£é™©
    """
    try:
        # è·å–åŒè´¦æˆ·èµ„é‡‘çŠ¶æ€
        long_info = await self.dual_manager.long_account.get_account_info()
        short_info = await self.dual_manager.short_account.get_account_info()
        
        # è®¡ç®—å…³é”®æŒ‡æ ‡
        long_margin_ratio = self._calculate_margin_ratio(long_info)
        short_margin_ratio = self._calculate_margin_ratio(short_info)
        
        # ä¿è¯é‡‘æ¯”ç‡é¢„è­¦
        if long_margin_ratio > 0.8 or short_margin_ratio > 0.8:
            self.logger.warning(
                f"âš ï¸  ä¿è¯é‡‘æ¯”ç‡è¿‡é«˜! "
                f"å¤šå¤´: {long_margin_ratio:.2%}, "
                f"ç©ºå¤´: {short_margin_ratio:.2%}"
            )
            
        # å¼ºå¹³é£é™©é¢„è­¦
        if long_margin_ratio > 0.9 or short_margin_ratio > 0.9:
            self.logger.critical(
                f"ğŸš¨ å¼ºå¹³é£é™©è­¦å‘Š! "
                f"å¤šå¤´: {long_margin_ratio:.2%}, "
                f"ç©ºå¤´: {short_margin_ratio:.2%}"
            )
            
            # è§¦å‘ç´§æ€¥å‡ä»“
            await self.emergency_reduce_positions()
            
    except Exception as e:
        self.logger.error(f"èµ„é‡‘ç›‘æ§å¤±è´¥: {e}")

def _calculate_margin_ratio(self, account_info: Dict) -> float:
    """
    è®¡ç®—ä¿è¯é‡‘æ¯”ç‡
    
    ä¿è¯é‡‘æ¯”ç‡ = å·²ç”¨ä¿è¯é‡‘ / æ€»èµ„äº§
    """
    total_wallet_balance = float(account_info.get('totalWalletBalance', 0))
    total_margin_balance = float(account_info.get('totalMarginBalance', 0))
    
    if total_wallet_balance == 0:
        return 1.0
        
    return total_margin_balance / total_wallet_balance
```

#### 4.2 ä¸‹å•å‰èµ„é‡‘æ£€æŸ¥

```python
async def check_sufficient_funds(self, account_type: str, quantity: Decimal, price: Decimal) -> bool:
    """
    ä¸‹å•å‰èµ„é‡‘å……è¶³æ€§æ£€æŸ¥
    
    æ£€æŸ¥é¡¹ç›®:
    1. å¯ç”¨ä½™é¢æ˜¯å¦å……è¶³
    2. ä¿è¯é‡‘éœ€æ±‚è®¡ç®—
    3. æœ€å°åä¹‰ä»·å€¼éªŒè¯
    4. å¼ºå¹³é£é™©è¯„ä¼°
    """
    try:
        # è·å–è´¦æˆ·ä¿¡æ¯
        if account_type == "long":
            account_info = await self.dual_manager.long_account.get_account_info()
        else:
            account_info = await self.dual_manager.short_account.get_account_info()
            
        available_balance = Decimal(account_info.get('availableBalance', '0'))
        
        # è®¡ç®—è®¢å•æ‰€éœ€ä¿è¯é‡‘
        order_notional = quantity * price  # åä¹‰ä»·å€¼
        required_margin = order_notional / self.config.leverage  # æ‰€éœ€ä¿è¯é‡‘
        
        # æ£€æŸ¥å¯ç”¨ä½™é¢
        if available_balance < required_margin:
            self.logger.warning(
                f"ä¸‹å•å‰èµ„é‡‘æ£€æŸ¥å¤±è´¥:\n"
                f"  è®¢å•åä¹‰ä»·å€¼: {order_notional:.2f} USDC\n"
                f"  è®¢å•ä¿è¯é‡‘éœ€æ±‚: {required_margin:.2f} USDC\n" 
                f"  å¯ç”¨ä½™é¢: {available_balance:.2f} USDC\n"
                f"  è·³è¿‡æ­¤è®¢å•: {account_type}"
            )
            return False
            
        # æ£€æŸ¥æœ€å°åä¹‰ä»·å€¼
        min_notional = await self._get_min_notional()
        if order_notional < min_notional:
            self.logger.warning(f"è®¢å•åä¹‰ä»·å€¼ä¸è¶³æœ€å°å€¼: {order_notional} < {min_notional}")
            return False
            
        return True
        
    except Exception as e:
        self.logger.error(f"èµ„é‡‘æ£€æŸ¥å¤±è´¥: {e}")
        return False
```

### 5. ç´§æ€¥é£æ§æœºåˆ¶

#### 5.1 ç´§æ€¥åœæ­¢é€»è¾‘

```python
async def emergency_stop(self, reason: str = "EMERGENCY"):
    """
    ç´§æ€¥åœæ­¢æœºåˆ¶
    
    ç´§æ€¥æƒ…å†µå¤„ç†:
    1. ç«‹å³åœæ­¢æ‰€æœ‰äº¤æ˜“æ´»åŠ¨
    2. å–æ¶ˆæ‰€æœ‰æŒ‚å•
    3. è®°å½•ç´§æ€¥åœæ­¢åŸå› 
    4. å‘é€å‘Šè­¦é€šçŸ¥
    5. å®‰å…¨å…³é—­ç³»ç»Ÿ
    """
    try:
        self.is_emergency_stopped = True
        self.logger.critical(f"ğŸš¨ ç´§æ€¥åœæ­¢è§¦å‘! åŸå› : {reason}")
        
        # 1. è®¾ç½®ç´§æ€¥åœæ­¢æ ‡å¿—
        self.strategy_status = StrategyStatus.EMERGENCY_STOPPED
        
        # 2. å¹¶è¡Œå–æ¶ˆæ‰€æœ‰æŒ‚å• (å®¹é”™å¤„ç†)
        cancel_tasks = []
        try:
            cancel_tasks.append(
                self.dual_manager.long_account.cancel_all_orders(self.config.symbol)
            )
            cancel_tasks.append(
                self.dual_manager.short_account.cancel_all_orders(self.config.symbol)
            )
            
            # ç­‰å¾…å–æ¶ˆå®Œæˆï¼Œä½†ä¸é˜»å¡
            await asyncio.wait_for(
                asyncio.gather(*cancel_tasks, return_exceptions=True),
                timeout=10.0
            )
        except asyncio.TimeoutError:
            self.logger.warning("å–æ¶ˆè®¢å•è¶…æ—¶ï¼Œç»§ç»­ç´§æ€¥åœæ­¢æµç¨‹")
        except Exception as e:
            self.logger.error(f"å–æ¶ˆè®¢å•å¤±è´¥: {e}")
        
        # 3. è®°å½•ç´§æ€¥åœæ­¢ä¿¡æ¯
        self._log_emergency_stop(reason)
        
        # 4. å‘é€å‘Šè­¦é€šçŸ¥ (å¦‚æœé…ç½®äº†)
        if hasattr(self, 'notifier'):
            await self.notifier.send_emergency_alert(reason)
            
        # 5. å®‰å…¨å…³é—­
        self.logger.critical("ç´§æ€¥åœæ­¢å®Œæˆï¼Œç³»ç»Ÿå·²å®‰å…¨å…³é—­")
        
    except Exception as e:
        self.logger.critical(f"ç´§æ€¥åœæ­¢æ‰§è¡Œå¤±è´¥: {e}")
        # å³ä½¿ç´§æ€¥åœæ­¢å¤±è´¥ï¼Œä¹Ÿè¦è®¾ç½®åœæ­¢æ ‡å¿—
        self.is_emergency_stopped = True
```

#### 5.2 å¼‚å¸¸æ¢å¤æœºåˆ¶

```python
async def handle_strategy_exception(self, exception: Exception):
    """
    ç­–ç•¥å¼‚å¸¸å¤„ç†å’Œæ¢å¤
    
    å¼‚å¸¸åˆ†ç±»å¤„ç†:
    1. ç½‘ç»œå¼‚å¸¸ -> é‡è¯•
    2. APIå¼‚å¸¸ -> é™åˆ¶é‡è¯•
    3. èµ„é‡‘å¼‚å¸¸ -> ç´§æ€¥åœæ­¢
    4. ç³»ç»Ÿå¼‚å¸¸ -> ç´§æ€¥åœæ­¢
    """
    try:
        exception_type = type(exception).__name__
        exception_msg = str(exception)
        
        self.logger.error(f"ç­–ç•¥å¼‚å¸¸: {exception_type} - {exception_msg}")
        
        # æ ¹æ®å¼‚å¸¸ç±»å‹åˆ†ç±»å¤„ç†
        if self._is_network_exception(exception):
            # ç½‘ç»œå¼‚å¸¸ - é‡è¯•æœºåˆ¶
            await self._handle_network_exception(exception)
            
        elif self._is_api_exception(exception):
            # APIå¼‚å¸¸ - é™åˆ¶é‡è¯•
            await self._handle_api_exception(exception)
            
        elif self._is_fund_exception(exception):
            # èµ„é‡‘å¼‚å¸¸ - ç´§æ€¥åœæ­¢
            await self.emergency_stop(f"FUND_EXCEPTION: {exception_msg}")
            
        else:
            # æœªçŸ¥å¼‚å¸¸ - ç´§æ€¥åœæ­¢
            await self.emergency_stop(f"UNKNOWN_EXCEPTION: {exception_msg}")
            
    except Exception as e:
        self.logger.critical(f"å¼‚å¸¸å¤„ç†å™¨å¤±è´¥: {e}")
        await self.emergency_stop("EXCEPTION_HANDLER_FAILED")

def _is_network_exception(self, exception: Exception) -> bool:
    """åˆ¤æ–­æ˜¯å¦ä¸ºç½‘ç»œå¼‚å¸¸"""
    network_keywords = ['timeout', 'connection', 'network', 'socket']
    exception_str = str(exception).lower()
    return any(keyword in exception_str for keyword in network_keywords)

def _is_api_exception(self, exception: Exception) -> bool:
    """åˆ¤æ–­æ˜¯å¦ä¸ºAPIå¼‚å¸¸"""
    api_keywords = ['rate limit', '429', 'too many requests', 'api']
    exception_str = str(exception).lower()
    return any(keyword in exception_str for keyword in api_keywords)

def _is_fund_exception(self, exception: Exception) -> bool:
    """åˆ¤æ–­æ˜¯å¦ä¸ºèµ„é‡‘å¼‚å¸¸"""
    fund_keywords = ['insufficient', 'margin', 'balance', '2019']
    exception_str = str(exception).lower()
    return any(keyword in exception_str for keyword in fund_keywords)
```

---

## å‚æ•°é…ç½®æŒ‡å—

### 1. æ ¸å¿ƒç­–ç•¥å‚æ•°

```python
# æ¨èé…ç½®å‚æ•°
RECOMMENDED_CONFIG = {
    # ATRæŒ‡æ ‡å‚æ•°
    "atr_period": 14,                    # ATRè®¡ç®—å‘¨æœŸ
    "atr_period_timeframe": "1h",        # ATRæ—¶é—´æ¡†æ¶
    "atr_multiplier": 2.0,               # ATRé€šé“å€æ•°
    "grid_spacing_percent": 0.26,        # ç½‘æ ¼é—´è·å€æ•°
    
    # èµ„é‡‘ç®¡ç†å‚æ•°
    "leverage": 3,                       # æ æ†å€æ•° (æ¨è3-5å€)
    "max_open_orders": 6,                # æœ€å¤§æŒ‚å•æ•° (åŒè´¦æˆ·æ€»è®¡)
    "fund_utilization_rate": 0.9,       # èµ„é‡‘åˆ©ç”¨ç‡ (90%)
    "safety_factor": 0.8,                # å®‰å…¨ç³»æ•° (80%)
    
    # é£æ§å‚æ•°
    "margin_ratio_warning": 0.8,         # ä¿è¯é‡‘æ¯”ç‡é¢„è­¦çº¿
    "margin_ratio_emergency": 0.9,       # ä¿è¯é‡‘æ¯”ç‡ç´§æ€¥çº¿
    "max_retry_attempts": 3,             # æœ€å¤§é‡è¯•æ¬¡æ•°
    "retry_delay": 2,                    # é‡è¯•å»¶è¿Ÿ (ç§’)
    
    # ç›‘æ§å‚æ•°
    "monitor_interval": 5,               # ä¸»ç›‘æ§é—´éš” (ç§’)
    "health_check_interval": 30,         # å¥åº·æ£€æŸ¥é—´éš” (ç§’)
    "fund_check_interval": 60,           # èµ„é‡‘æ£€æŸ¥é—´éš” (ç§’)
}
```

### 2. ä¸åŒå¸‚å€¼ä»£å¸å‚æ•°è°ƒæ•´

```python
# å¤§å¸‚å€¼ä»£å¸ (BTC, ETH)
LARGE_CAP_CONFIG = {
    "atr_multiplier": 1.5,               # è¾ƒå°çš„é€šé“
    "grid_spacing_percent": 0.2,         # è¾ƒå¯†çš„ç½‘æ ¼
    "leverage": 3,                       # è¾ƒä½æ æ†
    "max_open_orders": 8,                # æ›´å¤šæŒ‚å•
}

# ä¸­å¸‚å€¼ä»£å¸ (ADA, DOT, MATIC)
MID_CAP_CONFIG = {
    "atr_multiplier": 2.0,               # æ ‡å‡†é€šé“
    "grid_spacing_percent": 0.26,        # æ ‡å‡†ç½‘æ ¼
    "leverage": 5,                       # ä¸­ç­‰æ æ†
    "max_open_orders": 6,                # æ ‡å‡†æŒ‚å•
}

# å°å¸‚å€¼ä»£å¸ (é£é™©è¾ƒé«˜)
SMALL_CAP_CONFIG = {
    "atr_multiplier": 2.5,               # è¾ƒå¤§çš„é€šé“
    "grid_spacing_percent": 0.3,         # è¾ƒç–çš„ç½‘æ ¼
    "leverage": 2,                       # è¾ƒä½æ æ†
    "max_open_orders": 4,                # è¾ƒå°‘æŒ‚å•
    "fund_utilization_rate": 0.7,        # è¾ƒä½èµ„é‡‘åˆ©ç”¨ç‡
}
```

---

## å®æ–½è¦ç‚¹

### 1. éƒ¨ç½²å‰æ£€æŸ¥æ¸…å•

```markdown
â–¡ å¸å®‰APIæƒé™ç¡®è®¤ (æœŸè´§äº¤æ˜“æƒé™)
â–¡ åŒè´¦æˆ·èµ„é‡‘å……è¶³æ€§éªŒè¯
â–¡ ç½‘ç»œè¿æ¥ç¨³å®šæ€§æµ‹è¯•
â–¡ é…ç½®å‚æ•°åˆç†æ€§æ£€æŸ¥
â–¡ æµ‹è¯•ç¯å¢ƒå®Œæ•´éªŒè¯
â–¡ ç›‘æ§å‘Šè­¦æœºåˆ¶é…ç½®
â–¡ ç´§æ€¥è”ç³»äººè®¾ç½®
â–¡ é£é™©æ‰¿å—èƒ½åŠ›è¯„ä¼°
```

### 2. ç›‘æ§è¦ç‚¹

```python
# å…³é”®ç›‘æ§æŒ‡æ ‡
KEY_METRICS = {
    "price_breakout": "ä»·æ ¼æ˜¯å¦çªç ´ATRé€šé“",
    "margin_ratio": "ä¿è¯é‡‘æ¯”ç‡æ˜¯å¦è¿‡é«˜",
    "account_health": "åŒè´¦æˆ·æ˜¯å¦å¥åº·è¿è¡Œ",
    "order_success_rate": "è®¢å•æˆåŠŸç‡",
    "pnl_status": "æ€»ä½“ç›ˆäºçŠ¶å†µ",
    "grid_efficiency": "ç½‘æ ¼æˆäº¤æ•ˆç‡",
}
```

### 3. å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

```markdown
Q: è®¢å•ç»å¸¸è¢«æ‹’ç»æ€ä¹ˆåŠï¼Ÿ
A: æ£€æŸ¥ç²¾åº¦è®¾ç½®ã€æœ€å°åä¹‰ä»·å€¼ã€è´¦æˆ·ä½™é¢

Q: ATRé€šé“çªç ´é¢‘ç¹è§¦å‘æ­¢æŸï¼Ÿ
A: è°ƒå¤§ATRå€æ•°æˆ–æ£€æŸ¥å¸‚åœºå¼‚å¸¸æ³¢åŠ¨

Q: ç½‘æ ¼æˆäº¤ç‡ä½ï¼Ÿ
A: è°ƒæ•´ç½‘æ ¼é—´è·æˆ–å¢åŠ æŒ‚å•æ•°é‡

Q: èµ„é‡‘åˆ©ç”¨ç‡ä¸è¶³ï¼Ÿ
A: æ£€æŸ¥æ æ†è®¾ç½®å’Œæ¯æ ¼é‡‘é¢è®¡ç®—

Q: åŒè´¦æˆ·ä¸åŒæ­¥ï¼Ÿ
A: æ£€æŸ¥ç½‘ç»œè¿æ¥å’ŒAPIæƒé™è®¾ç½®
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-07-09  
**é€‚ç”¨ç¯å¢ƒ**: å¸å®‰æœŸè´§API  
**é£é™©æç¤º**: æœ¬ç­–ç•¥æ¶‰åŠæ æ†äº¤æ˜“ï¼Œè¯·å……åˆ†äº†è§£é£é™©åä½¿ç”¨
