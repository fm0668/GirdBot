# æŒ‡æ ‡å‚æ•°è®¡ç®—å¯¹æ¯”åˆ†ææŠ¥å‘Š

## ğŸ“‹ æ¦‚è¿°

æœ¬æŠ¥å‘Šå¯¹æ¯”åˆ†æäº†é¡¹ç›®ä»£ç å®ç°ä¸è®¾è®¡æ–‡æ¡£ã€ŠåŒå¸æˆ·å¯¹å†²ç½‘æ ¼è®¡ç®—å±‚ï¼ˆæŒ‡æ ‡å‚æ•°è®¡ç®—ï¼‰æ–¹æ¡ˆ.mdã€‹ä¸­çš„è®¡ç®—é€»è¾‘ï¼Œæ£€æŸ¥å®ç°çš„ä¸€è‡´æ€§å’Œæ•°æ®è·å–çš„å®Œæ•´æ€§ã€‚

## ğŸ” è¯¦ç»†å¯¹æ¯”åˆ†æ

### 1. ATRé€šé“è¾¹ç•Œè®¡ç®—é€»è¾‘

#### ğŸ“„ è®¾è®¡æ–‡æ¡£è¦æ±‚ï¼š
```
1. è·å–Kçº¿æ•°æ®ï¼šä½¿ç”¨ ccxt ä»å¸å®‰è·å–Kçº¿æ•°æ®ï¼Œè½¬æ¢ä¸º pandas.DataFrameï¼ŒåŒ…å« open, high, low, close, volume åˆ—
2. è®¡ç®—çœŸå®æ³¢å¹… (TR)ï¼šTR = max(high - low, abs(high - close[1]), abs(low - close[1]))
3. è®¡ç®—å¹³æ»‘åçš„ATRï¼šæ ¹æ®ç”¨æˆ·é€‰æ‹©çš„ smoothing æ–¹æ³•ï¼ˆRMA, SMA, EMA, WMAï¼‰
4. è®¡ç®—ATRé€šé“ä¸Šä¸‹è½¨ï¼š
   - x = a + src1 (ä¸Šè½¨ = high + atr*multiplier) --> åšç©ºç½‘æ ¼æ­¢æŸçº¿
   - x2 = src2 - a (ä¸‹è½¨ = low - atr*multiplier) --> åšå¤šç½‘æ ¼æ­¢æŸçº¿
```

#### âœ… é¡¹ç›®ä»£ç å®ç°ï¼š
**æ–‡ä»¶ï¼š`core/atr_calculator.py`**

```python
# 1. Kçº¿æ•°æ®è·å– - âœ… å®Œå…¨ä¸€è‡´
async def get_latest_klines(self, symbol: str, timeframe: str, limit: int) -> pd.DataFrame:
    ohlcv = await self.exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

# 2. çœŸå®æ³¢å¹…è®¡ç®— - âœ… å®Œå…¨ä¸€è‡´
def calculate_true_range(self, df: pd.DataFrame) -> pd.Series:
    high_low = df['high'] - df['low']
    high_close_prev = abs(df['high'] - df['close'].shift(1))
    low_close_prev = abs(df['low'] - df['close'].shift(1))
    tr = pd.concat([high_low, high_close_prev, low_close_prev], axis=1).max(axis=1)

# 3. ATRå¹³æ»‘è®¡ç®— - âœ… æ”¯æŒæ‰€æœ‰è¦æ±‚çš„æ–¹æ³•
def smooth_atr(self, tr_series: pd.Series, method: str, length: int) -> pd.Series:
    if method == 'RMA':
        return tr_series.ewm(alpha=1/length, adjust=False).mean()
    elif method == 'SMA':
        return tr_series.rolling(window=length).mean()
    # ... æ”¯æŒ EMA, WMA

# 4. ATRé€šé“è®¡ç®— - âœ… å®Œå…¨ä¸€è‡´
upper_bound = high_price + (atr_value * config.multiplier)  # åšç©ºç½‘æ ¼æ­¢æŸçº¿
lower_bound = low_price - (atr_value * config.multiplier)   # åšå¤šç½‘æ ¼æ­¢æŸçº¿
```

**ç»“è®ºï¼šâœ… ATRè®¡ç®—é€»è¾‘å®Œå…¨ä¸€è‡´**

---

### 2. ç½‘æ ¼é—´è·è®¡ç®—é€»è¾‘

#### ğŸ“„ è®¾è®¡æ–‡æ¡£è¦æ±‚ï¼š
```
ç½‘æ ¼é—´è· â‰ˆ ï¼ˆç›®æ ‡æœ€ä½æ¯›åˆ©æ¶¦ç‡+äº¤æ˜“æ‰‹ç»­è´¹*2ï¼‰*ä»·æ ¼èŒƒå›´ä¸Šé™
- ç›®æ ‡æœ€ä½æ¯›åˆ©æ¶¦ç‡ï¼šé…ç½®æ–‡ä»¶è®¾å®šï¼Œé»˜è®¤0.2%
- äº¤æ˜“æ‰‹ç»­è´¹ï¼šé€šè¿‡APIè·å–å¸å®‰äº¤æ˜“æ‰€å¯¹åº”äº¤æ˜“å¯¹çš„æŒ‚å•æ‰‹ç»­è´¹
- ä»·æ ¼èŒƒå›´ä¸Šé™ï¼šATRé€šé“ä¸Šè½¨å¯¹åº”çš„ä»·æ ¼
```

#### âœ… é¡¹ç›®ä»£ç å®ç°ï¼š
**æ–‡ä»¶ï¼š`core/grid_calculator.py`**

```python
async def calculate_grid_spacing(
    self,
    upper_bound: Decimal,
    lower_bound: Decimal,
    target_profit_rate: Decimal,
    trading_fees: Decimal
) -> Decimal:
    # æŒ‰ç…§è¦æ±‚çš„é€»è¾‘è®¡ç®—ç½‘æ ¼é—´è·
    # ç½‘æ ¼é—´è· â‰ˆ ï¼ˆç›®æ ‡æœ€ä½æ¯›åˆ©æ¶¦ç‡+äº¤æ˜“æ‰‹ç»­è´¹*2ï¼‰*ä»·æ ¼èŒƒå›´ä¸Šé™
    grid_spacing = (target_profit_rate + trading_fees * Decimal("2")) * upper_bound
```

**ç»“è®ºï¼šâœ… ç½‘æ ¼é—´è·è®¡ç®—é€»è¾‘å®Œå…¨ä¸€è‡´**

---

### 3. ç½‘æ ¼å±‚æ•°è®¡ç®—é€»è¾‘

#### ğŸ“„ è®¾è®¡æ–‡æ¡£è¦æ±‚ï¼š
```
ç½‘æ ¼å±‚æ•° = (ç½‘æ ¼ä»·æ ¼åŒºé—´) / (ç½‘æ ¼é—´è·)
- ç½‘æ ¼ä»·æ ¼åŒºé—´ï¼šATRé€šé“ä¸Šè½¨ - ATRé€šé“ä¸‹è½¨
- è®¡ç®—å‡ºçš„æ•°å€¼å‘ä¸‹å–æ•´
```

#### âœ… é¡¹ç›®ä»£ç å®ç°ï¼š
**æ–‡ä»¶ï¼š`core/grid_calculator.py`**

```python
async def calculate_grid_levels(self, price_range: Decimal, grid_spacing: Decimal) -> int:
    # è®¡ç®—ç†è®ºå±‚æ•°å¹¶å‘ä¸‹å–æ•´
    theoretical_levels = price_range / grid_spacing
    grid_levels = int(theoretical_levels)  # å‘ä¸‹å–æ•´
    
    # é™åˆ¶åœ¨åˆç†èŒƒå›´å†…
    grid_levels = max(min_levels, min(max_levels, grid_levels))
```

**ç»“è®ºï¼šâœ… ç½‘æ ¼å±‚æ•°è®¡ç®—é€»è¾‘å®Œå…¨ä¸€è‡´**

---

### 4. æœ€å¤§æ æ†è®¡ç®—é€»è¾‘

#### ğŸ“„ è®¾è®¡æ–‡æ¡£è¦æ±‚ï¼š
```python
# 1. è®¡ç®—å¤šå¤´ç†è®ºæœ€å¤§æ æ†
long_factor = 1 + mmr - (lower_bound / avg_entry_price)
max_leverage_long = 1 / long_factor (å¦‚æœlong_factor > 0)

# 2. è®¡ç®—ç©ºå¤´ç†è®ºæœ€å¤§æ æ†
short_factor = (upper_bound / avg_entry_price) - 1 + mmr
max_leverage_short = 1 / short_factor (å¦‚æœshort_factor > 0)

# 3. å–è¾ƒä¿å®ˆçš„æ æ†å¹¶åº”ç”¨å®‰å…¨ç³»æ•°
conservative_leverage = min(max_leverage_long, max_leverage_short)
usable_leverage = int(conservative_leverage * safety_factor)
```

#### âœ… é¡¹ç›®ä»£ç å®ç°ï¼š
**æ–‡ä»¶ï¼š`core/grid_calculator.py`**

```python
async def calculate_max_leverage(self, atr_result: ATRResult, mmr: Decimal, safety_factor: Decimal) -> int:
    # è®¡ç®—å¹³å‡å…¥åœºä»·æ ¼
    avg_entry_price = (atr_result.upper_bound + atr_result.lower_bound) / Decimal("2")
    
    # 1. è®¡ç®—å¤šå¤´ç†è®ºæœ€å¤§æ æ†
    long_factor = Decimal("1") + mmr - (atr_result.lower_bound / avg_entry_price)
    max_leverage_long = Decimal("1") / long_factor if long_factor > 0 else Decimal("100")
    
    # 2. è®¡ç®—ç©ºå¤´ç†è®ºæœ€å¤§æ æ†
    short_factor = (atr_result.upper_bound / avg_entry_price) - Decimal("1") + mmr
    max_leverage_short = Decimal("1") / short_factor if short_factor > 0 else Decimal("100")
    
    # 3. å–è¾ƒä¿å®ˆçš„æ æ†å¹¶åº”ç”¨å®‰å…¨ç³»æ•°
    conservative_leverage = min(max_leverage_long, max_leverage_short)
    usable_leverage = int(conservative_leverage * safety_factor)
```

**ç»“è®ºï¼šâœ… æœ€å¤§æ æ†è®¡ç®—é€»è¾‘å®Œå…¨ä¸€è‡´**

---

### 5. å•æ ¼ç½‘æ ¼é‡‘é¢è®¡ç®—é€»è¾‘

#### ğŸ“„ è®¾è®¡æ–‡æ¡£è¦æ±‚ï¼š
```python
# 1. è®¡ç®—æ€»æŠ•å…¥åä¹‰ä»·å€¼
total_nominal_value = total_balance * usable_leverage

# 2. è®¡ç®—æ¯æ ¼åˆ†é…çš„åä¹‰ä»·å€¼
nominal_value_per_grid = total_nominal_value / num_levels

# 3. æ£€æŸ¥æœ€å°åä¹‰ä»·å€¼é™åˆ¶
if nominal_value_per_grid < min_notional_value:
    new_num_levels = math.floor(total_nominal_value / min_notional_value)

# 4. è®¡ç®—æ¯æ ¼ä¸‹å•çš„åŸºç¡€è´§å¸æ•°é‡
quantity_per_grid = nominal_value_per_grid / current_price

# 5. ç²¾åº¦é‡åŒ–å¤„ç†
quantized_quantity = math.floor(quantity_per_grid / amount_precision) * amount_precision
```

#### âœ… é¡¹ç›®ä»£ç å®ç°ï¼š
**æ–‡ä»¶ï¼š`core/grid_calculator.py`**

```python
async def calculate_amount_per_grid(self, total_balance: Decimal, leverage: int, grid_levels: int, min_notional: Decimal, current_price: Decimal) -> Decimal:
    # 1. è®¡ç®—æ€»æŠ•å…¥åä¹‰ä»·å€¼
    usable_balance = total_balance * Decimal("0.8")  # ä½¿ç”¨80%ä½™é¢
    total_nominal_value = usable_balance * leverage
    
    # 2. è®¡ç®—æ¯æ ¼åˆ†é…çš„åä¹‰ä»·å€¼
    nominal_value_per_grid = total_nominal_value / grid_levels
    
    # 3. æ£€æŸ¥æ˜¯å¦æ»¡è¶³æœ€å°åä¹‰ä»·å€¼
    if nominal_value_per_grid < min_notional:
        new_num_levels = int(total_nominal_value / min_notional)
        # è°ƒæ•´å±‚æ•°å’Œé‡‘é¢
    
    # 4. è®¡ç®—æ¯æ ¼ä¸‹å•çš„åŸºç¡€è´§å¸æ•°é‡
    quantity_per_grid = nominal_value_per_grid / current_price
    
    # 5. ç²¾åº¦é‡åŒ–å¤„ç†
    quantity_per_grid = round_to_precision(quantity_per_grid, 6)
```

**ç»“è®ºï¼šâœ… å•æ ¼é‡‘é¢è®¡ç®—é€»è¾‘åŸºæœ¬ä¸€è‡´ï¼Œæœ‰å°å¹…ä¼˜åŒ–**

---

## ğŸ” äº¤æ˜“æ‰€æ•°æ®è·å–æ£€æŸ¥

### âœ… å·²æ­£ç¡®å®ç°çš„æ•°æ®è·å–ï¼š

1. **Kçº¿æ•°æ®è·å–** - âœ… å®Œæ•´å®ç°
   ```python
   # core/atr_calculator.py
   ohlcv = await self.exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
   df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
   ```

2. **è´¦æˆ·ä½™é¢è·å–** - âœ… å®Œæ•´å®ç°
   ```python
   # core/dual_account_manager.py
   async def get_account_balance(self, account_type: str) -> Decimal:
       balance = await exchange.fetch_balance()
       available_balance = balance.get(quote_asset, {}).get('free', 0)
   ```

### âš ï¸ éœ€è¦è¡¥å……çš„æ•°æ®è·å–ï¼š

1. **äº¤æ˜“æ‰‹ç»­è´¹è·å–** - âŒ ç¼ºå¤±
   - å½“å‰ä½¿ç”¨ç¡¬ç¼–ç å€¼ï¼š`trading_fees = Decimal("0.0004")`
   - éœ€è¦å®ç°ï¼š`await exchange.fetch_trading_fees(symbol)`

2. **ç»´æŒä¿è¯é‡‘ç‡(MMR)è·å–** - âŒ ç¼ºå¤±
   - å½“å‰ä½¿ç”¨ç¡¬ç¼–ç å€¼ï¼š`mmr = Decimal("0.1")`
   - éœ€è¦å®ç°ï¼šä»å¸å®‰æ æ†åˆ†å±‚è§„åˆ™è·å–

3. **äº¤æ˜“ç²¾åº¦è·å–** - âŒ ç¼ºå¤±
   - å½“å‰ä½¿ç”¨å›ºå®šç²¾åº¦ï¼š`round_to_precision(quantity_per_grid, 6)`
   - éœ€è¦å®ç°ï¼š`exchange.markets[symbol]['precision']['amount']`

4. **æœ€å°åä¹‰ä»·å€¼è·å–** - âŒ ç¼ºå¤±
   - å½“å‰ä½¿ç”¨ç¡¬ç¼–ç å€¼ï¼š`min_notional = Decimal("5")`
   - éœ€è¦å®ç°ï¼š`exchange.markets[symbol]['limits']['cost']['min']`

## ğŸ“Š æ€»ä½“è¯„ä¼°

### âœ… ä¼˜ç‚¹ï¼š
1. **è®¡ç®—é€»è¾‘å®Œå…¨ä¸€è‡´**ï¼šæ‰€æœ‰æ ¸å¿ƒè®¡ç®—é€»è¾‘éƒ½ä¸è®¾è®¡æ–‡æ¡£ä¿æŒä¸€è‡´
2. **ä»£ç ç»“æ„æ¸…æ™°**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼ŒèŒè´£åˆ†ç¦»æ˜ç¡®
3. **é”™è¯¯å¤„ç†å®Œå–„**ï¼šåŒ…å«å®Œæ•´çš„å¼‚å¸¸å¤„ç†æœºåˆ¶
4. **æ—¥å¿—è®°å½•è¯¦ç»†**ï¼šä¾¿äºè°ƒè¯•å’Œç›‘æ§

### âš ï¸ éœ€è¦æ”¹è¿›ï¼š
1. **åŠ¨æ€æ•°æ®è·å–**ï¼šéœ€è¦å®ç°ä»äº¤æ˜“æ‰€åŠ¨æ€è·å–æ‰‹ç»­è´¹ã€ç²¾åº¦ç­‰å‚æ•°
2. **å‚æ•°éªŒè¯**ï¼šéœ€è¦å¢å¼ºå¯¹äº¤æ˜“æ‰€è¿”å›æ•°æ®çš„éªŒè¯
3. **ç¼“å­˜æœºåˆ¶**ï¼šå¯¹äºä¸å¸¸å˜åŒ–çš„æ•°æ®ï¼ˆå¦‚ç²¾åº¦ã€æ‰‹ç»­è´¹ï¼‰å¯ä»¥å¢åŠ ç¼“å­˜

## ğŸ¯ æ”¹è¿›å»ºè®®

### 1. ç«‹å³å®ç°åŠ¨æ€æ•°æ®è·å–

#### ğŸ“ æ–°å¢æ–‡ä»¶ï¼š`core/exchange_data_provider.py`
åŸºäº `äº¤æ˜“æ‰€æ•°æ®è·å–æ”¹è¿›æ–¹æ¡ˆ.py` å®ç°ï¼Œæä¾›ä»¥ä¸‹åŠŸèƒ½ï¼š

```python
class ExchangeDataProvider:
    async def get_symbol_info(self, symbol: str) -> TradingSymbolInfo
    async def _get_trading_fees(self, symbol: str) -> Dict[str, Decimal]
    async def _get_margin_info(self, symbol: str) -> Dict[str, Decimal]
    async def validate_order_params(self, symbol: str, amount: Decimal, price: Decimal) -> Tuple[bool, str]
    def format_amount(self, symbol: str, amount: Decimal) -> Decimal
    def format_price(self, symbol: str, price: Decimal) -> Decimal
```

#### ğŸ”§ ä¿®æ”¹ç°æœ‰æ–‡ä»¶ï¼š

**1. ä¿®æ”¹ `core/grid_calculator.py`**
```python
# æ·»åŠ äº¤æ˜“æ‰€æ•°æ®æä¾›å™¨ä¾èµ–
def __init__(self, data_provider: ExchangeDataProvider):
    self.data_provider = data_provider

# ä¿®æ”¹è®¡ç®—æ–¹æ³•ï¼Œä½¿ç”¨åŠ¨æ€è·å–çš„æ•°æ®
async def calculate_grid_parameters(self, ...):
    # è·å–äº¤æ˜“å¯¹ä¿¡æ¯
    symbol_info = await self.data_provider.get_symbol_info(symbol)

    # ä½¿ç”¨å®é™…æ‰‹ç»­è´¹
    trading_fees = symbol_info.maker_fee

    # ä½¿ç”¨å®é™…ç»´æŒä¿è¯é‡‘ç‡
    mmr = symbol_info.maintenance_margin_rate

    # ä½¿ç”¨å®é™…æœ€å°åä¹‰ä»·å€¼
    min_notional = symbol_info.min_cost

    # ä½¿ç”¨å®é™…ç²¾åº¦æ ¼å¼åŒ–ç»“æœ
    amount_per_grid = self.data_provider.format_amount(symbol, amount_per_grid)
```

**2. ä¿®æ”¹ `core/shared_grid_engine.py`**
```python
# æ·»åŠ æ•°æ®æä¾›å™¨åˆå§‹åŒ–
def __init__(self, exchange, dual_config, executor_config):
    self.data_provider = ExchangeDataProvider(exchange)
    self.grid_calculator = GridCalculator(self.data_provider)

# ä¿®æ”¹å‚æ•°æ›´æ–°æ–¹æ³•
async def update_grid_parameters(self) -> bool:
    # è·å–å®é™…è´¦æˆ·ä½™é¢
    account_balances = await self._get_real_account_balances()

    # è·å–äº¤æ˜“å¯¹ä¿¡æ¯
    symbol_info = await self.data_provider.get_symbol_info(self.dual_config.trading_pair)
```

### 2. å¢åŠ æ•°æ®éªŒè¯å’Œç¼“å­˜æœºåˆ¶

#### ğŸ” æ•°æ®éªŒè¯å¢å¼ºï¼š
```python
# åœ¨ ExchangeDataProvider ä¸­å®ç°
async def validate_symbol_data(self, symbol: str) -> bool:
    """éªŒè¯äº¤æ˜“å¯¹æ•°æ®å®Œæ•´æ€§"""
    try:
        symbol_info = await self.get_symbol_info(symbol)

        # éªŒè¯å…³é”®æ•°æ®
        if symbol_info.maker_fee <= 0 or symbol_info.maker_fee > Decimal("0.01"):
            self.logger.warning(f"å¼‚å¸¸çš„æ‰‹ç»­è´¹ç‡: {symbol_info.maker_fee}")
            return False

        if symbol_info.maintenance_margin_rate <= 0 or symbol_info.maintenance_margin_rate > Decimal("0.5"):
            self.logger.warning(f"å¼‚å¸¸çš„ä¿è¯é‡‘ç‡: {symbol_info.maintenance_margin_rate}")
            return False

        return True
    except Exception as e:
        self.logger.error(f"æ•°æ®éªŒè¯å¤±è´¥: {e}")
        return False
```

#### ğŸ’¾ ç¼“å­˜æœºåˆ¶ä¼˜åŒ–ï¼š
```python
# å®ç°å¤šçº§ç¼“å­˜
class CacheManager:
    def __init__(self):
        self._memory_cache = {}  # å†…å­˜ç¼“å­˜
        self._file_cache_path = "cache/exchange_data.json"  # æ–‡ä»¶ç¼“å­˜

    async def get_cached_data(self, key: str) -> Optional[dict]:
        # å…ˆæ£€æŸ¥å†…å­˜ç¼“å­˜
        if key in self._memory_cache:
            return self._memory_cache[key]

        # å†æ£€æŸ¥æ–‡ä»¶ç¼“å­˜
        return await self._load_from_file_cache(key)

    async def set_cached_data(self, key: str, data: dict):
        # åŒæ—¶æ›´æ–°å†…å­˜å’Œæ–‡ä»¶ç¼“å­˜
        self._memory_cache[key] = data
        await self._save_to_file_cache(key, data)
```

### 3. å®Œå–„æµ‹è¯•ç”¨ä¾‹è¦†ç›–

#### ğŸ“ æ–°å¢æµ‹è¯•æ–‡ä»¶ï¼š`tests/test_exchange_data_provider.py`
```python
class TestExchangeDataProvider:
    @pytest.mark.asyncio
    async def test_get_symbol_info_success(self):
        """æµ‹è¯•è·å–äº¤æ˜“å¯¹ä¿¡æ¯æˆåŠŸ"""

    @pytest.mark.asyncio
    async def test_get_trading_fees_fallback(self):
        """æµ‹è¯•æ‰‹ç»­è´¹è·å–å¤±è´¥æ—¶çš„é™çº§å¤„ç†"""

    @pytest.mark.asyncio
    async def test_validate_order_params(self):
        """æµ‹è¯•è®¢å•å‚æ•°éªŒè¯"""

    @pytest.mark.asyncio
    async def test_format_precision(self):
        """æµ‹è¯•ç²¾åº¦æ ¼å¼åŒ–"""
```

#### ğŸ”§ ä¿®æ”¹ç°æœ‰æµ‹è¯•ï¼š
```python
# ä¿®æ”¹ tests/test_grid_calculator.py
# ä½¿ç”¨æ¨¡æ‹Ÿçš„ ExchangeDataProvider è¿›è¡Œæµ‹è¯•
@pytest.fixture
def mock_data_provider():
    provider = Mock(spec=ExchangeDataProvider)
    provider.get_symbol_info.return_value = TradingSymbolInfo(...)
    return provider
```

### 4. ä¼˜åŒ–æ€§èƒ½å’Œé”™è¯¯å¤„ç†

#### âš¡ æ€§èƒ½ä¼˜åŒ–ï¼š
```python
# æ‰¹é‡è·å–æ•°æ®
async def batch_get_symbol_info(self, symbols: List[str]) -> Dict[str, TradingSymbolInfo]:
    """æ‰¹é‡è·å–å¤šä¸ªäº¤æ˜“å¯¹ä¿¡æ¯"""
    tasks = [self.get_symbol_info(symbol) for symbol in symbols]
    results = await asyncio.gather(*tasks, return_exceptions=True)

    return {
        symbol: result for symbol, result in zip(symbols, results)
        if not isinstance(result, Exception)
    }

# å¼‚æ­¥ç¼“å­˜é¢„çƒ­
async def warm_up_cache(self, symbols: List[str]):
    """é¢„çƒ­ç¼“å­˜"""
    await self.batch_get_symbol_info(symbols)
```

#### ğŸ›¡ï¸ é”™è¯¯å¤„ç†å¢å¼ºï¼š
```python
# å®ç°é‡è¯•æœºåˆ¶
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=4, max=10)
)
async def _fetch_with_retry(self, fetch_func, *args, **kwargs):
    """å¸¦é‡è¯•çš„æ•°æ®è·å–"""
    try:
        return await fetch_func(*args, **kwargs)
    except Exception as e:
        self.logger.warning(f"æ•°æ®è·å–å¤±è´¥ï¼Œå‡†å¤‡é‡è¯•: {e}")
        raise

# å®ç°é™çº§ç­–ç•¥
async def get_trading_fees_with_fallback(self, symbol: str) -> Dict[str, Decimal]:
    """å¸¦é™çº§ç­–ç•¥çš„æ‰‹ç»­è´¹è·å–"""
    try:
        return await self._get_trading_fees(symbol)
    except Exception as e:
        self.logger.error(f"è·å–æ‰‹ç»­è´¹å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼: {e}")
        return self._get_default_trading_fees()
```

## ğŸ“‹ å®æ–½è®¡åˆ’

### é˜¶æ®µ1ï¼šæ ¸å¿ƒåŠŸèƒ½å®ç°ï¼ˆ1-2å¤©ï¼‰
1. åˆ›å»º `ExchangeDataProvider` ç±»
2. å®ç°åŸºç¡€æ•°æ®è·å–æ–¹æ³•
3. é›†æˆåˆ°ç°æœ‰è®¡ç®—å™¨ä¸­

### é˜¶æ®µ2ï¼šä¼˜åŒ–å’Œæµ‹è¯•ï¼ˆ1å¤©ï¼‰
1. æ·»åŠ ç¼“å­˜æœºåˆ¶
2. å®Œå–„é”™è¯¯å¤„ç†
3. ç¼–å†™å•å…ƒæµ‹è¯•

### é˜¶æ®µ3ï¼šéªŒè¯å’Œéƒ¨ç½²ï¼ˆ1å¤©ï¼‰
1. é›†æˆæµ‹è¯•
2. æ€§èƒ½æµ‹è¯•
3. æ–‡æ¡£æ›´æ–°

## âœ… é¢„æœŸæ•ˆæœ

1. **æ•°æ®å‡†ç¡®æ€§æå‡**ï¼šä½¿ç”¨å®æ—¶äº¤æ˜“æ‰€æ•°æ®æ›¿ä»£ç¡¬ç¼–ç å€¼
2. **ç³»ç»Ÿç¨³å®šæ€§å¢å¼º**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œé™çº§æœºåˆ¶
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šç¼“å­˜æœºåˆ¶å‡å°‘APIè°ƒç”¨æ¬¡æ•°
4. **ç»´æŠ¤æ€§æå‡**ï¼šæ¨¡å—åŒ–è®¾è®¡ä¾¿äºæ‰©å±•å’Œç»´æŠ¤
