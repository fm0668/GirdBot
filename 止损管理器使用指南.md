# 止损管理器(StopLossManager)使用指南

## 概述

`StopLossManager` 是双账户对冲网格策略的核心安全组件，负责:
- ATR通道突破检测
- 价格突破止损执行  
- 紧急停止机制
- 双账户健康状态监控
- 启动时安全检查

## 核心功能

### 1. ATR通道突破止损

**功能说明:**
- 监控价格是否突破预设的ATR通道上下边界
- 单一触发条件，避免误触
- 立即执行止损流程

**使用示例:**
```python
# 设置ATR边界
stop_loss_manager.set_atr_boundaries(
    upper_boundary=Decimal("0.4500"),
    lower_boundary=Decimal("0.3500")
)

# 检查突破
current_price = Decimal("0.4600")
if await stop_loss_manager.check_atr_breakout(current_price):
    await stop_loss_manager.execute_stop_loss(
        StopLossReason.ATR_CHANNEL_BREAKOUT, 
        current_price
    )
```

### 2. 账户健康监控

**功能说明:**
- 持续监控双账户连接状态
- 检测账户权限、交易状态等
- 自动触发止损保护资金安全

**使用示例:**
```python
# 运行时健康检查(带频率限制)
is_healthy = await stop_loss_manager.check_account_health()
if not is_healthy:
    # 自动触发止损，无需手动处理
    pass

# 启动时健康检查(多次重试)
startup_ok = await stop_loss_manager.check_startup_health(max_retries=3)
if not startup_ok:
    # 启动失败，自动执行紧急停止
    pass
```

### 3. 止损执行流程

**执行步骤:**
1. 立即取消所有挂单
2. 获取双账户持仓信息
3. 按浮亏大小有序平仓
4. 更新止损状态

**核心代码:**
```python
# 执行止损
success = await stop_loss_manager.execute_stop_loss(
    reason=StopLossReason.ATR_CHANNEL_BREAKOUT,
    current_price=current_price
)

# 检查止损状态
status = stop_loss_manager.get_stop_loss_status()
if status["is_active"]:
    print(f"止损已激活: {status['reason']}")
```

### 4. 紧急停止机制

**触发条件:**
- 正常止损流程失败
- 严重的账户连接异常
- 超时或其他系统异常

**特点:**
- 多次重试机制
- 并行强制平仓
- 超时保护机制

## 集成到网格策略

### 1. 初始化集成

```python
class GridStrategy:
    def __init__(self, config, dual_manager):
        # ...existing code...
        self.stop_loss_manager = StopLossManager(dual_manager, config.symbol)
    
    async def initialize(self) -> bool:
        # ...existing code...
        
        # 启动健康检查
        if not await self.stop_loss_manager.check_startup_health():
            self.logger.error("启动健康检查失败")
            return False
        
        # 设置ATR边界
        self.stop_loss_manager.set_atr_boundaries(
            upper_boundary=self.upper_boundary,
            lower_boundary=self.lower_boundary
        )
        
        # ...existing code...
```

### 2. 监控循环集成

```python
async def _monitor_loop(self):
    while self._running:
        try:
            # 获取当前价格
            await self._update_current_price()
            
            # 检查ATR通道突破
            if self.current_price and await self.stop_loss_manager.check_atr_breakout(self.current_price):
                self.logger.warning("ATR通道突破，触发止损")
                await self.stop_loss_manager.execute_stop_loss(
                    StopLossReason.ATR_CHANNEL_BREAKOUT, 
                    self.current_price
                )
                await self.stop("ATR_STOP_LOSS")
                break
            
            # 账户健康检查
            if not await self.stop_loss_manager.check_account_health():
                self.logger.warning("账户健康检查失败，触发止损")
                await self.stop("ACCOUNT_HEALTH_FAILURE")
                break
            
            # 检查止损管理器状态
            stop_loss_status = self.stop_loss_manager.get_stop_loss_status()
            if stop_loss_status["is_active"]:
                self.logger.warning(f"止损管理器已激活: {stop_loss_status['reason']}")
                await self.stop("STOP_LOSS_ACTIVE")
                break
            
            await asyncio.sleep(self.config.monitor_interval)
            
        except Exception as e:
            self.logger.error(f"监控循环异常: {e}")
            await asyncio.sleep(5)
```

### 3. 重启机制集成

```python
async def restart(self) -> bool:
    try:
        # 停止当前策略
        await self.stop("RESTART")
        
        # 重置止损管理器状态
        self.stop_loss_manager.reset_stop_loss_status()
        
        # 重新初始化
        if not await self.initialize():
            return False
        
        # 重新启动
        return await self.start()
        
    except Exception as e:
        self.logger.error(f"重启策略失败: {e}")
        return False
```

## 配置参数

### 止损管理器参数

```python
class StopLossManager:
    def __init__(self, dual_manager, symbol):
        # 容错参数
        self.max_stop_loss_retries = 3      # 最大止损重试次数
        self.stop_loss_retry_delay = 1.0    # 重试间隔(秒)
        self.emergency_stop_timeout = 30.0  # 紧急停止超时(秒)
        
        # 健康检查参数
        self.health_check_interval = 10.0   # 健康检查间隔(秒)
```

### 双账户健康检查参数

```python
# 账户状态检查项
- account_info["status"] == "NORMAL"      # 账户状态正常
- account_info["canTrade"] == True        # 可以交易
- "FUTURES" in permissions                # 有期货权限

# 持仓对齐检查
- 检查双账户持仓数量是否对齐
- 允许小幅误差(0.001)
- 单边持仓视为不对齐
```

## 状态管理

### 止损状态信息

```python
status = stop_loss_manager.get_stop_loss_status()
# 返回格式:
{
    "is_active": False,           # 是否已激活止损
    "reason": None,               # 止损原因
    "is_stopping": False,         # 是否正在执行止损
    "account_health": {           # 账户健康状态
        "long": True, 
        "short": True
    },
    "atr_boundaries": {           # ATR边界
        "upper": 0.4500, 
        "lower": 0.3500
    }
}
```

### 止损原因枚举

```python
class StopLossReason(Enum):
    ATR_CHANNEL_BREAKOUT = "ATR_CHANNEL_BREAKOUT"  # ATR通道突破
    ACCOUNT_FAILURE = "ACCOUNT_FAILURE"            # 账户故障
    EMERGENCY_STOP = "EMERGENCY_STOP"              # 紧急停止
    STARTUP_FAILURE = "STARTUP_FAILURE"            # 启动失败
```

## 最佳实践

### 1. 启动检查

```python
# 在策略启动前进行全面检查
async def safe_startup():
    # 1. 健康检查
    if not await stop_loss_manager.check_startup_health():
        return False
    
    # 2. 设置边界
    stop_loss_manager.set_atr_boundaries(upper, lower)
    
    # 3. 启动策略
    return await strategy.start()
```

### 2. 容错处理

```python
# 启动时双账户同步检查
async def check_dual_startup():
    max_retries = 3
    for attempt in range(max_retries):
        try:
            # 并行检查双账户
            long_orders = await place_long_orders()
            short_orders = await place_short_orders()
            
            if not long_orders:
                # 长账户失败，取消短账户订单
                await cancel_short_orders()
                if attempt == max_retries - 1:
                    await stop_loss_manager.execute_stop_loss(
                        StopLossReason.STARTUP_FAILURE
                    )
                continue
            
            if not short_orders:
                # 短账户失败，取消长账户订单
                await cancel_long_orders()
                if attempt == max_retries - 1:
                    await stop_loss_manager.execute_stop_loss(
                        StopLossReason.STARTUP_FAILURE
                    )
                continue
            
            # 双账户都成功
            return True
            
        except Exception as e:
            logger.error(f"启动第{attempt+1}次尝试失败: {e}")
            if attempt == max_retries - 1:
                await stop_loss_manager.execute_stop_loss(
                    StopLossReason.STARTUP_FAILURE
                )
    
    return False
```

### 3. 运行时监控

```python
# 在运行循环中集成各种检查
async def monitor_with_stop_loss():
    while running:
        try:
            # 1. 价格更新
            current_price = await get_current_price()
            
            # 2. ATR突破检查
            if await stop_loss_manager.check_atr_breakout(current_price):
                break  # 自动触发止损
            
            # 3. 账户健康检查
            if not await stop_loss_manager.check_account_health():
                break  # 自动触发止损
            
            # 4. 订单管理
            await manage_orders()
            
            # 5. 性能统计
            await update_metrics()
            
            await asyncio.sleep(monitor_interval)
            
        except Exception as e:
            logger.error(f"监控异常: {e}")
            # 严重异常时触发紧急停止
            await stop_loss_manager.execute_stop_loss(
                StopLossReason.EMERGENCY_STOP
            )
            break
```

## 测试验证

完整的测试覆盖了:
- ✅ ATR通道突破检测
- ✅ 账户健康状态检查
- ✅ 启动时安全验证
- ✅ 止损执行流程
- ✅ 紧急停止机制
- ✅ 状态管理和重置

所有测试用例都已通过，确保止损管理器的可靠性和健壮性。

## 总结

`StopLossManager` 为双账户对冲网格策略提供了完整的安全保护机制:

1. **预防性保护**: 启动时健康检查，确保双账户同步启动
2. **实时监控**: 持续监控价格突破和账户状态
3. **快速响应**: 单一触发条件，立即执行止损
4. **有序平仓**: 优先平浮亏大的账户，减少滑点
5. **容错机制**: 多重保护，确保在各种异常情况下都能安全停止

这样的设计确保了策略在各种市场条件和技术故障下都能保护资金安全。
