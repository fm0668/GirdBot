# 双账号对冲网格策略算法详解

## 1. 核心算法流程

### 1.1 策略初始化算法

```python
async def initialize_strategy_algorithm():
    """
    策略初始化算法
    时间复杂度: O(n) 其中n为K线数量
    空间复杂度: O(1)
    """
    # 第一阶段：账户验证与连接
    step1_success = await validate_and_connect_accounts()
    if not step1_success:
        return False
    
    # 第二阶段：市场数据采集
    klines = await fetch_market_data(period=100)  # 获取100根K线
    
    # 第三阶段：ATR计算
    atr_value = await calculate_atr_with_precision(klines)
    
    # 第四阶段：网格参数计算
    grid_params = await calculate_optimal_grid_parameters(atr_value)
    
    # 第五阶段：资金验证
    fund_check = await verify_fund_adequacy(grid_params)
    
    return step1_success and fund_check
```

### 1.2 ATR计算算法

```python
def calculate_atr_algorithm(klines: List[Dict], period: int = 14) -> Decimal:
    """
    ATR计算算法 - 完全复制TradingView Pine Script逻辑
    
    算法步骤：
    1. 计算每根K线的True Range
    2. 使用RMA(Relative Moving Average)计算ATR
    3. 应用指数加权移动平均
    
    时间复杂度: O(n) 其中n为K线数量
    空间复杂度: O(n) 存储中间计算结果
    """
    if len(klines) < period + 1:
        raise ValueError(f"K线数据不足，需要至少{period + 1}根")
    
    true_ranges = []
    
    # 第一步：计算True Range
    for i in range(1, len(klines)):
        current = klines[i]
        previous = klines[i - 1]
        
        # 获取OHLC数据
        high = Decimal(current['high'])
        low = Decimal(current['low'])
        prev_close = Decimal(previous['close'])
        
        # 计算三种True Range
        tr1 = high - low
        tr2 = abs(high - prev_close)
        tr3 = abs(low - prev_close)
        
        # 取最大值
        true_range = max(tr1, tr2, tr3)
        true_ranges.append(true_range)
    
    # 第二步：计算RMA (Relative Moving Average)
    # RMA公式: RMA[i] = (TR[i] + (n-1) * RMA[i-1]) / n
    # 等价于: alpha = 1/n 的指数加权移动平均
    
    rma_values = []
    alpha = Decimal('1') / Decimal(str(period))
    
    # 初始值：前period个TR的简单平均
    initial_rma = sum(true_ranges[:period]) / Decimal(str(period))
    rma_values.append(initial_rma)
    
    # 递推计算RMA
    for i in range(period, len(true_ranges)):
        current_tr = true_ranges[i]
        prev_rma = rma_values[-1]
        
        # RMA递推公式
        new_rma = alpha * current_tr + (Decimal('1') - alpha) * prev_rma
        rma_values.append(new_rma)
    
    # 返回最新的ATR值
    return rma_values[-1]
```

### 1.3 网格参数优化算法

```python
async def calculate_optimal_grid_parameters(atr_value: Decimal, current_price: Decimal) -> Dict:
    """
    网格参数优化算法
    
    目标：在给定资金约束下，最大化网格覆盖范围和盈利概率
    
    算法类型：约束优化问题
    目标函数：max(grid_coverage * profit_probability)
    约束条件：
    - total_margin <= available_margin * safety_factor
    - grid_spacing >= min_tick_size
    - max_levels <= system_limit
    """
    
    # 第一步：计算基础参数
    base_params = {
        'atr_value': atr_value,
        'current_price': current_price,
        'min_tick_size': await get_symbol_tick_size(symbol),
        'min_quantity': await get_symbol_min_quantity(symbol),
    }
    
    # 第二步：优化网格间距
    optimal_spacing = await optimize_grid_spacing(base_params)
    
    # 第三步：计算最大层数
    max_levels = await calculate_max_levels(optimal_spacing, base_params)
    
    # 第四步：计算每层数量
    quantity_per_level = await calculate_quantity_per_level(max_levels, base_params)
    
    # 第五步：验证参数可行性
    if not await validate_parameters(optimal_spacing, max_levels, quantity_per_level):
        # 如果不可行，使用保守参数
        return await calculate_conservative_parameters(base_params)
    
    return {
        'grid_spacing': optimal_spacing,
        'max_levels': max_levels,
        'amount_per_grid': quantity_per_level,
        'total_margin_needed': max_levels * quantity_per_level * current_price / leverage,
        'coverage_range': optimal_spacing * max_levels * 2,  # 双向覆盖
    }

async def optimize_grid_spacing(base_params: Dict) -> Decimal:
    """
    网格间距优化算法
    
    使用黄金分割法进行一维优化
    目标：找到最优的网格间距，平衡覆盖范围和成交概率
    """
    atr_value = base_params['atr_value']
    current_price = base_params['current_price']
    min_tick_size = base_params['min_tick_size']
    
    # 搜索区间
    min_spacing = max(min_tick_size, current_price * Decimal('0.0001'))  # 0.01%
    max_spacing = atr_value * Decimal('0.5')  # ATR的50%
    
    # 黄金分割法
    golden_ratio = (Decimal('5').sqrt() - Decimal('1')) / Decimal('2')
    
    # 初始点
    x1 = min_spacing + (max_spacing - min_spacing) * (Decimal('1') - golden_ratio)
    x2 = min_spacing + (max_spacing - min_spacing) * golden_ratio
    
    # 迭代优化
    for _ in range(20):  # 最大20次迭代
        f1 = await evaluate_spacing_fitness(x1, base_params)
        f2 = await evaluate_spacing_fitness(x2, base_params)
        
        if f1 > f2:
            max_spacing = x2
            x2 = x1
            x1 = min_spacing + (max_spacing - min_spacing) * (Decimal('1') - golden_ratio)
        else:
            min_spacing = x1
            x1 = x2
            x2 = min_spacing + (max_spacing - min_spacing) * golden_ratio
        
        # 收敛检查
        if abs(max_spacing - min_spacing) < min_tick_size:
            break
    
    return (x1 + x2) / Decimal('2')

async def evaluate_spacing_fitness(spacing: Decimal, base_params: Dict) -> Decimal:
    """
    评估网格间距的适应度
    
    适应度函数：
    fitness = coverage_score * probability_score * efficiency_score
    """
    atr_value = base_params['atr_value']
    current_price = base_params['current_price']
    
    # 覆盖范围得分 (spacing应该接近ATR的某个比例)
    optimal_ratio = Decimal('0.1')  # 经验值：ATR的10%
    coverage_score = Decimal('1') - abs(spacing / atr_value - optimal_ratio)
    coverage_score = max(Decimal('0'), coverage_score)
    
    # 成交概率得分 (间距越小，成交概率越高)
    probability_score = Decimal('1') / (Decimal('1') + spacing / (current_price * Decimal('0.01')))
    
    # 效率得分 (考虑手续费和滑点)
    fee_ratio = Decimal('0.0004')  # 0.04%手续费
    efficiency_score = spacing / (current_price * fee_ratio * Decimal('2'))
    efficiency_score = min(Decimal('1'), efficiency_score / Decimal('10'))
    
    return coverage_score * probability_score * efficiency_score
```

## 2. 订单执行算法

### 2.1 智能下单算法

```python
class SmartOrderExecutor:
    """智能订单执行器"""
    
    def __init__(self, dual_manager: DualAccountManager):
        self.dual_manager = dual_manager
        self.order_queue = asyncio.Queue()
        self.execution_stats = {
            'total_orders': 0,
            'successful_orders': 0,
            'failed_orders': 0,
            'average_latency': 0,
        }
    
    async def execute_order_with_retry(self, order: Dict) -> Dict:
        """
        带重试机制的订单执行算法
        
        算法特点：
        1. 指数退避重试
        2. 价格微调机制
        3. 部分成交处理
        4. 动态超时调整
        """
        max_retries = 3
        base_delay = 0.1
        
        for attempt in range(max_retries):
            try:
                # 第一步：预执行检查
                if not await self.pre_execution_check(order):
                    continue
                
                # 第二步：价格精度调整
                adjusted_order = await self.adjust_order_precision(order)
                
                # 第三步：执行订单
                start_time = time.time()
                result = await self.execute_single_order(adjusted_order)
                execution_time = time.time() - start_time
                
                # 第四步：后执行处理
                await self.post_execution_process(result, execution_time)
                
                return result
                
            except Exception as e:
                await self.handle_execution_error(e, order, attempt)
                
                if attempt < max_retries - 1:
                    # 指数退避
                    delay = base_delay * (2 ** attempt)
                    await asyncio.sleep(delay)
                    
                    # 价格微调（如果是价格相关错误）
                    if self.is_price_related_error(e):
                        order = await self.adjust_order_price(order, e)
        
        # 所有重试都失败
        await self.handle_final_failure(order)
        return {'status': 'failed', 'error': 'max_retries_exceeded'}
    
    async def pre_execution_check(self, order: Dict) -> bool:
        """
        预执行检查算法
        
        检查项目：
        1. 账户余额充足性
        2. 持仓模式正确性
        3. 价格合理性
        4. 数量合理性
        """
        # 检查账户余额
        account_type = order['account_type']
        connector = self.dual_manager.get_connector(account_type)
        balance = await connector.get_account_balance()
        
        required_margin = self.calculate_required_margin(order)
        if balance['available'] < required_margin:
            self.logger.warning(f"余额不足: 需要={required_margin}, 可用={balance['available']}")
            return False
        
        # 检查持仓模式
        position_mode = await connector.get_position_mode()
        if position_mode != 'BOTH':
            await connector.set_position_mode('BOTH')
        
        # 检查价格合理性
        current_price = await self.dual_manager.get_current_price(order['symbol'])
        price_deviation = abs(Decimal(order['price']) - current_price) / current_price
        if price_deviation > Decimal('0.05'):  # 5%偏差限制
            self.logger.warning(f"价格偏差过大: {price_deviation:.2%}")
            return False
        
        return True
    
    async def adjust_order_precision(self, order: Dict) -> Dict:
        """
        订单精度调整算法
        
        调整项目：
        1. 价格精度
        2. 数量精度
        3. 最小下单量
        """
        symbol = order['symbol']
        
        # 获取交易对信息
        symbol_info = await self.dual_manager.get_symbol_info(symbol)
        
        # 调整价格精度
        price_precision = symbol_info['pricePrecision']
        adjusted_price = self.round_to_precision(
            Decimal(order['price']), 
            price_precision
        )
        
        # 调整数量精度
        quantity_precision = symbol_info['quantityPrecision']
        adjusted_quantity = self.round_to_precision(
            Decimal(order['quantity']), 
            quantity_precision
        )
        
        # 检查最小下单量
        min_quantity = Decimal(symbol_info['minQty'])
        if adjusted_quantity < min_quantity:
            adjusted_quantity = min_quantity
        
        # 检查最小名义价值
        min_notional = Decimal(symbol_info['minNotional'])
        notional_value = adjusted_price * adjusted_quantity
        if notional_value < min_notional:
            adjusted_quantity = min_notional / adjusted_price
            adjusted_quantity = self.round_to_precision(adjusted_quantity, quantity_precision)
        
        return {
            **order,
            'price': str(adjusted_price),
            'quantity': str(adjusted_quantity)
        }
    
    def round_to_precision(self, value: Decimal, precision: int) -> Decimal:
        """
        精度舍入算法
        
        使用银行家舍入法，避免累积误差
        """
        multiplier = Decimal('10') ** precision
        return (value * multiplier).quantize(Decimal('1'), rounding=ROUND_HALF_EVEN) / multiplier
```

### 2.2 对冲订单算法

```python
class HedgeOrderManager:
    """对冲订单管理器"""
    
    def __init__(self, dual_manager: DualAccountManager):
        self.dual_manager = dual_manager
        self.hedge_pairs = {}  # 对冲订单对
        self.hedge_queue = asyncio.Queue()
    
    async def create_hedge_pair(self, trigger_order: Dict) -> Dict:
        """
        创建对冲订单对算法
        
        算法逻辑：
        1. 当一个网格订单成交时，立即在对手账户创建对冲订单
        2. 对冲订单价格 = 成交价格 ± 网格间距
        3. 对冲订单数量 = 成交数量
        """
        # 确定对冲参数
        if trigger_order['account_type'] == 'long_account':
            hedge_account = 'short_account'
            hedge_side = 'SELL' if trigger_order['side'] == 'BUY' else 'BUY'
            hedge_position_side = 'LONG' if trigger_order['side'] == 'BUY' else 'SHORT'
        else:
            hedge_account = 'long_account'
            hedge_side = 'BUY' if trigger_order['side'] == 'SELL' else 'SELL'
            hedge_position_side = 'SHORT' if trigger_order['side'] == 'SELL' else 'LONG'
        
        # 计算对冲价格
        trigger_price = Decimal(trigger_order['avg_price'])
        grid_spacing = await self.get_grid_spacing(trigger_order['symbol'])
        
        if hedge_side == 'BUY':
            hedge_price = trigger_price - grid_spacing
        else:
            hedge_price = trigger_price + grid_spacing
        
        # 创建对冲订单
        hedge_order = {
            'symbol': trigger_order['symbol'],
            'side': hedge_side,
            'type': 'LIMIT',
            'quantity': trigger_order['executed_qty'],
            'price': str(hedge_price),
            'position_side': hedge_position_side,
            'account_type': hedge_account,
            'time_in_force': 'GTC',
            'hedge_pair_id': f"{trigger_order['order_id']}_hedge"
        }
        
        return hedge_order
    
    async def execute_hedge_strategy(self, filled_order: Dict):
        """
        执行对冲策略算法
        
        策略类型：
        1. 即时对冲：立即执行对冲订单
        2. 延迟对冲：等待更好的价格
        3. 部分对冲：分批执行对冲
        """
        strategy_type = await self.determine_hedge_strategy(filled_order)
        
        if strategy_type == 'immediate':
            await self.execute_immediate_hedge(filled_order)
        elif strategy_type == 'delayed':
            await self.execute_delayed_hedge(filled_order)
        elif strategy_type == 'partial':
            await self.execute_partial_hedge(filled_order)
    
    async def execute_immediate_hedge(self, filled_order: Dict):
        """
        即时对冲算法
        
        适用场景：
        1. 高波动市场
        2. 大额订单
        3. 风险规避模式
        """
        hedge_order = await self.create_hedge_pair(filled_order)
        
        # 添加紧急标记
        hedge_order['urgency'] = 'high'
        hedge_order['timeout'] = 5  # 5秒超时
        
        # 执行对冲
        result = await self.smart_executor.execute_order_with_retry(hedge_order)
        
        # 记录对冲结果
        await self.record_hedge_result(filled_order, hedge_order, result)
    
    async def monitor_hedge_positions(self):
        """
        对冲持仓监控算法
        
        监控项目：
        1. 持仓不平衡
        2. 未完成对冲
        3. 对冲失效
        """
        while True:
            try:
                # 获取双账户持仓
                long_positions = await self.dual_manager.long_account.get_positions()
                short_positions = await self.dual_manager.short_account.get_positions()
                
                # 计算净敞口
                net_exposure = await self.calculate_net_exposure(long_positions, short_positions)
                
                # 检查对冲有效性
                if abs(net_exposure) > await self.get_exposure_threshold():
                    await self.handle_hedge_imbalance(net_exposure)
                
                # 检查未完成对冲
                incomplete_hedges = await self.find_incomplete_hedges()
                for hedge in incomplete_hedges:
                    await self.handle_incomplete_hedge(hedge)
                
                await asyncio.sleep(5)  # 5秒检查一次
                
            except Exception as e:
                self.logger.error(f"对冲监控异常: {e}")
                await asyncio.sleep(10)
```

## 3. 风险控制算法

### 3.1 动态止损算法

```python
class DynamicStopLossAlgorithm:
    """动态止损算法"""
    
    def __init__(self, dual_manager: DualAccountManager):
        self.dual_manager = dual_manager
        self.stop_loss_levels = {}
        self.trailing_stops = {}
        
    async def calculate_dynamic_stop_loss(self, position: Dict) -> Decimal:
        """
        动态止损计算算法
        
        算法类型：自适应止损
        考虑因素：
        1. 当前波动率
        2. 历史最大回撤
        3. 持仓时间
        4. 市场流动性
        """
        symbol = position['symbol']
        position_side = position['position_side']
        entry_price = Decimal(position['entry_price'])
        current_price = await self.dual_manager.get_current_price(symbol)
        
        # 第一步：计算基础止损
        base_stop_loss = await self.calculate_base_stop_loss(position)
        
        # 第二步：波动率调整
        volatility_adjustment = await self.calculate_volatility_adjustment(symbol)
        
        # 第三步：时间衰减调整
        time_adjustment = await self.calculate_time_adjustment(position)
        
        # 第四步：流动性调整
        liquidity_adjustment = await self.calculate_liquidity_adjustment(symbol)
        
        # 综合调整
        adjusted_stop_loss = base_stop_loss * volatility_adjustment * time_adjustment * liquidity_adjustment
        
        # 应用方向性调整
        if position_side == 'LONG':
            stop_price = entry_price - adjusted_stop_loss
        else:
            stop_price = entry_price + adjusted_stop_loss
        
        return stop_price
    
    async def calculate_base_stop_loss(self, position: Dict) -> Decimal:
        """
        基础止损计算
        
        使用ATR的倍数作为基础止损
        """
        symbol = position['symbol']
        
        # 获取ATR值
        klines = await self.dual_manager.get_klines(symbol, '1h', 50)
        atr_value = await self.calculate_atr(klines)
        
        # 基础止损 = ATR * 止损倍数
        stop_loss_multiplier = Decimal('2.0')  # 2倍ATR
        base_stop_loss = atr_value * stop_loss_multiplier
        
        return base_stop_loss
    
    async def calculate_volatility_adjustment(self, symbol: str) -> Decimal:
        """
        波动率调整计算
        
        高波动率市场放宽止损，低波动率市场收紧止损
        """
        # 获取历史波动率
        historical_volatility = await self.get_historical_volatility(symbol, periods=20)
        
        # 获取隐含波动率（如果有期权数据）
        # implied_volatility = await self.get_implied_volatility(symbol)
        
        # 计算波动率分位数
        volatility_percentile = await self.calculate_volatility_percentile(historical_volatility)
        
        # 调整系数
        if volatility_percentile > 0.8:  # 高波动率
            adjustment = Decimal('1.5')
        elif volatility_percentile < 0.2:  # 低波动率
            adjustment = Decimal('0.7')
        else:  # 正常波动率
            adjustment = Decimal('1.0')
        
        return adjustment
    
    async def calculate_time_adjustment(self, position: Dict) -> Decimal:
        """
        时间衰减调整
        
        持仓时间越长，止损越宽松
        """
        current_time = time.time()
        entry_time = position['entry_time']
        holding_time = current_time - entry_time
        
        # 时间衰减函数
        # adjustment = 1 + log(1 + holding_time / 3600) * 0.1
        holding_hours = holding_time / 3600
        time_adjustment = Decimal('1') + Decimal(str(math.log(1 + holding_hours) * 0.1))
        
        # 限制最大调整幅度
        return min(time_adjustment, Decimal('2.0'))
    
    async def update_trailing_stop(self, position: Dict, current_price: Decimal):
        """
        追踪止损更新算法
        
        算法特点：
        1. 只向有利方向调整
        2. 动态调整追踪距离
        3. 突破确认机制
        """
        position_id = position['position_id']
        position_side = position['position_side']
        
        # 获取当前追踪止损
        current_trailing_stop = self.trailing_stops.get(position_id, {
            'stop_price': None,
            'trailing_distance': None,
            'last_update': None
        })
        
        # 计算动态追踪距离
        trailing_distance = await self.calculate_trailing_distance(position, current_price)
        
        # 更新追踪止损
        if position_side == 'LONG':
            new_stop_price = current_price - trailing_distance
            
            # 只向上调整止损
            if (current_trailing_stop['stop_price'] is None or 
                new_stop_price > current_trailing_stop['stop_price']):
                current_trailing_stop['stop_price'] = new_stop_price
                current_trailing_stop['trailing_distance'] = trailing_distance
                current_trailing_stop['last_update'] = time.time()
        else:
            new_stop_price = current_price + trailing_distance
            
            # 只向下调整止损
            if (current_trailing_stop['stop_price'] is None or 
                new_stop_price < current_trailing_stop['stop_price']):
                current_trailing_stop['stop_price'] = new_stop_price
                current_trailing_stop['trailing_distance'] = trailing_distance
                current_trailing_stop['last_update'] = time.time()
        
        # 保存更新后的追踪止损
        self.trailing_stops[position_id] = current_trailing_stop
        
        return current_trailing_stop
```

### 3.2 资金管理算法

```python
class AdvancedFundManager:
    """高级资金管理算法"""
    
    def __init__(self, dual_manager: DualAccountManager):
        self.dual_manager = dual_manager
        self.fund_allocation_history = []
        self.risk_budget = {}
        
    async def calculate_optimal_position_size(self, trade_signal: Dict) -> Decimal:
        """
        最优仓位计算算法
        
        使用凯利公式的修正版本
        考虑因素：
        1. 胜率
        2. 盈亏比
        3. 账户风险承受能力
        4. 相关性风险
        """
        symbol = trade_signal['symbol']
        
        # 第一步：计算历史胜率
        win_rate = await self.calculate_historical_win_rate(symbol)
        
        # 第二步：计算平均盈亏比
        avg_win_loss_ratio = await self.calculate_avg_win_loss_ratio(symbol)
        
        # 第三步：计算凯利比例
        kelly_fraction = await self.calculate_kelly_fraction(win_rate, avg_win_loss_ratio)
        
        # 第四步：风险调整
        risk_adjusted_fraction = await self.apply_risk_adjustment(kelly_fraction, trade_signal)
        
        # 第五步：计算仓位大小
        available_capital = await self.get_available_capital()
        position_size = available_capital * risk_adjusted_fraction
        
        return position_size
    
    async def calculate_kelly_fraction(self, win_rate: Decimal, avg_win_loss_ratio: Decimal) -> Decimal:
        """
        凯利公式计算
        
        Kelly% = (bp - q) / b
        其中：
        b = 盈亏比
        p = 胜率
        q = 败率 (1 - p)
        """
        if avg_win_loss_ratio <= 0 or win_rate <= 0:
            return Decimal('0')
        
        b = avg_win_loss_ratio
        p = win_rate
        q = Decimal('1') - p
        
        kelly_fraction = (b * p - q) / b
        
        # 限制最大仓位
        return max(Decimal('0'), min(kelly_fraction, Decimal('0.25')))  # 最大25%
    
    async def apply_risk_adjustment(self, kelly_fraction: Decimal, trade_signal: Dict) -> Decimal:
        """
        风险调整算法
        
        调整因素：
        1. 账户回撤状态
        2. 市场环境
        3. 持仓集中度
        4. 相关性风险
        """
        # 回撤调整
        current_drawdown = await self.calculate_current_drawdown()
        drawdown_adjustment = await self.calculate_drawdown_adjustment(current_drawdown)
        
        # 市场环境调整
        market_regime = await self.identify_market_regime()
        market_adjustment = await self.calculate_market_adjustment(market_regime)
        
        # 集中度调整
        concentration_risk = await self.calculate_concentration_risk(trade_signal['symbol'])
        concentration_adjustment = await self.calculate_concentration_adjustment(concentration_risk)
        
        # 相关性调整
        correlation_risk = await self.calculate_correlation_risk(trade_signal['symbol'])
        correlation_adjustment = await self.calculate_correlation_adjustment(correlation_risk)
        
        # 综合调整
        total_adjustment = (drawdown_adjustment * market_adjustment * 
                          concentration_adjustment * correlation_adjustment)
        
        adjusted_fraction = kelly_fraction * total_adjustment
        
        return max(Decimal('0'), min(adjusted_fraction, Decimal('0.1')))  # 最大10%
    
    async def dynamic_leverage_adjustment(self, current_positions: List[Dict]) -> int:
        """
        动态杠杆调整算法
        
        根据当前持仓状态动态调整杠杆倍数
        """
        # 计算当前风险敞口
        total_exposure = await self.calculate_total_exposure(current_positions)
        
        # 计算账户净值
        account_equity = await self.calculate_account_equity()
        
        # 计算风险比例
        risk_ratio = total_exposure / account_equity
        
        # 动态调整杠杆
        if risk_ratio > Decimal('0.8'):
            # 高风险，降低杠杆
            recommended_leverage = 3
        elif risk_ratio > Decimal('0.6'):
            # 中等风险，适中杠杆
            recommended_leverage = 5
        elif risk_ratio > Decimal('0.4'):
            # 低风险，可以使用更高杠杆
            recommended_leverage = 10
        else:
            # 极低风险，最高杠杆
            recommended_leverage = 15
        
        return min(recommended_leverage, 20)  # 最大20倍杠杆
```

## 4. 性能优化算法

### 4.1 缓存算法

```python
class IntelligentCacheManager:
    """智能缓存管理器"""
    
    def __init__(self, max_memory_mb: int = 100):
        self.max_memory_bytes = max_memory_mb * 1024 * 1024
        self.cache_storage = {}
        self.access_patterns = {}
        self.cache_stats = {
            'hits': 0,
            'misses': 0,
            'evictions': 0,
        }
        
    async def get_with_cache(self, key: str, fetch_func: Callable, ttl: int = 300) -> Any:
        """
        智能缓存获取算法
        
        算法特点：
        1. LRU + TTL混合策略
        2. 访问模式学习
        3. 预测性预加载
        4. 内存使用优化
        """
        current_time = time.time()
        
        # 第一步：检查缓存命中
        if key in self.cache_storage:
            cache_entry = self.cache_storage[key]
            
            # 检查TTL
            if current_time - cache_entry['timestamp'] < ttl:
                # 更新访问信息
                cache_entry['last_access'] = current_time
                cache_entry['access_count'] += 1
                
                # 更新访问模式
                await self.update_access_pattern(key, current_time)
                
                self.cache_stats['hits'] += 1
                return cache_entry['data']
            else:
                # 缓存过期，删除
                del self.cache_storage[key]
        
        # 第二步：缓存未命中，获取数据
        self.cache_stats['misses'] += 1
        data = await fetch_func()
        
        # 第三步：存储到缓存
        await self.store_in_cache(key, data, current_time)
        
        # 第四步：检查是否需要预加载
        await self.check_preload_opportunity(key)
        
        return data
    
    async def store_in_cache(self, key: str, data: Any, timestamp: float):
        """
        智能缓存存储算法
        
        存储策略：
        1. 内存使用检查
        2. 重要性评估
        3. 最优驱逐选择
        """
        # 计算数据大小
        data_size = self.calculate_data_size(data)
        
        # 检查内存使用
        current_memory = self.calculate_current_memory_usage()
        if current_memory + data_size > self.max_memory_bytes:
            # 需要驱逐一些缓存
            await self.intelligent_eviction(data_size)
        
        # 存储数据
        self.cache_storage[key] = {
            'data': data,
            'timestamp': timestamp,
            'last_access': timestamp,
            'access_count': 1,
            'size': data_size,
            'importance_score': await self.calculate_importance_score(key),
        }
    
    async def intelligent_eviction(self, required_space: int):
        """
        智能驱逐算法
        
        驱逐策略：
        1. 过期数据优先
        2. 访问频率考虑
        3. 重要性评估
        4. 数据大小权衡
        """
        current_time = time.time()
        eviction_candidates = []
        
        # 评估所有缓存项
        for key, cache_entry in self.cache_storage.items():
            # 计算驱逐分数
            eviction_score = await self.calculate_eviction_score(key, cache_entry, current_time)
            eviction_candidates.append((key, eviction_score, cache_entry['size']))
        
        # 按驱逐分数排序（分数越高越应该被驱逐）
        eviction_candidates.sort(key=lambda x: x[1], reverse=True)
        
        # 驱逐缓存直到释放足够空间
        freed_space = 0
        for key, score, size in eviction_candidates:
            if freed_space >= required_space:
                break
            
            del self.cache_storage[key]
            freed_space += size
            self.cache_stats['evictions'] += 1
    
    async def calculate_eviction_score(self, key: str, cache_entry: Dict, current_time: float) -> float:
        """
        计算驱逐分数
        
        分数越高越应该被驱逐
        """
        # 时间因素（越老分数越高）
        age_factor = current_time - cache_entry['timestamp']
        
        # 访问频率因素（访问越少分数越高）
        access_factor = 1 / (cache_entry['access_count'] + 1)
        
        # 最后访问时间因素
        last_access_factor = current_time - cache_entry['last_access']
        
        # 重要性因素（越不重要分数越高）
        importance_factor = 1 / (cache_entry['importance_score'] + 1)
        
        # 大小因素（越大分数越高）
        size_factor = cache_entry['size'] / (1024 * 1024)  # MB
        
        # 综合评分
        eviction_score = (age_factor * 0.3 + 
                         access_factor * 0.2 + 
                         last_access_factor * 0.2 + 
                         importance_factor * 0.2 + 
                         size_factor * 0.1)
        
        return eviction_score
```

### 4.2 并发控制算法

```python
class ConcurrencyController:
    """并发控制器"""
    
    def __init__(self, max_concurrent_requests: int = 10):
        self.max_concurrent_requests = max_concurrent_requests
        self.semaphore = asyncio.Semaphore(max_concurrent_requests)
        self.rate_limiter = RateLimiter()
        self.request_queue = asyncio.Queue()
        self.active_requests = {}
        
    async def execute_with_concurrency_control(self, request_id: str, 
                                             coro: Coroutine, 
                                             priority: int = 0) -> Any:
        """
        并发控制执行算法
        
        算法特点：
        1. 信号量控制并发数
        2. 优先级队列
        3. 自适应速率限制
        4. 请求去重
        """
        # 第一步：检查请求去重
        if request_id in self.active_requests:
            # 如果是相同请求，等待现有请求完成
            return await self.active_requests[request_id]
        
        # 第二步：创建请求Future
        request_future = asyncio.Future()
        self.active_requests[request_id] = request_future
        
        # 第三步：加入优先级队列
        await self.request_queue.put((priority, request_id, coro, request_future))
        
        # 第四步：等待执行完成
        try:
            result = await request_future
            return result
        finally:
            # 清理活跃请求
            self.active_requests.pop(request_id, None)
    
    async def process_request_queue(self):
        """
        请求队列处理算法
        
        处理策略：
        1. 优先级排序
        2. 并发控制
        3. 速率限制
        4. 错误处理
        """
        while True:
            try:
                # 获取下一个请求
                priority, request_id, coro, future = await self.request_queue.get()
                
                # 创建处理任务
                task = asyncio.create_task(
                    self.execute_request_with_limits(request_id, coro, future)
                )
                
                # 不等待任务完成，继续处理下一个请求
                
            except Exception as e:
                self.logger.error(f"请求队列处理异常: {e}")
                await asyncio.sleep(0.1)
    
    async def execute_request_with_limits(self, request_id: str, 
                                        coro: Coroutine, 
                                        future: asyncio.Future):
        """
        带限制的请求执行
        """
        # 等待信号量
        async with self.semaphore:
            try:
                # 速率限制
                await self.rate_limiter.acquire()
                
                # 执行请求
                result = await coro
                
                # 设置结果
                if not future.done():
                    future.set_result(result)
                    
            except Exception as e:
                # 设置异常
                if not future.done():
                    future.set_exception(e)

class AdaptiveRateLimiter:
    """自适应速率限制器"""
    
    def __init__(self, initial_rate: float = 10.0):
        self.current_rate = initial_rate
        self.min_rate = 1.0
        self.max_rate = 100.0
        self.last_acquire_time = 0
        self.success_count = 0
        self.error_count = 0
        self.adjustment_window = 60  # 60秒调整窗口
        
    async def acquire(self):
        """
        获取速率限制许可
        
        自适应调整算法：
        1. 成功率高 -> 提高速率
        2. 错误率高 -> 降低速率
        3. 平滑调整，避免震荡
        """
        current_time = time.time()
        
        # 计算等待时间
        time_since_last = current_time - self.last_acquire_time
        required_interval = 1.0 / self.current_rate
        
        if time_since_last < required_interval:
            wait_time = required_interval - time_since_last
            await asyncio.sleep(wait_time)
        
        self.last_acquire_time = time.time()
        
        # 定期调整速率
        await self.adjust_rate_if_needed()
    
    async def adjust_rate_if_needed(self):
        """
        自适应速率调整
        """
        current_time = time.time()
        
        # 检查是否需要调整
        if current_time - getattr(self, 'last_adjustment_time', 0) < self.adjustment_window:
            return
        
        # 计算成功率
        total_requests = self.success_count + self.error_count
        if total_requests == 0:
            return
        
        success_rate = self.success_count / total_requests
        
        # 调整速率
        if success_rate > 0.95:  # 高成功率，提高速率
            self.current_rate = min(self.current_rate * 1.1, self.max_rate)
        elif success_rate < 0.8:  # 低成功率，降低速率
            self.current_rate = max(self.current_rate * 0.9, self.min_rate)
        
        # 重置计数器
        self.success_count = 0
        self.error_count = 0
        self.last_adjustment_time = current_time
    
    def record_success(self):
        """记录成功请求"""
        self.success_count += 1
    
    def record_error(self):
        """记录错误请求"""
        self.error_count += 1
```

## 5. 总结

本文档详细介绍了双账号对冲网格策略的核心算法实现，包括：

### 5.1 核心算法特点
1. **ATR计算**：完全复制TradingView逻辑，确保指标准确性
2. **网格优化**：使用黄金分割法优化网格间距
3. **智能下单**：带重试机制和精度调整的订单执行
4. **动态止损**：基于波动率和时间的自适应止损
5. **资金管理**：凯利公式的风险调整版本

### 5.2 性能优化
1. **缓存管理**：智能缓存策略，平衡命中率和内存使用
2. **并发控制**：自适应速率限制和优先级队列
3. **异步处理**：全异步架构，提高执行效率

### 5.3 风险控制
1. **多层防护**：预执行检查、执行监控、后处理验证
2. **实时监控**：持续监控风险指标和系统状态
3. **紧急处理**：快速响应异常情况

这些算法的实现确保了策略的稳定性、高效性和安全性，为双账号对冲网格策略的成功运行提供了坚实的技术基础。
