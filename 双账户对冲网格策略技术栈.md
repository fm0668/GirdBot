# 双账户对冲网格策略技术栈

## 概述

双账户对冲网格策略是基于现有单账户ATR网格系统的扩展，通过两个独立的币安账户实现市场中性的对冲交易。一个账户专门执行多头网格策略，另一个账户专门执行空头网格策略，共享相同的网格参数计算，实现风险对冲和波动套利。

---

## 项目架构图

```
双账户对冲网格策略
├─ 配置管理层
│  ├─ config/dual_account_config.py    # 双账户配置管理
│  └─ .env                             # 环境变量配置
├─ 账户管理层
│  └─ core/dual_account_manager.py     # 双账户连接和管理
├─ 网格计算层（共享）
│  ├─ core/atr_calculator.py           # ATR指标计算（复用）
│  ├─ core/grid_calculator.py          # 网格参数计算（复用）
│  └─ core/shared_grid_engine.py       # 共享网格参数引擎
├─ 执行控制层
│  ├─ core/sync_controller.py          # 同步执行控制器
│  └─ hedge_grid_strategy.py           # 对冲网格策略主脚本
├─ 监控管理层
│  ├─ core/hedge_monitor.py            # 统一监控模块
│  └─ core/risk_hedge_controller.py    # 对冲风险控制
└─ 启动脚本层
   ├─ start_hedge_grid.sh              # 启动脚本
   └─ stop_hedge_grid.sh               # 停止脚本
```

---

## 1. 配置管理

### 1.1 双账户配置结构

**文件位置**：`config/dual_account_config.py`

```python
import os
from dataclasses import dataclass
from typing import Optional

@dataclass
class DualAccountConfig:
    """双账户对冲策略配置"""
    
    # 多头账户配置
    LONG_ACCOUNT_API_KEY: str = os.getenv('LONG_ACCOUNT_API_KEY')
    LONG_ACCOUNT_SECRET: str = os.getenv('LONG_ACCOUNT_SECRET')
    LONG_ACCOUNT_NAME: str = os.getenv('LONG_ACCOUNT_NAME', 'LongAccount')
    
    # 空头账户配置
    SHORT_ACCOUNT_API_KEY: str = os.getenv('SHORT_ACCOUNT_API_KEY')
    SHORT_ACCOUNT_SECRET: str = os.getenv('SHORT_ACCOUNT_SECRET')
    SHORT_ACCOUNT_NAME: str = os.getenv('SHORT_ACCOUNT_NAME', 'ShortAccount')
    
    # 对冲策略配置
    ENABLE_HEDGE_MODE: bool = True
    SHARED_GRID_PARAMETERS: bool = True
    SYNC_EXECUTION: bool = True
    HEDGE_RATIO_TOLERANCE: float = 0.05  # 对冲比例容忍度
    
    # 风险控制配置
    MAX_POSITION_IMBALANCE: float = 0.2  # 最大持仓不平衡比例
    EMERGENCY_STOP_LOSS: float = 0.1     # 紧急止损比例
    
    # 监控配置
    MONITOR_INTERVAL: int = 10           # 监控间隔（秒）
    LOG_HEDGE_STATUS: bool = True        # 记录对冲状态
    
    def validate_config(self) -> bool:
        """验证配置完整性"""
        required_fields = [
            self.LONG_ACCOUNT_API_KEY,
            self.LONG_ACCOUNT_SECRET,
            self.SHORT_ACCOUNT_API_KEY,
            self.SHORT_ACCOUNT_SECRET
        ]
        return all(field for field in required_fields)
```

### 1.2 配置继承与扩展

**基于现有配置的扩展**：

```python
from config.settings import config as base_config

class HedgeGridConfig(base_config.__class__):
    """继承原有配置并扩展对冲功能"""
    
    def __init__(self):
        super().__init__()
        self.dual_account = DualAccountConfig()
        
        # 验证双账户配置
        if not self.dual_account.validate_config():
            raise ValueError("双账户配置不完整，请检查环境变量")
    
    @property
    def is_hedge_mode_enabled(self) -> bool:
        """检查是否启用对冲模式"""
        return self.dual_account.ENABLE_HEDGE_MODE
```

### 1.3 配置管理器

```python
class ConfigManager:
    """配置管理器 - 统一管理单账户和双账户配置"""
    
    def __init__(self, mode: str = 'hedge'):
        self.mode = mode
        if mode == 'hedge':
            self.config = HedgeGridConfig()
        else:
            self.config = base_config
    
    def get_account_config(self, account_type: str) -> dict:
        """获取指定账户的配置"""
        if account_type.upper() == 'LONG':
            return {
                'api_key': self.config.dual_account.LONG_ACCOUNT_API_KEY,
                'secret': self.config.dual_account.LONG_ACCOUNT_SECRET,
                'name': self.config.dual_account.LONG_ACCOUNT_NAME
            }
        elif account_type.upper() == 'SHORT':
            return {
                'api_key': self.config.dual_account.SHORT_ACCOUNT_API_KEY,
                'secret': self.config.dual_account.SHORT_ACCOUNT_SECRET,
                'name': self.config.dual_account.SHORT_ACCOUNT_NAME
            }
        else:
            raise ValueError(f"不支持的账户类型: {account_type}")
```

---

## 2. 双账户管理

### 2.1 双账户管理器核心架构

**文件位置**：`core/dual_account_manager.py`

```python
import asyncio
from typing import Dict, Any, Optional, Tuple
from core.market_data import MarketDataProvider
from core.order_manager import OrderManager
from core.risk_controller import RiskController
from utils.logger import logger

class DualAccountManager:
    """双账户管理器 - 统一管理多空两个账户的连接和操作"""
    
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.accounts = {}
        self.market_data_providers = {}
        self.order_managers = {}
        self.risk_controllers = {}
        self.connection_status = {}
        
        # 初始化双账户
        self._initialize_accounts()
    
    def _initialize_accounts(self):
        """初始化双账户连接"""
        account_types = ['LONG', 'SHORT']
        
        for account_type in account_types:
            try:
                # 获取账户配置
                account_config = self.config_manager.get_account_config(account_type)
                
                # 创建账户实例
                self.accounts[account_type] = self._create_account_connection(
                    account_config['api_key'],
                    account_config['secret'],
                    account_config['name']
                )
                
                # 创建各模块实例
                self.market_data_providers[account_type] = MarketDataProvider()
                self.market_data_providers[account_type].set_account_connection(
                    self.accounts[account_type]
                )
                
                self.order_managers[account_type] = OrderManager(
                    self.market_data_providers[account_type]
                )
                
                self.risk_controllers[account_type] = RiskController(
                    self.market_data_providers[account_type],
                    self.order_managers[account_type]
                )
                
                self.connection_status[account_type] = True
                logger.info(f"{account_type}账户初始化成功")
                
            except Exception as e:
                logger.error(f"{account_type}账户初始化失败: {e}")
                self.connection_status[account_type] = False
                raise
    
    def _create_account_connection(self, api_key: str, secret: str, name: str):
        """创建账户连接"""
        from grid_binance_v3_atr import CustomGate
        
        exchange = CustomGate({
            "apiKey": api_key,
            "secret": secret,
            "options": {
                "defaultType": "future",
            },
        })
        exchange.load_markets(reload=False)
        return exchange
    
    async def check_connections(self) -> Dict[str, bool]:
        """检查所有账户连接状态"""
        connection_results = {}
        
        for account_type in ['LONG', 'SHORT']:
            try:
                # 测试连接
                balance = self.accounts[account_type].fetch_balance()
                connection_results[account_type] = True
                logger.debug(f"{account_type}账户连接正常")
            except Exception as e:
                connection_results[account_type] = False
                logger.error(f"{account_type}账户连接失败: {e}")
        
        return connection_results
    
    def get_account_instance(self, account_type: str):
        """获取指定账户的交易所实例"""
        return self.accounts.get(account_type.upper())
    
    def get_market_data_provider(self, account_type: str):
        """获取指定账户的行情提供器"""
        return self.market_data_providers.get(account_type.upper())
    
    def get_order_manager(self, account_type: str):
        """获取指定账户的订单管理器"""
        return self.order_managers.get(account_type.upper())
    
    def get_risk_controller(self, account_type: str):
        """获取指定账户的风险控制器"""
        return self.risk_controllers.get(account_type.upper())
```

### 2.2 账户状态同步器

```python
class AccountStateSynchronizer:
    """账户状态同步器 - 确保双账户状态一致性"""
    
    def __init__(self, dual_account_manager):
        self.dual_account_manager = dual_account_manager
        self.sync_lock = asyncio.Lock()
        self.last_sync_time = {}
        
    async def sync_account_states(self):
        """同步双账户状态"""
        async with self.sync_lock:
            try:
                # 同步持仓状态
                await self._sync_positions()
                
                # 同步订单状态
                await self._sync_orders()
                
                # 同步余额状态
                await self._sync_balances()
                
                logger.debug("账户状态同步完成")
                
            except Exception as e:
                logger.error(f"账户状态同步失败: {e}")
    
    async def _sync_positions(self):
        """同步持仓状态"""
        for account_type in ['LONG', 'SHORT']:
            try:
                risk_controller = self.dual_account_manager.get_risk_controller(account_type)
                long_pos, short_pos = risk_controller.get_position()
                
                # 记录持仓状态
                self.last_sync_time[f"{account_type}_position"] = time.time()
                logger.debug(f"{account_type}账户持仓: 多头={long_pos}, 空头={short_pos}")
                
            except Exception as e:
                logger.error(f"同步{account_type}账户持仓失败: {e}")
    
    async def _sync_orders(self):
        """同步订单状态"""
        for account_type in ['LONG', 'SHORT']:
            try:
                order_manager = self.dual_account_manager.get_order_manager(account_type)
                open_orders = order_manager.get_open_orders()
                
                logger.debug(f"{account_type}账户未成交订单数: {len(open_orders)}")
                
            except Exception as e:
                logger.error(f"同步{account_type}账户订单失败: {e}")
    
    async def _sync_balances(self):
        """同步余额状态"""
        for account_type in ['LONG', 'SHORT']:
            try:
                account = self.dual_account_manager.get_account_instance(account_type)
                balance = account.fetch_balance()
                
                logger.debug(f"{account_type}账户余额同步完成")
                
            except Exception as e:
                logger.error(f"同步{account_type}账户余额失败: {e}")
```

### 2.3 账户健康检查器

```python
class AccountHealthChecker:
    """账户健康检查器"""
    
    def __init__(self, dual_account_manager):
        self.dual_account_manager = dual_account_manager
        self.health_status = {}
    
    async def perform_health_check(self) -> Dict[str, Dict[str, Any]]:
        """执行健康检查"""
        health_results = {}
        
        for account_type in ['LONG', 'SHORT']:
            health_results[account_type] = await self._check_account_health(account_type)
        
        return health_results
    
    async def _check_account_health(self, account_type: str) -> Dict[str, Any]:
        """检查单个账户健康状态"""
        health_info = {
            'connection': False,
            'balance_sufficient': False,
            'position_reasonable': False,
            'orders_normal': False,
            'errors': []
        }
        
        try:
            # 检查连接
            account = self.dual_account_manager.get_account_instance(account_type)
            balance = account.fetch_balance()
            health_info['connection'] = True
            
            # 检查余额
            usdt_balance = balance.get('USDT', {}).get('free', 0)
            health_info['balance_sufficient'] = usdt_balance > 100  # 至少100 USDT
            
            # 检查持仓
            risk_controller = self.dual_account_manager.get_risk_controller(account_type)
            long_pos, short_pos = risk_controller.get_position()
            total_position = abs(long_pos) + abs(short_pos)
            health_info['position_reasonable'] = total_position < 10000  # 持仓不超过10000
            
            # 检查订单
            order_manager = self.dual_account_manager.get_order_manager(account_type)
            open_orders = order_manager.get_open_orders()
            health_info['orders_normal'] = len(open_orders) < 50  # 挂单不超过50个
            
        except Exception as e:
            health_info['errors'].append(str(e))
            logger.error(f"{account_type}账户健康检查失败: {e}")
        
        return health_info
```

---

## 3. 网格指标计算模块（共享）

### 3.1 共享网格参数引擎

**文件位置**：`core/shared_grid_engine.py`

```python
import asyncio
import time
from typing import Dict, Any, Optional, Tuple
from core.atr_calculator import ATRCalculator
from core.grid_calculator import GridCalculator
from core.market_data import MarketDataProvider
from utils.logger import logger

class SharedGridEngine:
    """共享网格参数引擎 - 为双账户提供统一的网格参数计算"""
    
    def __init__(self, market_data_provider: MarketDataProvider, config):
        self.market_data_provider = market_data_provider
        self.config = config
        
        # 初始化计算器（复用现有模块）
        self.atr_calculator = ATRCalculator(
            market_data_provider=market_data_provider,
            period=getattr(config, 'ATR_PERIOD', 14),
            multiplier=getattr(config, 'ATR_MULTIPLIER', 2.0),
            fixed_mode=getattr(config, 'ATR_FIXED_MODE', True)
        )
        
        self.grid_calculator = GridCalculator(market_data_provider)
        
        # 网格参数缓存
        self.shared_grid_params = {}
        self.last_calculation_time = 0
        self.calculation_lock = asyncio.Lock()
        
        # 参数更新标志
        self.params_updated = False
        
    async def calculate_shared_grid_parameters(self) -> Dict[str, Any]:
        """计算共享的网格参数 - 核心方法"""
        async with self.calculation_lock:
            try:
                current_time = time.time()
                
                # 防止频繁计算（至少间隔10秒）
                if current_time - self.last_calculation_time < 10:
                    logger.debug("网格参数计算间隔过短，返回缓存参数")
                    return self.shared_grid_params
                
                logger.info("开始计算共享网格参数...")
                
                # 1. 获取当前价格
                current_price = self.market_data_provider.get_current_price()
                if current_price <= 0:
                    raise ValueError(f"无效的当前价格: {current_price}")
                
                # 2. 计算ATR及通道（网格区间）
                atr_data = await self._calculate_atr_channel(current_price)
                
                # 3. 计算网格层数
                grid_levels_data = await self._calculate_grid_levels(current_price, atr_data)
                
                # 4. 计算网格间距
                grid_spacing = await self._calculate_grid_spacing(current_price, atr_data)
                
                # 5. 计算最大杠杆
                max_leverage = self._calculate_max_leverage()
                
                # 6. 计算单个网格金额
                grid_amount_data = await self._calculate_grid_amount(current_price)
                
                # 7. 组装共享参数
                self.shared_grid_params = {
                    'timestamp': current_time,
                    'current_price': current_price,
                    'atr_data': atr_data,
                    'grid_levels': grid_levels_data,
                    'grid_spacing': grid_spacing,
                    'max_leverage': max_leverage,
                    'grid_amount_data': grid_amount_data,
                    'calculation_summary': {
                        'total_long_levels': len(grid_levels_data.get('long_levels', [])),
                        'total_short_levels': len(grid_levels_data.get('short_levels', [])),
                        'grid_spacing_percent': (grid_spacing / current_price) * 100,
                        'atr_value': atr_data.get('atr_value', 0),
                        'upper_band': atr_data.get('upper_band', 0),
                        'lower_band': atr_data.get('lower_band', 0)
                    }
                }
                
                self.last_calculation_time = current_time
                self.params_updated = True
                
                logger.info("共享网格参数计算完成")
                logger.info(f"参数摘要: {self.shared_grid_params['calculation_summary']}")
                
                return self.shared_grid_params
                
            except Exception as e:
                logger.error(f"计算共享网格参数失败: {e}")
                raise
    
    async def _calculate_atr_channel(self, current_price: float) -> Dict[str, Any]:
        """计算ATR通道（网格区间）"""
        try:
            # 获取ATR值
            atr_value = self.atr_calculator.get_atr()
            if atr_value <= 0:
                raise ValueError("ATR值无效")
            
            # 计算ATR通道上下轨
            upper_band, lower_band = self.atr_calculator.get_atr_channel(current_price)
            
            return {
                'atr_value': atr_value,
                'upper_band': upper_band,
                'lower_band': lower_band,
                'channel_width': upper_band - lower_band,
                'channel_width_percent': ((upper_band - lower_band) / current_price) * 100
            }
            
        except Exception as e:
            logger.error(f"计算ATR通道失败: {e}")
            raise
    
    async def _calculate_grid_levels(self, current_price: float, atr_data: Dict) -> Dict[str, Any]:
        """计算网格层数"""
        try:
            # 使用现有的网格计算器
            grid_data = await self.grid_calculator.calculate_enhanced_grid_levels(
                current_price=current_price,
                atr_value=atr_data['atr_value'],
                account_balance=1000,  # 使用默认值，实际会在各账户中重新计算
                leverage=self.config.BASE_LEVERAGE
            )
            
            return grid_data.get('grid_levels', {})
            
        except Exception as e:
            logger.error(f"计算网格层数失败: {e}")
            raise
    
    async def _calculate_grid_spacing(self, current_price: float, atr_data: Dict) -> float:
        """计算网格间距"""
        try:
            # 使用ATR动态间距
            if getattr(self.config, 'USE_ATR_GRID_SPACING', True):
                num_levels = getattr(self.config, 'GRID_LEVELS', 5)
                spacing = self.atr_calculator.calculate_dynamic_grid_spacing(
                    current_price, num_levels
                )
            else:
                # 使用固定间距
                spacing = getattr(self.config, 'GRID_SPACING', 0.005) * current_price
            
            return spacing
            
        except Exception as e:
            logger.error(f"计算网格间距失败: {e}")
            raise
    
    def _calculate_max_leverage(self) -> int:
        """计算最大杠杆"""
        try:
            base_leverage = getattr(self.config, 'BASE_LEVERAGE', 10)
            max_leverage_limit = getattr(self.config, 'MAX_LEVERAGE_LIMIT', 20)
            
            # 简单逻辑：使用基础杠杆，不超过上限
            return min(base_leverage, max_leverage_limit)
            
        except Exception as e:
            logger.error(f"计算最大杠杆失败: {e}")
            return 10  # 默认杠杆
    
    async def _calculate_grid_amount(self, current_price: float) -> Dict[str, Any]:
        """计算单个网格金额"""
        try:
            # 使用现有的网格计算器计算position sizes
            position_data = await self.grid_calculator.calculate_position_sizes(
                current_price=current_price,
                account_balance=1000,  # 默认值，各账户会重新计算
                leverage=self.config.BASE_LEVERAGE,
                atr_value=self.atr_calculator.get_atr()
            )
            
            return position_data
            
        except Exception as e:
            logger.error(f"计算网格金额失败: {e}")
            raise
    
    def get_shared_parameters(self) -> Optional[Dict[str, Any]]:
        """获取共享参数（无需重新计算）"""
        return self.shared_grid_params if self.shared_grid_params else None
    
    def is_parameters_updated(self) -> bool:
        """检查参数是否已更新"""
        return self.params_updated
    
    def mark_parameters_consumed(self):
        """标记参数已被消费"""
        self.params_updated = False
    
    async def warmup_atr(self):
        """预热ATR计算器"""
        try:
            logger.info("正在预热共享ATR计算器...")
            
            # 获取历史K线数据
            klines = await self.market_data_provider.get_klines(
                symbol=self.config.SYMBOL,
                interval=getattr(self.config, 'ATR_TIMEFRAME', '1h'),
                limit=getattr(self.config, 'ATR_PERIOD', 14) * 2
            )
            
            if not klines:
                logger.warning("无法获取历史K线数据")
                return False
            
            # 添加历史数据到ATR计算器
            for kline in klines:
                high = float(kline[2])
                low = float(kline[3])
                close = float(kline[4])
                self.atr_calculator.add_price_data(high, low, close)
            
            atr_value = self.atr_calculator.get_atr()
            if atr_value > 0:
                logger.info(f"共享ATR预热完成，ATR值: {atr_value:.6f}")
                return True
            else:
                logger.warning("ATR预热失败")
                return False
                
        except Exception as e:
            logger.error(f"预热ATR计算器失败: {e}")
            return False
```

### 3.2 网格参数分发器

```python
class GridParameterDistributor:
    """网格参数分发器 - 将共享参数分发给双账户"""
    
    def __init__(self, shared_grid_engine: SharedGridEngine):
        self.shared_grid_engine = shared_grid_engine
        self.subscribers = {}  # 订阅者（双账户）
        
    def register_subscriber(self, account_type: str, callback):
        """注册参数订阅者"""
        self.subscribers[account_type] = callback
        logger.info(f"{account_type}账户已注册为网格参数订阅者")
    
    async def distribute_parameters(self):
        """分发参数给所有订阅者"""
        try:
            # 获取最新的共享参数
            shared_params = self.shared_grid_engine.get_shared_parameters()
            
            if not shared_params:
                logger.warning("没有可用的共享网格参数")
                return
            
            # 分发给所有订阅者
            for account_type, callback in self.subscribers.items():
                try:
                    # 为不同账户类型定制参数
                    customized_params = self._customize_parameters_for_account(
                        shared_params, account_type
                    )
                    
                    # 调用回调函数
                    await callback(customized_params)
                    logger.debug(f"参数已分发给{account_type}账户")
                    
                except Exception as e:
                    logger.error(f"分发参数给{account_type}账户失败: {e}")
            
            # 标记参数已消费
            self.shared_grid_engine.mark_parameters_consumed()
            
        except Exception as e:
            logger.error(f"分发网格参数失败: {e}")
    
    def _customize_parameters_for_account(self, shared_params: Dict, account_type: str) -> Dict:
        """为特定账户类型定制参数"""
        customized = shared_params.copy()
        
        # 根据账户类型调整策略方向
        if account_type.upper() == 'LONG':
            # 多头账户只关注long_levels
            customized['target_levels'] = shared_params['grid_levels'].get('long_levels', [])
            customized['strategy_direction'] = 'LONG'
        elif account_type.upper() == 'SHORT':
            # 空头账户只关注short_levels  
            customized['target_levels'] = shared_params['grid_levels'].get('short_levels', [])
            customized['strategy_direction'] = 'SHORT'
        
        return customized
```

---
## 4. 网格执行模块

### 4.1 对冲网格策略执行器

**文件位置**：`core/hedge_grid_executor.py`

```python
import asyncio
from typing import Dict, Any, List, Optional
from core.market_data import MarketDataProvider
from core.order_manager import OrderManager
from core.risk_controller import RiskController
from utils.logger import logger

class HedgeGridExecutor:
    """对冲网格执行器 - 基于共享参数执行单账户网格策略"""
    
    def __init__(self, account_type: str, account_config: Dict,
                 market_data_provider: MarketDataProvider,
                 order_manager: OrderManager,
                 risk_controller: RiskController):
        
        self.account_type = account_type.upper()
        self.account_config = account_config
        self.market_data_provider = market_data_provider
        self.order_manager = order_manager
        self.risk_controller = risk_controller
        
        # 执行状态
        self.current_grid_params = {}
        self.target_orders = []
        self.execution_enabled = False
        self.last_execution_time = 0
        
        # 锁机制
        self.execution_lock = asyncio.Lock()
        
        logger.info(f"{self.account_type}账户网格执行器初始化完成")
    
    async def update_grid_parameters(self, shared_params: Dict[str, Any]):
        """更新网格参数（从共享引擎接收）"""
        try:
            self.current_grid_params = shared_params
            
            # 重新计算目标订单
            await self._calculate_target_orders()
            
            logger.info(f"{self.account_type}账户网格参数已更新")
            
        except Exception as e:
            logger.error(f"{self.account_type}账户更新网格参数失败: {e}")
    
    async def _calculate_target_orders(self):
        """根据当前参数计算目标订单"""
        try:
            if not self.current_grid_params:
                logger.warning(f"{self.account_type}账户没有可用的网格参数")
                return
            
            self.target_orders = []
            current_price = self.current_grid_params.get('current_price', 0)
            target_levels = self.current_grid_params.get('target_levels', [])
            grid_amount = self.current_grid_params.get('grid_amount_data', {}).get('base_quantity', 0)
            
            if self.account_type == 'LONG':
                # 多头账户：在所有网格点位挂买单
                for level in target_levels:
                    if level.get('entry_price', 0) < current_price:  # 只在当前价格下方挂买单
                        order = {
                            'side': 'buy',
                            'price': level['entry_price'],
                            'quantity': grid_amount,
                            'position_side': 'LONG',
                            'type': 'limit',
                            'level_info': level
                        }
                        self.target_orders.append(order)
                        
            elif self.account_type == 'SHORT':
                # 空头账户：在所有网格点位挂卖单
                for level in target_levels:
                    if level.get('entry_price', 0) > current_price:  # 只在当前价格上方挂卖单
                        order = {
                            'side': 'sell',
                            'price': level['entry_price'],
                            'quantity': grid_amount,
                            'position_side': 'SHORT',
                            'type': 'limit',
                            'level_info': level
                        }
                        self.target_orders.append(order)
            
            logger.debug(f"{self.account_type}账户计算出{len(self.target_orders)}个目标订单")
            
        except Exception as e:
            logger.error(f"{self.account_type}账户计算目标订单失败: {e}")
    
    async def execute_grid_strategy(self):
        """执行网格策略"""
        async with self.execution_lock:
            try:
                if not self.execution_enabled:
                    logger.debug(f"{self.account_type}账户执行未启用")
                    return
                
                # 防止频繁执行
                current_time = time.time()
                if current_time - self.last_execution_time < 3:
                    return
                
                # 风险检查
                if not self.risk_controller.check_position_limits():
                    logger.warning(f"{self.account_type}账户风险检查失败，暂停执行")
                    return
                
                # 获取当前订单
                current_orders = self.order_manager.get_open_orders()
                
                # 同步订单
                await self._sync_orders(current_orders, self.target_orders)
                
                self.last_execution_time = current_time
                
            except Exception as e:
                logger.error(f"{self.account_type}账户执行网格策略失败: {e}")
    
    async def _sync_orders(self, current_orders: List[Dict], target_orders: List[Dict]):
        """同步当前订单与目标订单"""
        try:
            # 分析当前订单
            current_prices = {round(float(order.get('price', 0)), 6) 
                            for order in current_orders 
                            if self._is_relevant_order(order)}
            
            # 分析目标订单
            target_prices = {round(order['price'], 6) for order in target_orders}
            
            # 计算需要新增的订单
            new_prices = target_prices - current_prices
            if new_prices:
                logger.info(f"{self.account_type}账户需要新增{len(new_prices)}个订单")
                for target_order in target_orders:
                    if round(target_order['price'], 6) in new_prices:
                        await self._place_grid_order(target_order)
            
            # 计算需要取消的订单
            cancel_prices = current_prices - target_prices
            if cancel_prices:
                logger.info(f"{self.account_type}账户需要取消{len(cancel_prices)}个订单")
                for current_order in current_orders:
                    if (round(float(current_order.get('price', 0)), 6) in cancel_prices 
                        and self._is_relevant_order(current_order)):
                        await self._cancel_grid_order(current_order)
            
        except Exception as e:
            logger.error(f"{self.account_type}账户同步订单失败: {e}")
    
    def _is_relevant_order(self, order: Dict) -> bool:
        """判断订单是否与当前账户策略相关"""
        order_side = order.get('side', '').lower()
        position_side = order.get('info', {}).get('positionSide', '')
        
        if self.account_type == 'LONG':
            return order_side == 'buy' and position_side == 'LONG'
        elif self.account_type == 'SHORT':
            return order_side == 'sell' and position_side == 'SHORT'
        
        return False
    
    async def _place_grid_order(self, order_info: Dict):
        """下网格订单"""
        try:
            result = self.order_manager.place_order(
                side=order_info['side'],
                price=order_info['price'],
                quantity=order_info['quantity'],
                position_side=order_info['position_side'],
                order_type=order_info.get('type', 'limit')
            )
            
            if result:
                logger.info(f"{self.account_type}账户下单成功: {order_info['side']} "
                          f"{order_info['quantity']} @ {order_info['price']:.6f}")
            
        except Exception as e:
            logger.error(f"{self.account_type}账户下单失败: {e}")
    
    async def _cancel_grid_order(self, order_info: Dict):
        """取消网格订单"""
        try:
            order_id = order_info.get('id')
            if order_id:
                await self.order_manager.cancel_order(order_id)
                logger.info(f"{self.account_type}账户取消订单: {order_id}")
                
        except Exception as e:
            logger.error(f"{self.account_type}账户取消订单失败: {e}")
    
    def enable_execution(self):
        """启用执行"""
        self.execution_enabled = True
        logger.info(f"{self.account_type}账户网格执行已启用")
    
    def disable_execution(self):
        """禁用执行"""
        self.execution_enabled = False
        logger.info(f"{self.account_type}账户网格执行已禁用")
    
    async def cleanup_all_orders(self):
        """清理所有订单"""
        try:
            current_orders = self.order_manager.get_open_orders()
            relevant_orders = [order for order in current_orders if self._is_relevant_order(order)]
            
            for order in relevant_orders:
                await self._cancel_grid_order(order)
            
            logger.info(f"{self.account_type}账户订单清理完成")
            
        except Exception as e:
            logger.error(f"{self.account_type}账户清理订单失败: {e}")
```

### 4.2 止盈订单管理器

```python
class TakeProfitManager:
    """止盈订单管理器 - 处理网格止盈逻辑"""
    
    def __init__(self, account_type: str, order_manager: OrderManager):
        self.account_type = account_type.upper()
        self.order_manager = order_manager
        self.active_take_profits = {}  # 跟踪活跃的止盈单
    
    async def handle_order_fill(self, filled_order: Dict):
        """处理订单成交事件"""
        try:
            if not self._is_entry_order(filled_order):
                return
            
            # 为成交的入场单创建止盈单
            await self._create_take_profit_order(filled_order)
            
        except Exception as e:
            logger.error(f"{self.account_type}账户处理订单成交失败: {e}")
    
    def _is_entry_order(self, order: Dict) -> bool:
        """判断是否为入场订单"""
        side = order.get('side', '').lower()
        position_side = order.get('info', {}).get('positionSide', '')
        reduce_only = order.get('reduceOnly', False)
        
        # 入场单：非reduce_only，且方向匹配账户类型
        if reduce_only:
            return False
        
        if self.account_type == 'LONG':
            return side == 'buy' and position_side == 'LONG'
        elif self.account_type == 'SHORT':
            return side == 'sell' and position_side == 'SHORT'
        
        return False
    
    async def _create_take_profit_order(self, entry_order: Dict):
        """创建止盈订单"""
        try:
            entry_price = float(entry_order.get('price', 0))
            quantity = float(entry_order.get('filled', 0))
            
            if entry_price <= 0 or quantity <= 0:
                logger.warning(f"{self.account_type}账户入场订单信息不完整")
                return
            
            # 计算止盈价格（基于网格间距）
            grid_spacing = 0.005  # 默认0.5%，实际应从配置获取
            
            if self.account_type == 'LONG':
                # 多头止盈：卖出价格 = 入场价格 + 网格间距
                take_profit_price = entry_price * (1 + grid_spacing)
                side = 'sell'
                position_side = 'LONG'
            elif self.account_type == 'SHORT':
                # 空头止盈：买入价格 = 入场价格 - 网格间距  
                take_profit_price = entry_price * (1 - grid_spacing)
                side = 'buy'
                position_side = 'SHORT'
            else:
                return
            
            # 下止盈单
            result = self.order_manager.place_order(
                side=side,
                price=take_profit_price,
                quantity=quantity,
                position_side=position_side,
                is_reduce_only=True,
                order_type='limit'
            )
            
            if result:
                order_id = result.get('orderId')
                self.active_take_profits[order_id] = {
                    'entry_order_id': entry_order.get('id'),
                    'entry_price': entry_price,
                    'take_profit_price': take_profit_price,
                    'quantity': quantity,
                    'timestamp': time.time()
                }
                
                logger.info(f"{self.account_type}账户止盈单已创建: "
                          f"{side} {quantity} @ {take_profit_price:.6f} "
                          f"(入场价: {entry_price:.6f})")
            
        except Exception as e:
            logger.error(f"{self.account_type}账户创建止盈单失败: {e}")
    
    async def cleanup_expired_take_profits(self, max_age: int = 3600):
        """清理过期的止盈单"""
        try:
            current_time = time.time()
            expired_orders = []
            
            for order_id, tp_info in self.active_take_profits.items():
                if current_time - tp_info['timestamp'] > max_age:
                    expired_orders.append(order_id)
            
            for order_id in expired_orders:
                try:
                    await self.order_manager.cancel_order(order_id)
                    del self.active_take_profits[order_id]
                    logger.info(f"{self.account_type}账户清理过期止盈单: {order_id}")
                except:
                    pass
                    
        except Exception as e:
            logger.error(f"{self.account_type}账户清理过期止盈单失败: {e}")
```

## 5. 同步执行控制器

### 5.1 核心同步控制器

**文件位置**：`core/sync_controller.py`

```python
import asyncio
import signal
import time
from typing import Dict, Any, List, Optional
from core.dual_account_manager import DualAccountManager
from core.shared_grid_engine import SharedGridEngine, GridParameterDistributor
from core.hedge_grid_executor import HedgeGridExecutor
from utils.logger import logger

class SyncController:
    """同步执行控制器 - 统一控制双账户的启停和执行"""
    
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.config = config_manager.config
        
        # 核心组件
        self.dual_account_manager = DualAccountManager(config_manager)
        self.shared_grid_engine = None
        self.parameter_distributor = None
        self.executors = {}  # 存储双账户执行器
        
        # 控制状态
        self.is_running = False
        self.shutdown_event = asyncio.Event()
        self.tasks = []
        
        # 初始化标志
        self.initialization_complete = False
        
        logger.info("同步控制器初始化完成")
    
    async def initialize_system(self) -> bool:
        """初始化整个系统"""
        try:
            logger.info("开始初始化双账户对冲系统...")
            
            # 1. 检查账户连接
            connection_status = await self.dual_account_manager.check_connections()
            if not all(connection_status.values()):
                logger.error(f"账户连接检查失败: {connection_status}")
                return False
            
            # 2. 初始化共享网格引擎
            master_market_data = self.dual_account_manager.get_market_data_provider('LONG')
            self.shared_grid_engine = SharedGridEngine(master_market_data, self.config)
            
            # 3. 预热ATR
            atr_ready = await self.shared_grid_engine.warmup_atr()
            if not atr_ready:
                logger.error("ATR预热失败")
                return False
            
            # 4. 初始化参数分发器
            self.parameter_distributor = GridParameterDistributor(self.shared_grid_engine)
            
            # 5. 初始化双账户执行器
            await self._initialize_executors()
            
            # 6. 计算初始网格参数
            initial_params = await self.shared_grid_engine.calculate_shared_grid_parameters()
            if not initial_params:
                logger.error("初始网格参数计算失败")
                return False
            
            self.initialization_complete = True
            logger.info("双账户对冲系统初始化完成")
            return True
            
        except Exception as e:
            logger.error(f"系统初始化失败: {e}")
            return False
    
    async def _initialize_executors(self):
        """初始化双账户执行器"""
        for account_type in ['LONG', 'SHORT']:
            try:
                # 获取账户组件
                market_data_provider = self.dual_account_manager.get_market_data_provider(account_type)
                order_manager = self.dual_account_manager.get_order_manager(account_type)
                risk_controller = self.dual_account_manager.get_risk_controller(account_type)
                account_config = self.config_manager.get_account_config(account_type)
                
                # 创建执行器
                executor = HedgeGridExecutor(
                    account_type=account_type,
                    account_config=account_config,
                    market_data_provider=market_data_provider,
                    order_manager=order_manager,
                    risk_controller=risk_controller
                )
                
                self.executors[account_type] = executor
                
                # 注册参数订阅
                self.parameter_distributor.register_subscriber(
                    account_type, 
                    executor.update_grid_parameters
                )
                
                logger.info(f"{account_type}账户执行器初始化完成")
                
            except Exception as e:
                logger.error(f"初始化{account_type}账户执行器失败: {e}")
                raise
    
    async def start_dual_grid_strategy(self):
        """启动双账户对冲网格策略"""
        try:
            if not self.initialization_complete:
                logger.error("系统未初始化，无法启动策略")
                return False
            
            logger.info("启动双账户对冲网格策略...")
            
            # 1. 检查系统健康状态
            if not await self._pre_start_health_check():
                return False
            
            # 2. 启用执行器
            for executor in self.executors.values():
                executor.enable_execution()
            
            # 3. 创建并启动任务
            self.tasks = [
                asyncio.create_task(self._grid_parameter_update_loop()),
                asyncio.create_task(self._dual_account_execution_loop()),
                asyncio.create_task(self._websocket_management_loop()),
                asyncio.create_task(self._system_monitoring_loop()),
            ]
            
            self.is_running = True
            logger.info("双账户对冲网格策略已启动")
            
            # 4. 等待任务完成或退出信号
            shutdown_task = asyncio.create_task(self.shutdown_event.wait())
            all_tasks = self.tasks + [shutdown_task]
            
            done, pending = await asyncio.wait(
                all_tasks,
                return_when=asyncio.FIRST_COMPLETED
            )
            
            # 取消未完成的任务
            for task in pending:
                task.cancel()
                try:
                    await task
                except asyncio.CancelledError:
                    pass
            
            # 如果是退出信号，执行清理
            if self.shutdown_event.is_set():
                await self.stop_dual_grid_strategy()
            
            return True
            
        except Exception as e:
            logger.error(f"启动双账户策略失败: {e}")
            await self.stop_dual_grid_strategy()
            return False
    
    async def _pre_start_health_check(self) -> bool:
        """启动前健康检查"""
        try:
            # 检查账户连接
            connections = await self.dual_account_manager.check_connections()
            if not all(connections.values()):
                logger.error("部分账户连接异常")
                return False
            
            # 检查网格参数
            params = self.shared_grid_engine.get_shared_parameters()
            if not params:
                logger.error("网格参数未就绪")
                return False
            
            # 检查执行器状态
            if not all(self.executors.values()):
                logger.error("执行器未完全初始化")
                return False
            
            logger.info("启动前健康检查通过")
            return True
            
        except Exception as e:
            logger.error(f"启动前健康检查失败: {e}")
            return False
    
    async def _grid_parameter_update_loop(self):
        """网格参数更新循环"""
        while self.shutdown_event.is_set() == False:
            try:
                # 计算最新的网格参数
                updated_params = await self.shared_grid_engine.calculate_shared_grid_parameters()
                
                if updated_params and self.shared_grid_engine.is_parameters_updated():
                    # 分发参数给双账户
                    await self.parameter_distributor.distribute_parameters()
                    logger.debug("网格参数已更新并分发")
                
                # 等待下次更新（60秒间隔）
                await asyncio.sleep(60)
                
            except Exception as e:
                logger.error(f"网格参数更新循环异常: {e}")
                await asyncio.sleep(10)
    
    async def _dual_account_execution_loop(self):
        """双账户执行循环"""
        while self.shutdown_event.is_set() == False:
            try:
                # 并行执行双账户策略
                execution_tasks = []
                for executor in self.executors.values():
                    execution_tasks.append(
                        asyncio.create_task(executor.execute_grid_strategy())
                    )
                
                # 等待所有执行任务完成
                if execution_tasks:
                    await asyncio.gather(*execution_tasks, return_exceptions=True)
                
                # 执行间隔
                await asyncio.sleep(3)
                
            except Exception as e:
                logger.error(f"双账户执行循环异常: {e}")
                await asyncio.sleep(5)
    
    async def _websocket_management_loop(self):
        """WebSocket连接管理循环"""
        while self.shutdown_event.is_set() == False:
            try:
                # 检查并维护WebSocket连接
                for account_type in ['LONG', 'SHORT']:
                    market_data_provider = self.dual_account_manager.get_market_data_provider(account_type)
                    
                    # 确保WebSocket连接活跃
                    if not market_data_provider.is_websocket_connected():
                        logger.warning(f"{account_type}账户WebSocket连接断开，尝试重连")
                        await market_data_provider.connect_websocket()
                
                await asyncio.sleep(30)  # 30秒检查一次
                
            except Exception as e:
                logger.error(f"WebSocket管理循环异常: {e}")
                await asyncio.sleep(10)
    
    async def _system_monitoring_loop(self):
        """系统监控循环"""
        while self.shutdown_event.is_set() == False:
            try:
                # 执行系统监控
                await self._perform_system_monitoring()
                
                await asyncio.sleep(self.config.dual_account.MONITOR_INTERVAL)
                
            except Exception as e:
                logger.error(f"系统监控循环异常: {e}")
                await asyncio.sleep(30)
    
    async def _perform_system_monitoring(self):
        """执行系统监控"""
        try:
            # 监控账户健康状态
            for account_type in ['LONG', 'SHORT']:
                risk_controller = self.dual_account_manager.get_risk_controller(account_type)
                if not risk_controller.check_position_limits():
                    logger.warning(f"{account_type}账户风险检查失败")
            
            # 监控对冲比例
            await self._monitor_hedge_ratio()
            
        except Exception as e:
            logger.error(f"系统监控失败: {e}")
    
    async def _monitor_hedge_ratio(self):
        """监控对冲比例"""
        try:
            # 获取双账户持仓
            long_risk = self.dual_account_manager.get_risk_controller('LONG')
            short_risk = self.dual_account_manager.get_risk_controller('SHORT')
            
            long_pos, _ = long_risk.get_position()
            _, short_pos = short_risk.get_position()
            
            # 计算对冲比例
            if long_pos > 0 and short_pos > 0:
                hedge_ratio = min(long_pos, short_pos) / max(long_pos, short_pos)
                if hedge_ratio < (1 - self.config.dual_account.HEDGE_RATIO_TOLERANCE):
                    logger.warning(f"对冲比例失衡: {hedge_ratio:.2f}")
            
        except Exception as e:
            logger.error(f"监控对冲比例失败: {e}")
    
    async def stop_dual_grid_strategy(self):
        """停止双账户对冲网格策略"""
        try:
            logger.info("开始停止双账户对冲网格策略...")
            
            self.is_running = False
            self.shutdown_event.set()
            
            # 1. 禁用执行器
            for executor in self.executors.values():
                executor.disable_execution()
            
            # 2. 清理所有订单
            cleanup_tasks = []
            for executor in self.executors.values():
                cleanup_tasks.append(
                    asyncio.create_task(executor.cleanup_all_orders())
                )
            
            if cleanup_tasks:
                await asyncio.gather(*cleanup_tasks, return_exceptions=True)
            
            # 3. 取消所有任务
            for task in self.tasks:
                if not task.done():
                    task.cancel()
                    try:
                        await task
                    except asyncio.CancelledError:
                        pass
            
            logger.info("双账户对冲网格策略已停止")
            
        except Exception as e:
            logger.error(f"停止策略失败: {e}")
    
    def request_shutdown(self):
        """请求关闭（信号处理）"""
        logger.info("收到关闭请求")
        self.shutdown_event.set()
```

### 5.2 信号处理器

```python
class SignalHandler:
    """信号处理器 - 处理优雅退出"""
    
    def __init__(self, sync_controller: SyncController):
        self.sync_controller = sync_controller
        self._setup_signal_handlers()
    
    def _setup_signal_handlers(self):
        """设置信号处理器"""
        signal.signal(signal.SIGTERM, self._signal_handler)
        signal.signal(signal.SIGINT, self._signal_handler)
        if hasattr(signal, 'SIGHUP'):
            signal.signal(signal.SIGHUP, self._signal_handler)
    
    def _signal_handler(self, signum, frame):
        """信号处理函数"""
        logger.info(f"收到退出信号: {signum}")
        self.sync_controller.request_shutdown()
```

---
## 6. 统一监控模块

### 6.1 对冲监控器

**文件位置**：`core/hedge_monitor.py`

```python
import asyncio
import time
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
from core.dual_account_manager import DualAccountManager
from utils.logger import logger

class HedgeStatus(Enum):
    """对冲状态枚举"""
    BALANCED = "平衡"
    IMBALANCED = "失衡"
    CRITICAL = "严重失衡"
    ERROR = "错误"

@dataclass
class HedgeMetrics:
    """对冲指标数据类"""
    timestamp: float
    long_position: float
    short_position: float
    hedge_ratio: float
    position_imbalance: float
    total_pnl: float
    long_pnl: float
    short_pnl: float
    status: HedgeStatus
    
class HedgeMonitor:
    """对冲策略监控器 - 实时监控双账户对冲效果"""
    
    def __init__(self, dual_account_manager: DualAccountManager, config):
        self.dual_account_manager = dual_account_manager
        self.config = config
        
        # 监控状态
        self.is_monitoring = False
        self.current_metrics = None
        self.metrics_history = []
        self.max_history_size = 1000
        
        # 阈值配置
        self.hedge_ratio_warning = 0.8    # 对冲比例警告线
        self.hedge_ratio_critical = 0.6   # 对冲比例危险线
        self.imbalance_warning = 0.2      # 持仓失衡警告线
        self.imbalance_critical = 0.4     # 持仓失衡危险线
        
        # 监控任务
        self.monitor_task = None
        self.alert_handlers = []
        
        logger.info("对冲监控器初始化完成")
    
    async def start_monitoring(self, interval: int = 10):
        """启动监控"""
        try:
            if self.is_monitoring:
                logger.warning("监控已在运行中")
                return
            
            self.is_monitoring = True
            self.monitor_task = asyncio.create_task(
                self._monitoring_loop(interval)
            )
            
            logger.info(f"对冲监控已启动，监控间隔: {interval}秒")
            
        except Exception as e:
            logger.error(f"启动监控失败: {e}")
    
    async def stop_monitoring(self):
        """停止监控"""
        try:
            self.is_monitoring = False
            
            if self.monitor_task and not self.monitor_task.done():
                self.monitor_task.cancel()
                try:
                    await self.monitor_task
                except asyncio.CancelledError:
                    pass
            
            logger.info("对冲监控已停止")
            
        except Exception as e:
            logger.error(f"停止监控失败: {e}")
    
    async def _monitoring_loop(self, interval: int):
        """监控循环"""
        while self.is_monitoring:
            try:
                # 收集监控数据
                metrics = await self._collect_hedge_metrics()
                
                if metrics:
                    # 更新当前指标
                    self.current_metrics = metrics
                    
                    # 添加到历史记录
                    self._add_to_history(metrics)
                    
                    # 状态分析和告警
                    await self._analyze_and_alert(metrics)
                    
                    # 记录监控日志
                    self._log_metrics(metrics)
                
                await asyncio.sleep(interval)
                
            except Exception as e:
                logger.error(f"监控循环异常: {e}")
                await asyncio.sleep(5)
    
    async def _collect_hedge_metrics(self) -> Optional[HedgeMetrics]:
        """收集对冲指标"""
        try:
            # 获取双账户持仓
            long_risk = self.dual_account_manager.get_risk_controller('LONG')
            short_risk = self.dual_account_manager.get_risk_controller('SHORT')
            
            long_pos, _ = long_risk.get_position()
            _, short_pos = short_risk.get_position()
            
            # 计算对冲比例
            hedge_ratio = self._calculate_hedge_ratio(long_pos, short_pos)
            
            # 计算持仓失衡度
            position_imbalance = self._calculate_position_imbalance(long_pos, short_pos)
            
            # 获取PnL数据
            long_pnl = await self._get_account_pnl('LONG')
            short_pnl = await self._get_account_pnl('SHORT')
            total_pnl = long_pnl + short_pnl
            
            # 确定状态
            status = self._determine_hedge_status(hedge_ratio, position_imbalance)
            
            return HedgeMetrics(
                timestamp=time.time(),
                long_position=long_pos,
                short_position=short_pos,
                hedge_ratio=hedge_ratio,
                position_imbalance=position_imbalance,
                total_pnl=total_pnl,
                long_pnl=long_pnl,
                short_pnl=short_pnl,
                status=status
            )
            
        except Exception as e:
            logger.error(f"收集对冲指标失败: {e}")
            return None
    
    def _calculate_hedge_ratio(self, long_pos: float, short_pos: float) -> float:
        """计算对冲比例"""
        if long_pos == 0 and short_pos == 0:
            return 1.0  # 都没有持仓，视为完全对冲
        
        if long_pos == 0 or short_pos == 0:
            return 0.0  # 单边持仓，无对冲
        
        return min(long_pos, short_pos) / max(long_pos, short_pos)
    
    def _calculate_position_imbalance(self, long_pos: float, short_pos: float) -> float:
        """计算持仓失衡度"""
        total_pos = long_pos + short_pos
        if total_pos == 0:
            return 0.0
        
        return abs(long_pos - short_pos) / total_pos
    
    async def _get_account_pnl(self, account_type: str) -> float:
        """获取账户PnL"""
        try:
            account = self.dual_account_manager.get_account_instance(account_type)
            positions = account.fetch_positions([self.config.SYMBOL])
            
            total_pnl = 0.0
            for position in positions:
                if position['contracts'] != 0:
                    total_pnl += float(position.get('unrealizedPnl', 0))
            
            return total_pnl
            
        except Exception as e:
            logger.error(f"获取{account_type}账户PnL失败: {e}")
            return 0.0
    
    def _determine_hedge_status(self, hedge_ratio: float, position_imbalance: float) -> HedgeStatus:
        """确定对冲状态"""
        if hedge_ratio < self.hedge_ratio_critical or position_imbalance > self.imbalance_critical:
            return HedgeStatus.CRITICAL
        elif hedge_ratio < self.hedge_ratio_warning or position_imbalance > self.imbalance_warning:
            return HedgeStatus.IMBALANCED
        else:
            return HedgeStatus.BALANCED
    
    def _add_to_history(self, metrics: HedgeMetrics):
        """添加到历史记录"""
        self.metrics_history.append(metrics)
        
        # 限制历史记录大小
        if len(self.metrics_history) > self.max_history_size:
            self.metrics_history.pop(0)
    
    async def _analyze_and_alert(self, metrics: HedgeMetrics):
        """分析并发送告警"""
        alerts = []
        
        # 检查对冲比例
        if metrics.hedge_ratio < self.hedge_ratio_critical:
            alerts.append(f"严重警告: 对冲比例过低 {metrics.hedge_ratio:.2f}")
        elif metrics.hedge_ratio < self.hedge_ratio_warning:
            alerts.append(f"警告: 对冲比例偏低 {metrics.hedge_ratio:.2f}")
        
        # 检查持仓失衡
        if metrics.position_imbalance > self.imbalance_critical:
            alerts.append(f"严重警告: 持仓严重失衡 {metrics.position_imbalance:.2f}")
        elif metrics.position_imbalance > self.imbalance_warning:
            alerts.append(f"警告: 持仓失衡 {metrics.position_imbalance:.2f}")
        
        # 发送告警
        for alert in alerts:
            await self._send_alert(alert, metrics)
    
    async def _send_alert(self, message: str, metrics: HedgeMetrics):
        """发送告警"""
        logger.warning(f"对冲监控告警: {message}")
        
        # 调用注册的告警处理器
        for handler in self.alert_handlers:
            try:
                await handler(message, metrics)
            except Exception as e:
                logger.error(f"告警处理器异常: {e}")
    
    def _log_metrics(self, metrics: HedgeMetrics):
        """记录监控指标"""
        if self.config.dual_account.LOG_HEDGE_STATUS:
            logger.info(
                f"对冲监控 - 状态: {metrics.status.value}, "
                f"多头: {metrics.long_position:.2f}, "
                f"空头: {metrics.short_position:.2f}, "
                f"对冲比例: {metrics.hedge_ratio:.3f}, "
                f"失衡度: {metrics.position_imbalance:.3f}, "
                f"总PnL: {metrics.total_pnl:.2f}"
            )
    
    def register_alert_handler(self, handler):
        """注册告警处理器"""
        self.alert_handlers.append(handler)
        logger.info("告警处理器已注册")
    
    def get_current_metrics(self) -> Optional[HedgeMetrics]:
        """获取当前指标"""
        return self.current_metrics
    
    def get_metrics_history(self, limit: int = 100) -> List[HedgeMetrics]:
        """获取历史指标"""
        return self.metrics_history[-limit:] if self.metrics_history else []
    
    def generate_summary_report(self) -> Dict[str, Any]:
        """生成监控摘要报告"""
        if not self.current_metrics:
            return {"error": "没有可用的监控数据"}
        
        # 计算历史统计
        recent_metrics = self.get_metrics_history(100)
        
        avg_hedge_ratio = sum(m.hedge_ratio for m in recent_metrics) / len(recent_metrics) if recent_metrics else 0
        avg_imbalance = sum(m.position_imbalance for m in recent_metrics) / len(recent_metrics) if recent_metrics else 0
        
        return {
            "current_status": {
                "hedge_status": self.current_metrics.status.value,
                "hedge_ratio": self.current_metrics.hedge_ratio,
                "position_imbalance": self.current_metrics.position_imbalance,
                "total_pnl": self.current_metrics.total_pnl,
                "long_position": self.current_metrics.long_position,
                "short_position": self.current_metrics.short_position
            },
            "historical_averages": {
                "avg_hedge_ratio": avg_hedge_ratio,
                "avg_position_imbalance": avg_imbalance,
                "data_points": len(recent_metrics)
            },
            "monitoring_info": {
                "is_active": self.is_monitoring,
                "last_update": self.current_metrics.timestamp,
                "total_history_count": len(self.metrics_history)
            }
        }
```

### 6.2 性能监控器

```python
class PerformanceMonitor:
    """性能监控器 - 监控系统性能和延迟"""
    
    def __init__(self):
        self.execution_times = {}
        self.error_counts = {}
        self.success_counts = {}
        
    def record_execution_time(self, operation: str, execution_time: float):
        """记录执行时间"""
        if operation not in self.execution_times:
            self.execution_times[operation] = []
        
        self.execution_times[operation].append(execution_time)
        
        # 限制记录数量
        if len(self.execution_times[operation]) > 1000:
            self.execution_times[operation].pop(0)
    
    def record_success(self, operation: str):
        """记录成功操作"""
        self.success_counts[operation] = self.success_counts.get(operation, 0) + 1
    
    def record_error(self, operation: str):
        """记录错误操作"""
        self.error_counts[operation] = self.error_counts.get(operation, 0) + 1
    
    def get_performance_stats(self) -> Dict[str, Any]:
        """获取性能统计"""
        stats = {}
        
        for operation, times in self.execution_times.items():
            if times:
                stats[operation] = {
                    "avg_time": sum(times) / len(times),
                    "min_time": min(times),
                    "max_time": max(times),
                    "total_executions": len(times),
                    "success_count": self.success_counts.get(operation, 0),
                    "error_count": self.error_counts.get(operation, 0)
                }
        
        return stats

# 全局性能监控实例
performance_monitor = PerformanceMonitor()
```

### 6.3 监控装饰器

```python
import functools
import time

def monitor_performance(operation_name: str):
    """性能监控装饰器"""
    def decorator(func):
        @functools.wraps(func)
        async def async_wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = await func(*args, **kwargs)
                performance_monitor.record_success(operation_name)
                return result
            except Exception as e:
                performance_monitor.record_error(operation_name)
                raise
            finally:
                execution_time = time.time() - start_time
                performance_monitor.record_execution_time(operation_name, execution_time)
        
        @functools.wraps(func)
        def sync_wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = func(*args, **kwargs)
                performance_monitor.record_success(operation_name)
                return result
            except Exception as e:
                performance_monitor.record_error(operation_name)
                raise
            finally:
                execution_time = time.time() - start_time
                performance_monitor.record_execution_time(operation_name, execution_time)
        
        return async_wrapper if asyncio.iscoroutinefunction(func) else sync_wrapper
    return decorator
```

---
## 7. 启动脚本

### 7.1 主启动脚本

**文件位置**：`hedge_grid_strategy.py`

```python
#!/usr/bin/env python3
"""
双账户对冲网格策略主启动脚本
实现两个币安账户的市场中性对冲网格交易
"""

import asyncio
import sys
import os
from pathlib import Path

# 添加项目根目录到Python路径
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from config.dual_account_config import ConfigManager
from core.sync_controller import SyncController, SignalHandler
from core.hedge_monitor import HedgeMonitor
from utils.logger import logger

class HedgeGridTradingBot:
    """双账户对冲网格交易机器人主类"""
    
    def __init__(self):
        self.config_manager = None
        self.sync_controller = None
        self.hedge_monitor = None
        self.signal_handler = None
        
    async def initialize(self) -> bool:
        """初始化系统"""
        try:
            logger.info("=" * 60)
            logger.info("双账户对冲网格交易机器人启动中...")
            logger.info("=" * 60)
            
            # 1. 初始化配置管理器
            logger.info("1. 初始化配置管理器...")
            self.config_manager = ConfigManager(mode='hedge')
            
            if not self.config_manager.config.dual_account.validate_config():
                logger.error("配置验证失败，请检查环境变量")
                return False
            
            logger.info("✓ 配置管理器初始化完成")
            
            # 2. 初始化同步控制器
            logger.info("2. 初始化同步控制器...")
            self.sync_controller = SyncController(self.config_manager)
            
            if not await self.sync_controller.initialize_system():
                logger.error("同步控制器初始化失败")
                return False
            
            logger.info("✓ 同步控制器初始化完成")
            
            # 3. 初始化监控器
            logger.info("3. 初始化监控器...")
            self.hedge_monitor = HedgeMonitor(
                self.sync_controller.dual_account_manager,
                self.config_manager.config
            )
            
            # 注册告警处理器
            self.hedge_monitor.register_alert_handler(self._handle_alert)
            
            logger.info("✓ 监控器初始化完成")
            
            # 4. 设置信号处理器
            logger.info("4. 设置信号处理器...")
            self.signal_handler = SignalHandler(self.sync_controller)
            logger.info("✓ 信号处理器设置完成")
            
            logger.info("=" * 60)
            logger.info("系统初始化完成，准备启动策略...")
            logger.info("=" * 60)
            
            return True
            
        except Exception as e:
            logger.error(f"系统初始化失败: {e}")
            return False
    
    async def run(self):
        """运行主程序"""
        try:
            # 初始化系统
            if not await self.initialize():
                logger.error("初始化失败，程序退出")
                return False
            
            # 启动监控
            await self.hedge_monitor.start_monitoring(
                interval=self.config_manager.config.dual_account.MONITOR_INTERVAL
            )
            
            # 显示启动信息
            self._display_startup_info()
            
            # 启动策略
            success = await self.sync_controller.start_dual_grid_strategy()
            
            if not success:
                logger.error("策略启动失败")
                return False
            
            return True
            
        except KeyboardInterrupt:
            logger.info("收到键盘中断信号")
            return True
        except Exception as e:
            logger.error(f"运行异常: {e}")
            return False
        finally:
            await self.cleanup()
    
    async def cleanup(self):
        """清理资源"""
        try:
            logger.info("开始清理系统资源...")
            
            # 停止监控
            if self.hedge_monitor:
                await self.hedge_monitor.stop_monitoring()
            
            # 停止策略
            if self.sync_controller:
                await self.sync_controller.stop_dual_grid_strategy()
            
            logger.info("系统资源清理完成")
            
        except Exception as e:
            logger.error(f"清理资源失败: {e}")
    
    def _display_startup_info(self):
        """显示启动信息"""
        config = self.config_manager.config
        
        logger.info("\n" + "=" * 60)
        logger.info("双账户对冲网格策略配置信息")
        logger.info("=" * 60)
        logger.info(f"交易对: {getattr(config, 'SYMBOL', 'Unknown')}")
        logger.info(f"基础杠杆: {getattr(config, 'BASE_LEVERAGE', 'Unknown')}")
        logger.info(f"ATR周期: {getattr(config, 'ATR_PERIOD', 'Unknown')}")
        logger.info(f"ATR倍数: {getattr(config, 'ATR_MULTIPLIER', 'Unknown')}")
        logger.info(f"网格层数: {getattr(config, 'GRID_LEVELS', 'Unknown')}")
        logger.info(f"监控间隔: {config.dual_account.MONITOR_INTERVAL}秒")
        logger.info(f"多头账户: {config.dual_account.LONG_ACCOUNT_NAME}")
        logger.info(f"空头账户: {config.dual_account.SHORT_ACCOUNT_NAME}")
        logger.info("=" * 60)
        logger.info("策略已启动，开始执行对冲网格交易...")
        logger.info("按 Ctrl+C 优雅退出程序")
        logger.info("=" * 60 + "\n")
    
    async def _handle_alert(self, message: str, metrics):
        """处理监控告警"""
        logger.warning(f"🚨 监控告警: {message}")
        
        # 这里可以添加更多告警处理逻辑，如：
        # - 发送邮件通知
        # - 发送微信/钉钉消息
        # - 执行紧急止损
        # - 暂停策略执行等

async def main():
    """主函数"""
    bot = HedgeGridTradingBot()
    
    try:
        success = await bot.run()
        exit_code = 0 if success else 1
    except Exception as e:
        logger.error(f"程序异常退出: {e}")
        exit_code = 1
    
    sys.exit(exit_code)

if __name__ == "__main__":
    # 检查Python版本
    if sys.version_info < (3, 8):
        print("错误: 需要Python 3.8或更高版本")
        sys.exit(1)
    
    # 运行主程序
    asyncio.run(main())
```

### 7.2 Shell启动脚本

**文件位置**：`start_hedge_grid.sh`

```bash
#!/bin/bash

# 双账户对冲网格策略启动脚本

# 脚本配置
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PYTHON_SCRIPT="hedge_grid_strategy.py"
PID_FILE="$SCRIPT_DIR/hedge_grid.pid"
LOG_DIR="$SCRIPT_DIR/log"
LOG_FILE="$LOG_DIR/hedge_grid_startup.log"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 打印带颜色的消息
print_message() {
    local color=$1
    local message=$2
    echo -e "${color}$(date '+%Y-%m-%d %H:%M:%S') - ${message}${NC}"
}

# 检查环境
check_environment() {
    print_message $BLUE "检查运行环境..."
    
    # 检查Python版本
    if ! command -v python3 &> /dev/null; then
        print_message $RED "错误: 未找到python3"
        exit 1
    fi
    
    local python_version=$(python3 -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
    print_message $GREEN "Python版本: $python_version"
    
    # 检查必要文件
    if [ ! -f "$SCRIPT_DIR/$PYTHON_SCRIPT" ]; then
        print_message $RED "错误: 未找到主脚本 $PYTHON_SCRIPT"
        exit 1
    fi
    
    # 检查.env文件
    if [ ! -f "$SCRIPT_DIR/.env" ]; then
        print_message $RED "错误: 未找到配置文件 .env"
        exit 1
    fi
    
    # 创建日志目录
    mkdir -p "$LOG_DIR"
    
    print_message $GREEN "环境检查完成"
}

# 检查是否已在运行
check_if_running() {
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if ps -p $pid > /dev/null 2>&1; then
            print_message $YELLOW "警告: 对冲网格策略已在运行中 (PID: $pid)"
            echo "如需重启，请先运行: ./stop_hedge_grid.sh"
            exit 1
        else
            print_message $YELLOW "发现过期的PID文件，清理中..."
            rm -f "$PID_FILE"
        fi
    fi
}

# 安装依赖
install_dependencies() {
    print_message $BLUE "检查Python依赖..."
    
    if [ -f "$SCRIPT_DIR/requirements.txt" ]; then
        print_message $BLUE "安装依赖包..."
        python3 -m pip install -r "$SCRIPT_DIR/requirements.txt" >> "$LOG_FILE" 2>&1
        
        if [ $? -eq 0 ]; then
            print_message $GREEN "依赖安装完成"
        else
            print_message $RED "依赖安装失败，请检查日志"
            exit 1
        fi
    fi
}

# 启动策略
start_strategy() {
    print_message $BLUE "启动双账户对冲网格策略..."
    
    cd "$SCRIPT_DIR"
    
    # 后台启动策略
    nohup python3 "$PYTHON_SCRIPT" >> "$LOG_FILE" 2>&1 &
    local pid=$!
    
    # 保存PID
    echo $pid > "$PID_FILE"
    
    # 等待几秒钟检查启动状态
    sleep 3
    
    if ps -p $pid > /dev/null 2>&1; then
        print_message $GREEN "策略启动成功! (PID: $pid)"
        print_message $GREEN "日志文件: $LOG_FILE"
        print_message $GREEN "监控日志: tail -f $LOG_DIR/grid_trading.log"
        print_message $BLUE "停止策略: ./stop_hedge_grid.sh"
    else
        print_message $RED "策略启动失败，请检查日志"
        rm -f "$PID_FILE"
        exit 1
    fi
}

# 显示状态
show_status() {
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if ps -p $pid > /dev/null 2>&1; then
            print_message $GREEN "策略运行中 (PID: $pid)"
        else
            print_message $RED "策略已停止（PID文件过期）"
            rm -f "$PID_FILE"
        fi
    else
        print_message $YELLOW "策略未运行"
    fi
}

# 显示帮助
show_help() {
    echo "双账户对冲网格策略启动脚本"
    echo ""
    echo "用法: $0 [选项]"
    echo ""
    echo "选项:"
    echo "  start    启动策略（默认）"
    echo "  status   显示运行状态"
   
    echo "  help     显示此帮助信息"
    echo ""
    echo "环境要求:"
    echo "  - Python 3.8+"
    echo "  - 已配置 .env 文件"
    echo "  - 已安装依赖包"
    echo ""
}

# 主逻辑
main() {
    local action=${1:-start}
    
    case $action in
        "start")
            print_message $BLUE "=== 双账户对冲网格策略启动程序 ==="
            check_environment
            check_if_running
            install_dependencies
            start_strategy
            ;;
        "status")
            show_status
            ;;
        "help"|"-h"|"--help")
            show_help
            ;;
        *)
            print_message $RED "未知选项: $action"
            show_help
            exit 1
            ;;
    esac
}

# 执行主函数
main "$@"
```

### 7.3 停止脚本

**文件位置**：`stop_hedge_grid.sh`

```bash
#!/bin/bash

# 双账户对冲网格策略停止脚本

# 脚本配置
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PID_FILE="$SCRIPT_DIR/hedge_grid.pid"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# 打印带颜色的消息
print_message() {
    local color=$1
    local message=$2
    echo -e "${color}$(date '+%Y-%m-%d %H:%M:%S') - ${message}${NC}"
}

# 停止策略
stop_strategy() {
    if [ ! -f "$PID_FILE" ]; then
        print_message $YELLOW "策略未运行或PID文件不存在"
        return 0
    fi
    
    local pid=$(cat "$PID_FILE")
    
    if ! ps -p $pid > /dev/null 2>&1; then
        print_message $YELLOW "策略进程不存在（PID: $pid），清理PID文件"
        rm -f "$PID_FILE"
        return 0
    fi
    
    print_message $BLUE "正在停止双账户对冲网格策略 (PID: $pid)..."
    
    # 发送SIGTERM信号（优雅退出）
    kill -TERM $pid
    
    # 等待最多30秒让程序优雅退出
    local count=0
    while [ $count -lt 30 ]; do
        if ! ps -p $pid > /dev/null 2>&1; then
            print_message $GREEN "策略已优雅停止"
            rm -f "$PID_FILE"
            return 0
        fi
        sleep 1
        count=$((count + 1))
        if [ $((count % 5)) -eq 0 ]; then
            print_message $YELLOW "等待策略停止... ($count/30秒)"
        fi
    done
    
    # 如果优雅退出失败，强制终止
    print_message $YELLOW "优雅退出超时，强制终止进程..."
    kill -KILL $pid
    
    sleep 2
    if ! ps -p $pid > /dev/null 2>&1; then
        print_message $GREEN "策略已强制停止"
        rm -f "$PID_FILE"
        return 0
    else
        print_message $RED "无法停止策略进程"
        return 1
    fi
}

# 主函数
main() {
    print_message $BLUE "=== 双账户对冲网格策略停止程序 ==="
    stop_strategy
}

# 执行主函数
main "$@"
```

### 7.4 状态检查脚本

**文件位置**：`status_hedge_grid.sh`

```bash
#!/bin/bash

# 双账户对冲网格策略状态检查脚本

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PID_FILE="$SCRIPT_DIR/hedge_grid.pid"
LOG_FILE="$SCRIPT_DIR/log/grid_trading.log"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_message() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# 检查运行状态
check_status() {
    print_message $BLUE "=== 双账户对冲网格策略状态 ==="
    
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if ps -p $pid > /dev/null 2>&1; then
            print_message $GREEN "✓ 策略运行中 (PID: $pid)"
            
            # 显示进程信息
            local start_time=$(ps -o lstart= -p $pid | xargs)
            local cpu_usage=$(ps -o %cpu= -p $pid | xargs)
            local mem_usage=$(ps -o %mem= -p $pid | xargs)
            
            echo ""
            print_message $BLUE "进程信息:"
            echo "  PID: $pid"
            echo "  启动时间: $start_time"
            echo "  CPU使用率: ${cpu_usage}%"
            echo "  内存使用率: ${mem_usage}%"
            
            # 显示最近日志
            if [ -f "$LOG_FILE" ]; then
                echo ""
                print_message $BLUE "最近日志 (最后10行):"
                tail -n 10 "$LOG_FILE"
            fi
            
        else
            print_message $RED "✗ 策略已停止（PID文件过期）"
            rm -f "$PID_FILE"
        fi
    else
        print_message $YELLOW "✗ 策略未运行"
    fi
    
    echo ""
    print_message $BLUE "可用操作:"
    echo "  启动策略: ./start_hedge_grid.sh"
    echo "  停止策略: ./stop_hedge_grid.sh"
    echo "  查看日志: tail -f $LOG_FILE"
}
# 执行检查
check_status
```

---
## 8. 环境变量

### 8.1 .env配置文件

**文件位置**：`.env`

```bash
# ============================================
# 双账户对冲网格策略配置文件
# ============================================

# --------------------------------------------
# 多头账户配置（做多策略）
# --------------------------------------------
LONG_ACCOUNT_API_KEY=your_long_account_api_key_here
LONG_ACCOUNT_SECRET=your_long_account_secret_here
LONG_ACCOUNT_NAME=LongAccount

# --------------------------------------------
# 空头账户配置（做空策略）
# --------------------------------------------
SHORT_ACCOUNT_API_KEY=your_short_account_api_key_here
SHORT_ACCOUNT_SECRET=your_short_account_secret_here
SHORT_ACCOUNT_NAME=ShortAccount

# --------------------------------------------
# 基础交易配置（复用现有配置）
# --------------------------------------------
SYMBOL=DOGEUSDT
COIN_NAME=DOGE
CONTRACT_TYPE=USDT

# --------------------------------------------
# 网格策略配置
# --------------------------------------------
# 基础杠杆
BASE_LEVERAGE=10
# 最大杠杆限制
MAX_LEVERAGE_LIMIT=20
# 是否使用动态杠杆
USE_DYNAMIC_LEVERAGE=false

# 网格层数
GRID_LEVELS=5
# 最大网格层数
MAX_GRID_LEVELS=10

# 初始下单量
INITIAL_QUANTITY=100
# 是否使用动态数量
USE_DYNAMIC_QUANTITY=true

# 基础网格间距（百分比）
BASE_GRID_SPACING=0.5
GRID_SPACING=0.5

# --------------------------------------------
# ATR指标配置
# --------------------------------------------
# ATR周期
ATR_PERIOD=14
# ATR倍数
ATR_MULTIPLIER=2.0
# ATR时间框架
ATR_TIMEFRAME=1h
# 是否启用ATR固定模式
ATR_FIXED_MODE=true
# 是否使用ATR动态网格间距
USE_ATR_GRID_SPACING=true

# --------------------------------------------
# 动态计算配置
# --------------------------------------------
# 是否启用动态计算
ENABLE_DYNAMIC_CALCULATION=true
# 是否启用动态参数重计算
ENABLE_DYNAMIC_RECALCULATION=false

# --------------------------------------------
# 对冲策略特定配置
# --------------------------------------------
# 是否启用对冲模式
ENABLE_HEDGE_MODE=true
# 是否使用共享网格参数
SHARED_GRID_PARAMETERS=true
# 是否同步执行
SYNC_EXECUTION=true

# 对冲比例容忍度（0.05 = 5%）
HEDGE_RATIO_TOLERANCE=0.05
# 最大持仓不平衡比例（0.2 = 20%）
MAX_POSITION_IMBALANCE=0.2
# 紧急止损比例（0.1 = 10%）
EMERGENCY_STOP_LOSS=0.1

# --------------------------------------------
# 风险控制配置
# --------------------------------------------
# 持仓阈值
POSITION_THRESHOLD=500
# 持仓限制
POSITION_LIMIT=1000
# 最大开仓订单数
MAX_OPEN_ORDERS=20

# --------------------------------------------
# 时间控制配置
# --------------------------------------------
# 同步时间间隔（秒）
SYNC_TIME=10
# 首单间隔时间（秒）
ORDER_FIRST_TIME=30
# Ticker更新间隔（秒）
TICKER_UPDATE_INTERVAL=0.5
# 监控间隔（秒）
MONITOR_INTERVAL=10

# --------------------------------------------
# 日志配置
# --------------------------------------------
# 是否记录对冲状态
LOG_HEDGE_STATUS=true
# 日志级别 (DEBUG, INFO, WARNING, ERROR)
LOG_LEVEL=INFO

# --------------------------------------------
# WebSocket配置
# --------------------------------------------
# WebSocket URL
WEBSOCKET_URL=wss://fstream.binance.com/ws
# WebSocket重连间隔（秒）
WEBSOCKET_RECONNECT_INTERVAL=5
# WebSocket超时时间（秒）
WEBSOCKET_TIMEOUT=30

# --------------------------------------------
# 测试和调试配置
# --------------------------------------------
# 是否启用测试模式
TEST_MODE=false
# 是否启用调试模式
DEBUG_MODE=false
# 是否启用模拟交易
SIMULATION_MODE=false
```

### 8.2 环境变量说明文档

**文件位置**：`docs/environment_variables.md`

```markdown
# 环境变量配置说明

## 必需配置项

### 账户配置
- `LONG_ACCOUNT_API_KEY`: 多头账户API密钥
- `LONG_ACCOUNT_SECRET`: 多头账户API密钥
- `SHORT_ACCOUNT_API_KEY`: 空头账户API密钥  
- `SHORT_ACCOUNT_SECRET`: 空头账户API密钥

### 基础交易配置
- `SYMBOL`: 交易对符号，如DOGEUSDT
- `COIN_NAME`: 币种名称，如DOGE
- `CONTRACT_TYPE`: 合约类型，通常为USDT

## 可选配置项

### 网格策略参数
- `GRID_LEVELS`: 网格层数，建议5-10
- `BASE_GRID_SPACING`: 基础网格间距百分比
- `INITIAL_QUANTITY`: 初始下单量

### ATR指标参数
- `ATR_PERIOD`: ATR计算周期，建议14
- `ATR_MULTIPLIER`: ATR倍数，建议2.0
- `ATR_TIMEFRAME`: ATR时间框架，建议1h

### 对冲控制参数
- `HEDGE_RATIO_TOLERANCE`: 对冲比例容忍度
- `MAX_POSITION_IMBALANCE`: 最大持仓不平衡比例

## 配置验证

启动前请确保：
1. 所有必需的API密钥已正确配置
2. 账户具有期货交易权限
3. 账户已启用双向持仓模式
4. 账户有足够的余额进行交易
```

---

## 9. 其他必需模块

### 9.1 错误处理和重试机制

**文件位置**：`core/error_handler.py`

```python
import asyncio
import functools
from typing import Callable, Any, Optional
from utils.logger import logger

class RetryableError(Exception):
    """可重试的错误"""
    pass

class FatalError(Exception):
    """致命错误（不可重试）"""
    pass

def retry_on_failure(max_retries: int = 3, 
                    delay: float = 1.0, 
                    backoff_factor: float = 2.0,
                    exceptions: tuple = (Exception,)):
    """重试装饰器"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        async def async_wrapper(*args, **kwargs) -> Any:
            last_exception = None
            current_delay = delay
            
            for attempt in range(max_retries + 1):
                try:
                    return await func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e
                    
                    if isinstance(e, FatalError):
                        logger.error(f"致命错误，停止重试: {e}")
                        raise
                    
                    if attempt < max_retries:
                        logger.warning(f"第{attempt + 1}次尝试失败: {e}, {current_delay}秒后重试")
                        await asyncio.sleep(current_delay)
                        current_delay *= backoff_factor
                    else:
                        logger.error(f"重试{max_retries}次后仍失败: {e}")
                        
            raise last_exception
        
        @functools.wraps(func)
        def sync_wrapper(*args, **kwargs) -> Any:
            last_exception = None
            current_delay = delay
            
            for attempt in range(max_retries + 1):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e
                    
                    if isinstance(e, FatalError):
                        logger.error(f"致命错误，停止重试: {e}")
                        raise
                    
                    if attempt < max_retries:
                        logger.warning(f"第{attempt + 1}次尝试失败: {e}, {current_delay}秒后重试")
                        time.sleep(current_delay)
                        current_delay *= backoff_factor
                    else:
                        logger.error(f"重试{max_retries}次后仍失败: {e}")
                        
            raise last_exception
        
        return async_wrapper if asyncio.iscoroutinefunction(func) else sync_wrapper
    return decorator
```

### 9.2 数据持久化模块

**文件位置**：`core/data_persistence.py`

```python
import json
import os
import time
from typing import Dict, Any, Optional
from pathlib import Path
from utils.logger import logger

class DataPersistence:
    """数据持久化管理器"""
    
    def __init__(self, data_dir: str = "data"):
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(exist_ok=True)
        
    def save_grid_parameters(self, params: Dict[str, Any], account_type: str = "shared"):
        """保存网格参数"""
        try:
            filename = f"grid_params_{account_type}_{int(time.time())}.json"
            filepath = self.data_dir / filename
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(params, f, indent=2, default=str)
            
            logger.debug(f"网格参数已保存: {filepath}")
            
        except Exception as e:
            logger.error(f"保存网格参数失败: {e}")
    
    def load_latest_grid_parameters(self, account_type: str = "shared") -> Optional[Dict[str, Any]]:
        """加载最新的网格参数"""
        try:
            pattern = f"grid_params_{account_type}_*.json"
            files = list(self.data_dir.glob(pattern))
            
            if not files:
                return None
            
            # 按时间戳排序，获取最新的
            latest_file = max(files, key=lambda x: x.stat().st_mtime)
            
            with open(latest_file, 'r', encoding='utf-8') as f:
                return json.load(f)
                
        except Exception as e:
            logger.error(f"加载网格参数失败: {e}")
            return None
    
    def save_monitoring_data(self, metrics: Dict[str, Any]):
        """保存监控数据"""
        try:
            date_str = time.strftime("%Y%m%d")
            filename = f"monitoring_{date_str}.jsonl"
            filepath = self.data_dir / filename
            
            with open(filepath, 'a', encoding='utf-8') as f:
                json.dump(metrics, f, default=str)
                f.write('\n')
                
        except Exception as e:
            logger.error(f"保存监控数据失败: {e}")
```

### 9.3 安全检查模块

**文件位置**：`core/security_checker.py`

```python
import os
import hashlib
from typing import Dict, List, Tuple
from utils.logger import logger

class SecurityChecker:
    """安全检查器"""
    
    @staticmethod
    def validate_api_credentials(api_key: str, secret: str) -> bool:
        """验证API凭据格式"""
        if not api_key or not secret:
            return False
        
        # 币安API密钥通常是64字符的十六进制字符串
        if len(api_key) != 64 or not all(c in '0123456789ABCDEFabcdef' for c in api_key):
            logger.warning("API密钥格式可能不正确")
            return False
        
        # 币安API密钥通常是64字符
        if len(secret) != 64:
            logger.warning("API密钥格式可能不正确")
            return False
        
        return True
    
    @staticmethod
    def check_environment_security() -> List[str]:
        """检查环境安全性"""
        warnings = []
        
        # 检查.env文件权限
        env_file = ".env"
        if os.path.exists(env_file):
            stat = os.stat(env_file)
            if stat.st_mode & 0o077:  # 检查其他用户是否有读写权限
                warnings.append(".env文件权限过于宽松，建议设置为600")
        
        # 检查是否在生产环境中启用了调试模式
        if os.getenv('DEBUG_MODE', '').lower() == 'true':
            warnings.append("生产环境中不应启用调试模式")
        
        return warnings
    
    @staticmethod
    def mask_sensitive_data(data: str) -> str:
        """掩码敏感数据"""
        if len(data) <= 8:
            return "*" * len(data)
        return data[:4] + "*" * (len(data) - 8) + data[-4:]
```

---

## 10. 部署和运维指南

### 10.1 系统要求

- **操作系统**: Linux (Ubuntu 20.04+ 推荐)
- **Python版本**: 3.8+
- **内存**: 最低2GB，推荐4GB+
- **存储**: 最低10GB可用空间
- **网络**: 稳定的网络连接，低延迟到币安服务器

### 10.2 部署步骤

1. **克隆代码库**
```bash
git clone <repository_url>
cd GirdBot
```

2. **安装依赖**
```bash
pip install -r requirements.txt
```

3. **配置环境变量**
```bash
cp .env.example .env
# 编辑.env文件，填入正确的API密钥和配置
```

4. **设置文件权限**
```bash
chmod 600 .env
chmod +x *.sh
```

5. **启动策略**
```bash
./start_hedge_grid.sh
```

### 10.3 监控和维护

- **日志监控**: `tail -f log/grid_trading.log`
- **状态检查**: `./status_hedge_grid.sh`
- **停止策略**: `./stop_hedge_grid.sh`
- **重启策略**: `./stop_hedge_grid.sh && ./start_hedge_grid.sh`

### 10.4 故障排除

1. **连接失败**: 检查API密钥和网络连接
2. **权限错误**: 确认账户已启用期货交易和双向持仓
3. **余额不足**: 确保双账户都有足够的USDT余额
4. **参数错误**: 检查.env文件中的配置参数

---

## 结语

本技术栈文档详细说明了双账户对冲网格策略的完整实现方案。该方案基于现有的单账户ATR网格系统进行扩展，通过模块化设计实现了：

1. **风险对冲**: 双账户多空对冲，降低单向市场风险
2. **参数共享**: 统一计算网格参数，确保策略一致性  
3. **同步执行**: 协调双账户的启停和执行过程
4. **实时监控**: 全面监控对冲效果和系统状态
5. **优雅退出**: 支持信号处理和资源清理

该技术栈具有良好的可扩展性和稳定性，适用于专业的量化交易场景。
