# 双账户对冲网格策略技术栈

## 概述

双账户对冲网格策略是基于现有单账户ATR网格系统的扩展，通过两个独立的币安账户实现市场中性的对冲交易。一个账户专门执行多头网格策略，另一个账户专门执行空头网格策略，共享相同的网格参数计算，实现风险对冲和波动套利。

---

## 项目架构图

```
双账户对冲网格策略（融合执行器架构）
├─ 配置管理层
│  ├─ config/dual_account_config.py    # 双账户配置管理
│  ├─ config/grid_executor_config.py   # 执行器配置管理
│  └─ .env                             # 环境变量配置
├─ 账户管理层
│  └─ core/dual_account_manager.py     # 双账户连接和管理
├─ 网格计算层（共享）
│  ├─ core/atr_calculator.py           # ATR指标计算（复用）
│  ├─ core/grid_calculator.py          # 网格参数计算（复用）
│  └─ core/shared_grid_engine.py       # 共享网格参数引擎
├─ 网格参数分发层
│  └─ core/grid_parameter_distributor.py # 网格参数分发器（增强版）
├─ 执行器架构层（新架构）
│  ├─ core/hedge_grid_executor.py      # 基础执行器（抽象基类）
│  ├─ core/long_account_executor.py    # 多头执行器
│  ├─ core/short_account_executor.py   # 空头执行器
│  ├─ core/executor_factory.py         # 执行器工厂
│  └─ core/sync_controller_v2.py       # 升级版同步控制器
├─ 策略层
│  └─ hedge_grid_strategy.py           # 对冲网格策略主脚本
├─ 监控管理层
│  ├─ core/hedge_monitor.py            # 统一监控模块
│  └─ core/risk_hedge_controller.py    # 对冲风险控制
└─ 启动脚本层
   ├─ start_hedge_grid.sh              # 启动脚本
   └─ stop_hedge_grid.sh               # 停止脚本
```

---

## 1. 配置管理

### 1.1 双账户配置结构

**文件位置**：`config/dual_account_config.py`

```python
import os
from dataclasses import dataclass
from typing import Optional

@dataclass
class DualAccountConfig:
    """双账户对冲策略配置"""
    
    # 多头账户配置
    LONG_ACCOUNT_API_KEY: str = os.getenv('LONG_ACCOUNT_API_KEY')
    LONG_ACCOUNT_SECRET: str = os.getenv('LONG_ACCOUNT_SECRET')
    LONG_ACCOUNT_NAME: str = os.getenv('LONG_ACCOUNT_NAME', 'LongAccount')
    
    # 空头账户配置
    SHORT_ACCOUNT_API_KEY: str = os.getenv('SHORT_ACCOUNT_API_KEY')
    SHORT_ACCOUNT_SECRET: str = os.getenv('SHORT_ACCOUNT_SECRET')
    SHORT_ACCOUNT_NAME: str = os.getenv('SHORT_ACCOUNT_NAME', 'ShortAccount')
    
    # 对冲策略配置
    ENABLE_HEDGE_MODE: bool = True
    SHARED_GRID_PARAMETERS: bool = True
    SYNC_EXECUTION: bool = True
    HEDGE_RATIO_TOLERANCE: float = 0.05  # 对冲比例容忍度
    
    # 风险控制配置
    MAX_POSITION_IMBALANCE: float = 0.2  # 最大持仓不平衡比例
    EMERGENCY_STOP_LOSS: float = 0.1     # 紧急止损比例
    
    # 监控配置
    MONITOR_INTERVAL: int = 10           # 监控间隔（秒）
    LOG_HEDGE_STATUS: bool = True        # 记录对冲状态
    
    def validate_config(self) -> bool:
        """验证配置完整性"""
        required_fields = [
            self.LONG_ACCOUNT_API_KEY,
            self.LONG_ACCOUNT_SECRET,
            self.SHORT_ACCOUNT_API_KEY,
            self.SHORT_ACCOUNT_SECRET
        ]
        return all(field for field in required_fields)
```

### 1.2 配置继承与扩展

**基于现有配置的扩展**：

```python
from config.settings import config as base_config

class HedgeGridConfig(base_config.__class__):
    """继承原有配置并扩展对冲功能"""
    
    def __init__(self):
        super().__init__()
        self.dual_account = DualAccountConfig()
        
        # 验证双账户配置
        if not self.dual_account.validate_config():
            raise ValueError("双账户配置不完整，请检查环境变量")
    
    @property
    def is_hedge_mode_enabled(self) -> bool:
        """检查是否启用对冲模式"""
        return self.dual_account.ENABLE_HEDGE_MODE
```

### 1.3 配置管理器

```python
class ConfigManager:
    """配置管理器 - 统一管理单账户和双账户配置"""
    
    def __init__(self, mode: str = 'hedge'):
        self.mode = mode
        if mode == 'hedge':
            self.config = HedgeGridConfig()
        else:
            self.config = base_config
    
    def get_account_config(self, account_type: str) -> dict:
        """获取指定账户的配置"""
        if account_type.upper() == 'LONG':
            return {
                'api_key': self.config.dual_account.LONG_ACCOUNT_API_KEY,
                'secret': self.config.dual_account.LONG_ACCOUNT_SECRET,
                'name': self.config.dual_account.LONG_ACCOUNT_NAME
            }
        elif account_type.upper() == 'SHORT':
            return {
                'api_key': self.config.dual_account.SHORT_ACCOUNT_API_KEY,
                'secret': self.config.dual_account.SHORT_ACCOUNT_SECRET,
                'name': self.config.dual_account.SHORT_ACCOUNT_NAME
            }
        else:
            raise ValueError(f"不支持的账户类型: {account_type}")
```

---

## 2. 双账户管理

### 2.1 双账户管理器核心架构

**文件位置**：`core/dual_account_manager.py`

```python
import asyncio
from typing import Dict, Any, Optional, Tuple
from core.market_data import MarketDataProvider
from core.order_manager import OrderManager
from core.risk_controller import RiskController
from utils.logger import logger

class DualAccountManager:
    """双账户管理器 - 统一管理多空两个账户的连接和操作"""
    
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.accounts = {}
        self.market_data_providers = {}
        self.order_managers = {}
        self.risk_controllers = {}
        self.connection_status = {}
        
        # 初始化双账户
        self._initialize_accounts()
    
    def _initialize_accounts(self):
        """初始化双账户连接"""
        account_types = ['LONG', 'SHORT']
        
        for account_type in account_types:
            try:
                # 获取账户配置
                account_config = self.config_manager.get_account_config(account_type)
                
                # 创建账户实例
                self.accounts[account_type] = self._create_account_connection(
                    account_config['api_key'],
                    account_config['secret'],
                    account_config['name']
                )
                
                # 创建各模块实例
                self.market_data_providers[account_type] = MarketDataProvider()
                self.market_data_providers[account_type].set_account_connection(
                    self.accounts[account_type]
                )
                
                self.order_managers[account_type] = OrderManager(
                    self.market_data_providers[account_type]
                )
                
                self.risk_controllers[account_type] = RiskController(
                    self.market_data_providers[account_type],
                    self.order_managers[account_type]
                )
                
                self.connection_status[account_type] = True
                logger.info(f"{account_type}账户初始化成功")
                
            except Exception as e:
                logger.error(f"{account_type}账户初始化失败: {e}")
                self.connection_status[account_type] = False
                raise
    
    def _create_account_connection(self, api_key: str, secret: str, name: str):
        """创建账户连接"""
        from grid_binance_v3_atr import CustomGate
        
        exchange = CustomGate({
            "apiKey": api_key,
            "secret": secret,
            "options": {
                "defaultType": "future",
            },
        })
        exchange.load_markets(reload=False)
        return exchange
    
    async def check_connections(self) -> Dict[str, bool]:
        """检查所有账户连接状态"""
        connection_results = {}
        
        for account_type in ['LONG', 'SHORT']:
            try:
                # 测试连接
                balance = self.accounts[account_type].fetch_balance()
                connection_results[account_type] = True
                logger.debug(f"{account_type}账户连接正常")
            except Exception as e:
                connection_results[account_type] = False
                logger.error(f"{account_type}账户连接失败: {e}")
        
        return connection_results
    
    def get_account_instance(self, account_type: str):
        """获取指定账户的交易所实例"""
        return self.accounts.get(account_type.upper())
    
    def get_market_data_provider(self, account_type: str):
        """获取指定账户的行情提供器"""
        return self.market_data_providers.get(account_type.upper())
    
    def get_order_manager(self, account_type: str):
        """获取指定账户的订单管理器"""
        return self.order_managers.get(account_type.upper())
    
    def get_risk_controller(self, account_type: str):
        """获取指定账户的风险控制器"""
        return self.risk_controllers.get(account_type.upper())
```

### 2.2 账户状态同步器

```python
class AccountStateSynchronizer:
    """账户状态同步器 - 确保双账户状态一致性"""
    
    def __init__(self, dual_account_manager):
        self.dual_account_manager = dual_account_manager
        self.sync_lock = asyncio.Lock()
        self.last_sync_time = {}
        
    async def sync_account_states(self):
        """同步双账户状态"""
        async with self.sync_lock:
            try:
                # 同步持仓状态
                await self._sync_positions()
                
                # 同步订单状态
                await self._sync_orders()
                
                # 同步余额状态
                await self._sync_balances()
                
                logger.debug("账户状态同步完成")
                
            except Exception as e:
                logger.error(f"账户状态同步失败: {e}")
    
    async def _sync_positions(self):
        """同步持仓状态"""
        for account_type in ['LONG', 'SHORT']:
            try:
                risk_controller = self.dual_account_manager.get_risk_controller(account_type)
                long_pos, short_pos = risk_controller.get_position()
                
                # 记录持仓状态
                self.last_sync_time[f"{account_type}_position"] = time.time()
                logger.debug(f"{account_type}账户持仓: 多头={long_pos}, 空头={short_pos}")
                
            except Exception as e:
                logger.error(f"同步{account_type}账户持仓失败: {e}")
    
    async def _sync_orders(self):
        """同步订单状态"""
        for account_type in ['LONG', 'SHORT']:
            try:
                order_manager = self.dual_account_manager.get_order_manager(account_type)
                open_orders = order_manager.get_open_orders()
                
                logger.debug(f"{account_type}账户未成交订单数: {len(open_orders)}")
                
            except Exception as e:
                logger.error(f"同步{account_type}账户订单失败: {e}")
    
    async def _sync_balances(self):
        """同步余额状态"""
        for account_type in ['LONG', 'SHORT']:
            try:
                account = self.dual_account_manager.get_account_instance(account_type)
                balance = account.fetch_balance()
                
                logger.debug(f"{account_type}账户余额同步完成")
                
            except Exception as e:
                logger.error(f"同步{account_type}账户余额失败: {e}")
```

### 2.3 账户健康检查器

```python
class AccountHealthChecker:
    """账户健康检查器"""
    
    def __init__(self, dual_account_manager):
        self.dual_account_manager = dual_account_manager
        self.health_status = {}
    
    async def perform_health_check(self) -> Dict[str, Dict[str, Any]]:
        """执行健康检查"""
        health_results = {}
        
        for account_type in ['LONG', 'SHORT']:
            health_results[account_type] = await self._check_account_health(account_type)
        
        return health_results
    
    async def _check_account_health(self, account_type: str) -> Dict[str, Any]:
        """检查单个账户健康状态"""
        health_info = {
            'connection': False,
            'balance_sufficient': False,
            'position_reasonable': False,
            'orders_normal': False,
            'errors': []
        }
        
        try:
            # 检查连接
            account = self.dual_account_manager.get_account_instance(account_type)
            balance = account.fetch_balance()
            health_info['connection'] = True
            
            # 检查余额
            usdt_balance = balance.get('USDT', {}).get('free', 0)
            health_info['balance_sufficient'] = usdt_balance > 100  # 至少100 USDT
            
            # 检查持仓
            risk_controller = self.dual_account_manager.get_risk_controller(account_type)
            long_pos, short_pos = risk_controller.get_position()
            total_position = abs(long_pos) + abs(short_pos)
            health_info['position_reasonable'] = total_position < 10000  # 持仓不超过10000
            
            # 检查订单
            order_manager = self.dual_account_manager.get_order_manager(account_type)
            open_orders = order_manager.get_open_orders()
            health_info['orders_normal'] = len(open_orders) < 50  # 挂单不超过50个
            
        except Exception as e:
            health_info['errors'].append(str(e))
            logger.error(f"{account_type}账户健康检查失败: {e}")
        
        return health_info
```

---

## 3. 网格指标计算模块（共享）

### 3.1 共享网格参数引擎

**文件位置**：`core/shared_grid_engine.py`

```python
import asyncio
import time
from typing import Dict, Any, Optional, Tuple
from core.atr_calculator import ATRCalculator
from core.grid_calculator import GridCalculator
from core.market_data import MarketDataProvider
from utils.logger import logger

class SharedGridEngine:
    """共享网格参数引擎 - 为双账户提供统一的网格参数计算"""
    
    def __init__(self, market_data_provider: MarketDataProvider, config):
        self.market_data_provider = market_data_provider
        self.config = config
        
        # 初始化计算器（复用现有模块）
        self.atr_calculator = ATRCalculator(
            market_data_provider=market_data_provider,
            period=getattr(config, 'ATR_PERIOD', 14),
            multiplier=getattr(config, 'ATR_MULTIPLIER', 2.0),
            fixed_mode=getattr(config, 'ATR_FIXED_MODE', True)
        )
        
        self.grid_calculator = GridCalculator(market_data_provider)
        
        # 网格参数缓存
        self.shared_grid_params = {}
        self.last_calculation_time = 0
        self.calculation_lock = asyncio.Lock()
        
        # 参数更新标志
        self.params_updated = False
        
    async def calculate_shared_grid_parameters(self) -> Dict[str, Any]:
        """计算共享的网格参数 - 核心方法"""
        async with self.calculation_lock:
            try:
                current_time = time.time()
                
                # 防止频繁计算（至少间隔10秒）
                if current_time - self.last_calculation_time < 10:
                    logger.debug("网格参数计算间隔过短，返回缓存参数")
                    return self.shared_grid_params
                
                logger.info("开始计算共享网格参数...")
                
                # 1. 获取当前价格
                current_price = self.market_data_provider.get_current_price()
                if current_price <= 0:
                    raise ValueError(f"无效的当前价格: {current_price}")
                
                # 2. 计算ATR及通道（网格区间）
                atr_data = await self._calculate_atr_channel(current_price)
                
                # 3. 计算网格层数
                grid_levels_data = await self._calculate_grid_levels(current_price, atr_data)
                
                # 4. 计算网格间距
                grid_spacing = await self._calculate_grid_spacing(current_price, atr_data)
                
                # 5. 计算最大杠杆
                max_leverage = self._calculate_max_leverage()
                
                # 6. 计算单个网格金额
                grid_amount_data = await self._calculate_grid_amount(current_price)
                
                # 7. 组装共享参数
                self.shared_grid_params = {
                    'timestamp': current_time,
                    'current_price': current_price,
                    'atr_data': atr_data,
                    'grid_levels': grid_levels_data,
                    'grid_spacing': grid_spacing,
                    'max_leverage': max_leverage,
                    'grid_amount_data': grid_amount_data,
                    'calculation_summary': {
                        'total_long_levels': len(grid_levels_data.get('long_levels', [])),
                        'total_short_levels': len(grid_levels_data.get('short_levels', [])),
                        'grid_spacing_percent': (grid_spacing / current_price) * 100,
                        'atr_value': atr_data.get('atr_value', 0),
                        'upper_band': atr_data.get('upper_band', 0),
                        'lower_band': atr_data.get('lower_band', 0)
                    }
                }
                
                self.last_calculation_time = current_time
                self.params_updated = True
                
                logger.info("共享网格参数计算完成")
                logger.info(f"参数摘要: {self.shared_grid_params['calculation_summary']}")
                
                return self.shared_grid_params
                
            except Exception as e:
                logger.error(f"计算共享网格参数失败: {e}")
                raise
    
    async def _calculate_atr_channel(self, current_price: float) -> Dict[str, Any]:
        """计算ATR通道（网格区间）"""
        try:
            # 获取ATR值
            atr_value = self.atr_calculator.get_atr()
            if atr_value <= 0:
                raise ValueError("ATR值无效")
            
            # 计算ATR通道上下轨
            upper_band, lower_band = self.atr_calculator.get_atr_channel(current_price)
            
            return {
                'atr_value': atr_value,
                'upper_band': upper_band,
                'lower_band': lower_band,
                'channel_width': upper_band - lower_band,
                'channel_width_percent': ((upper_band - lower_band) / current_price) * 100
            }
            
        except Exception as e:
            logger.error(f"计算ATR通道失败: {e}")
            raise
    
    async def _calculate_grid_levels(self, current_price: float, atr_data: Dict) -> Dict[str, Any]:
        """计算网格层数"""
        try:
            # 使用现有的网格计算器
            grid_data = await self.grid_calculator.calculate_enhanced_grid_levels(
                current_price=current_price,
                atr_value=atr_data['atr_value'],
                account_balance=1000,  # 使用默认值，实际会在各账户中重新计算
                leverage=self.config.BASE_LEVERAGE
            )
            
            return grid_data.get('grid_levels', {})
            
        except Exception as e:
            logger.error(f"计算网格层数失败: {e}")
            raise
    
    async def _calculate_grid_spacing(self, current_price: float, atr_data: Dict) -> float:
        """计算网格间距"""
        try:
            # 使用ATR动态间距
            if getattr(self.config, 'USE_ATR_GRID_SPACING', True):
                num_levels = getattr(self.config, 'GRID_LEVELS', 5)
                spacing = self.atr_calculator.calculate_dynamic_grid_spacing(
                    current_price, num_levels
                )
            else:
                # 使用固定间距
                spacing = getattr(self.config, 'GRID_SPACING', 0.005) * current_price
            
            return spacing
            
        except Exception as e:
            logger.error(f"计算网格间距失败: {e}")
            raise
    
    def _calculate_max_leverage(self) -> int:
        """计算最大杠杆"""
        try:
            base_leverage = getattr(self.config, 'BASE_LEVERAGE', 10)
            max_leverage_limit = getattr(self.config, 'MAX_LEVERAGE_LIMIT', 20)
            
            # 简单逻辑：使用基础杠杆，不超过上限
            return min(base_leverage, max_leverage_limit)
            
        except Exception as e:
            logger.error(f"计算最大杠杆失败: {e}")
            return 10  # 默认杠杆
    
    async def _calculate_grid_amount(self, current_price: float) -> Dict[str, Any]:
        """计算单个网格金额"""
        try:
            # 使用现有的网格计算器计算position sizes
            position_data = await self.grid_calculator.calculate_position_sizes(
                current_price=current_price,
                account_balance=1000,  # 默认值，各账户会重新计算
                leverage=self.config.BASE_LEVERAGE,
                atr_value=self.atr_calculator.get_atr()
            )
            
            return position_data
            
        except Exception as e:
            logger.error(f"计算网格金额失败: {e}")
            raise
    
    def get_shared_parameters(self) -> Optional[Dict[str, Any]]:
        """获取共享参数（无需重新计算）"""
        return self.shared_grid_params if self.shared_grid_params else None
    
    def is_parameters_updated(self) -> bool:
        """检查参数是否已更新"""
        return self.params_updated
    
    def mark_parameters_consumed(self):
        """标记参数已被消费"""
        self.params_updated = False
    
    async def warmup_atr(self):
        """预热ATR计算器"""
        try:
            logger.info("正在预热共享ATR计算器...")
            
            # 获取历史K线数据
            klines = await self.market_data_provider.get_klines(
                symbol=self.config.SYMBOL,
                interval=getattr(self.config, 'ATR_TIMEFRAME', '1h'),
                limit=getattr(self.config, 'ATR_PERIOD', 14) * 2
            )
            
            if not klines:
                logger.warning("无法获取历史K线数据")
                return False
            
            # 添加历史数据到ATR计算器
            for kline in klines:
                high = float(kline[2])
                low = float(kline[3])
                close = float(kline[4])
                self.atr_calculator.add_price_data(high, low, close)
            
            atr_value = self.atr_calculator.get_atr()
            if atr_value > 0:
                logger.info(f"共享ATR预热完成，ATR值: {atr_value:.6f}")
                return True
            else:
                logger.warning("ATR预热失败")
                return False
                
        except Exception as e:
            logger.error(f"预热ATR计算器失败: {e}")
            return False
```

### 3.2 网格参数分发器（增强版）

**文件位置**：`core/grid_parameter_distributor.py`

```python
class GridParameterDistributor:
    """网格参数分发器 - 将共享参数分发给执行器"""
    
    def __init__(self, shared_grid_engine: SharedGridEngine):
        self.shared_grid_engine = shared_grid_engine
        self.executor_subscribers = {}  # 执行器订阅者
        self.legacy_subscribers = {}    # 兼容旧系统的订阅者
        
    def register_executor_subscriber(self, account_type: str, executor_callback):
        """注册执行器订阅者（新架构）"""
        self.executor_subscribers[account_type] = executor_callback
        logger.info(f"{account_type}执行器已注册为网格参数订阅者")
    
    def register_subscriber(self, account_type: str, callback):
        """注册参数订阅者（兼容旧系统）"""
        self.legacy_subscribers[account_type] = callback
        logger.info(f"{account_type}账户已注册为网格参数订阅者")
    
    def get_grid_levels_for_executor(self, account_type: str, max_levels: int = None) -> List:
        """为执行器获取适配的网格层级"""
        shared_params = self.shared_grid_engine.get_shared_parameters()
        if not shared_params:
            return []
        
        all_levels = shared_params.get('grid_levels', {})
        
        if account_type.upper() == 'LONG':
            target_levels = all_levels.get('long_levels', [])
        elif account_type.upper() == 'SHORT':
            target_levels = all_levels.get('short_levels', [])
        else:
            # 单账户模式，使用所有层级
            target_levels = all_levels.get('all_levels', [])
        
        # 如果指定了最大层级数，进行筛选
        if max_levels and len(target_levels) > max_levels:
            current_price = shared_params.get('current_price', 0)
            if current_price > 0:
                # 按距离当前价格排序，选择最近的层级
                target_levels.sort(key=lambda x: abs(x.get('price', 0) - current_price))
                target_levels = target_levels[:max_levels]
        
        return target_levels
    
    async def distribute_parameters(self):
        """分发参数给所有订阅者"""
        try:
            # 获取最新的共享参数
            shared_params = self.shared_grid_engine.get_shared_parameters()
            
            if not shared_params:
                logger.warning("没有可用的共享网格参数")
                return
            
            # 分发给执行器订阅者（新架构）
            await self._distribute_to_executors(shared_params)
            
            # 分发给传统订阅者（兼容旧系统）
            await self._distribute_to_legacy_subscribers(shared_params)
            
            # 标记参数已消费
            self.shared_grid_engine.mark_parameters_consumed()
            
        except Exception as e:
            logger.error(f"分发网格参数失败: {e}")
    
    async def _distribute_to_executors(self, shared_params: Dict):
        """分发给执行器订阅者"""
        for account_type, executor_callback in self.executor_subscribers.items():
            try:
                # 为执行器定制参数
                executor_params = self._prepare_executor_parameters(shared_params, account_type)
                
                # 调用执行器回调
                await executor_callback(executor_params)
                logger.debug(f"参数已分发给{account_type}执行器")
                
            except Exception as e:
                logger.error(f"分发参数给{account_type}执行器失败: {e}")
    
    async def _distribute_to_legacy_subscribers(self, shared_params: Dict):
        """分发给传统订阅者（兼容性）"""
        for account_type, callback in self.legacy_subscribers.items():
            try:
                # 为不同账户类型定制参数
                customized_params = self._customize_parameters_for_account(
                    shared_params, account_type
                )
                
                # 调用回调函数
                await callback(customized_params)
                logger.debug(f"参数已分发给{account_type}账户")
                
            except Exception as e:
                logger.error(f"分发参数给{account_type}账户失败: {e}")
    
    def _prepare_executor_parameters(self, shared_params: Dict, account_type: str) -> Dict:
        """为执行器准备参数"""
        executor_params = {
            'timestamp': shared_params.get('timestamp'),
            'current_price': shared_params.get('current_price'),
            'atr_data': shared_params.get('atr_data'),
            'grid_spacing': shared_params.get('grid_spacing'),
            'max_leverage': shared_params.get('max_leverage'),
            'grid_amount_data': shared_params.get('grid_amount_data'),
            'target_levels': self.get_grid_levels_for_executor(account_type),
            'strategy_direction': account_type.upper(),
            'calculation_summary': shared_params.get('calculation_summary', {})
        }
        
        return executor_params
    
    def _customize_parameters_for_account(self, shared_params: Dict, account_type: str) -> Dict:
        """为特定账户类型定制参数（兼容旧系统）"""
        customized = shared_params.copy()
        
        # 根据账户类型调整策略方向
        if account_type.upper() == 'LONG':
            # 多头账户只关注long_levels
            customized['target_levels'] = shared_params['grid_levels'].get('long_levels', [])
            customized['strategy_direction'] = 'LONG'
        elif account_type.upper() == 'SHORT':
            # 空头账户只关注short_levels  
            customized['target_levels'] = shared_params['grid_levels'].get('short_levels', [])
            customized['strategy_direction'] = 'SHORT'
        
        return customized
```

---
## 4. 执行器架构层（全新设计）

### 4.1 基础执行器（抽象基类）

**文件位置**：`core/hedge_grid_executor.py`

```python
from abc import ABC, abstractmethod
import asyncio
import time
from enum import Enum
from typing import Dict, Any, List, Optional, Tuple
from decimal import Decimal
from dataclasses import dataclass
from utils.logger import logger

class RunnableStatus(Enum):
    """执行器运行状态"""
    NOT_STARTED = "NOT_STARTED"
    STARTING = "STARTING"
    RUNNING = "RUNNING"
    SHUTTING_DOWN = "SHUTTING_DOWN"
    TERMINATED = "TERMINATED"

class GridLevelStates(Enum):
    """网格级别状态"""
    NOT_ACTIVE = "NOT_ACTIVE"                 # 未激活
    OPEN_ORDER_PLACED = "OPEN_ORDER_PLACED"   # 开仓单已下
    OPEN_ORDER_FILLED = "OPEN_ORDER_FILLED"   # 开仓单已成交  
    CLOSE_ORDER_PLACED = "CLOSE_ORDER_PLACED" # 平仓单已下
    COMPLETE = "COMPLETE"                     # 完成一轮交易
    FAILED = "FAILED"                         # 失败状态

@dataclass
class GridLevel:
    """网格级别数据结构"""
    price: Decimal
    amount_quote: Decimal
    state: GridLevelStates = GridLevelStates.NOT_ACTIVE
    active_open_order: Optional[Any] = None
    active_close_order: Optional[Any] = None
    last_update_time: float = 0.0

@dataclass  
class TrackedOrder:
    """订单跟踪数据结构"""
    order_id: str
    executed_amount_base: Decimal = Decimal("0")
    price: Decimal = Decimal("0")

class HedgeGridExecutor(ABC):
    """
    对冲网格基础执行器 - 纯抽象状态机驱动
    完全与交易方向解耦的通用网格执行引擎
    """
    
    def __init__(self, account_type: str, config: 'GridExecutorConfig'):
        """
        参数：
        - account_type: 'SINGLE' | 'DUAL'  
        - config: 网格配置参数
        """
        self.account_type = account_type
        self.config = config
        
        # 状态管理
        self.grid_levels: List[GridLevel] = []
        self.levels_by_state: Dict[GridLevelStates, List[GridLevel]] = {}
        
        # 执行状态
        self.status = RunnableStatus.NOT_STARTED
        self.execution_enabled = True
        
        # 挂单控制参数（借鉴Hummingbot）
        self.max_open_orders = config.max_open_orders
        self.max_orders_per_batch = config.max_orders_per_batch
        self.activation_bounds = config.activation_bounds
        self.upper_lower_ratio = config.upper_lower_ratio
        self.order_frequency = config.order_frequency
        
        # 执行控制
        self.max_open_creation_timestamp = 0
        self.shared_grid_engine = None  # 由外部注入
        
        # 初始化状态字典
        self._initialize_state_dict()
    
    def _initialize_state_dict(self):
        """初始化状态字典"""
        for state in GridLevelStates:
            self.levels_by_state[state] = []
    
    @abstractmethod
    async def _place_open_order(self, level: GridLevel) -> Optional[TrackedOrder]:
        """
        抽象方法：下开仓单
        子类必须实现具体的开仓逻辑（买入或卖出）
        """
        pass
    
    @abstractmethod
    async def _place_close_order(self, level: GridLevel) -> Optional[TrackedOrder]:
        """
        抽象方法：下平仓单
        子类必须实现具体的平仓逻辑（卖出或买入）
        """
        pass
    
    @abstractmethod
    def _should_place_order_at_level(self, level: GridLevel, current_price: Decimal) -> bool:
        """
        抽象方法：判断是否在该点位挂单
        子类实现具体的挂单策略逻辑
        """
        pass
    
    async def start(self):
        """启动执行器"""
        if self.status != RunnableStatus.NOT_STARTED:
            logger.warning(f"{self.account_type}执行器已启动或正在启动")
            return
            
        self.status = RunnableStatus.STARTING
        logger.info(f"启动{self.account_type}执行器")
        
        try:
            await self.initialize()
            self.status = RunnableStatus.RUNNING
            await self.control_task()
        except Exception as e:
            logger.error(f"{self.account_type}执行器启动失败: {e}")
            self.status = RunnableStatus.TERMINATED
            raise
    
    async def stop(self):
        """停止执行器"""
        if self.status == RunnableStatus.RUNNING:
            self.status = RunnableStatus.SHUTTING_DOWN
            logger.info(f"停止{self.account_type}执行器")
    
    async def control_task(self):
        """主控制循环 - 状态机驱动"""
        while self.status in [RunnableStatus.RUNNING, RunnableStatus.SHUTTING_DOWN]:
            try:
                self.update_grid_levels()
                self.update_metrics()
                
                if self.status == RunnableStatus.RUNNING:
                    # 计算需要创建的订单
                    open_orders_to_create = self.get_open_orders_to_create()
                    close_orders_to_create = self.get_close_orders_to_create()
                    
                    # 计算需要取消的订单
                    open_order_ids_to_cancel = self.get_open_order_ids_to_cancel()
                    close_order_ids_to_cancel = self.get_close_order_ids_to_cancel()
                    
                    # 执行订单操作
                    await self.execute_order_operations(
                        open_orders_to_create, 
                        close_orders_to_create,
                        open_order_ids_to_cancel,
                        close_order_ids_to_cancel
                    )
                
                elif self.status == RunnableStatus.SHUTTING_DOWN:
                    await self.control_shutdown_process()
                    break
                
                await asyncio.sleep(1)
                
            except Exception as e:
                logger.error(f"{self.account_type}执行器控制循环异常: {e}")
                await asyncio.sleep(5)
        
        self.status = RunnableStatus.TERMINATED
        logger.info(f"{self.account_type}执行器已终止")
    
    def get_open_orders_to_create(self) -> List[GridLevel]:
        """
        通用开仓单创建逻辑 - 基于上下方分布
        """
        # 检查频率限制
        if (self.max_open_creation_timestamp > 
            self._get_current_timestamp() - self.order_frequency):
            return []
        
        # 检查最大挂单数限制
        n_open_orders = len(self.levels_by_state[GridLevelStates.OPEN_ORDER_PLACED])
        if n_open_orders >= self.max_open_orders:
            return []
        
        current_price = self.get_mid_price()
        target_levels = self.shared_grid_engine.get_grid_levels_for_account(self.account_type)
        
        # 计算可创建的订单数量
        remaining_slots = min(
            self.max_open_orders - n_open_orders,
            self.max_orders_per_batch
        )
        
        if remaining_slots <= 0:
            return []
        
        # 分配上下方挂单数量
        upper_count, lower_count = self._calculate_upper_lower_distribution(remaining_slots)
        
        # 分别获取上方和下方的订单
        upper_orders = self._get_upper_orders(target_levels, current_price, upper_count)
        lower_orders = self._get_lower_orders(target_levels, current_price, lower_count)
        
        orders_to_create = []
        orders_to_create.extend(upper_orders)
        orders_to_create.extend(lower_orders)
        
        return orders_to_create
    
    def _calculate_upper_lower_distribution(self, total_orders: int) -> Tuple[int, int]:
        """
        计算上下方挂单分布
        
        Args:
            total_orders: 总挂单数量
        
        Returns:
            (upper_count, lower_count): 上方和下方挂单数量
        """
        if total_orders <= 0:
            return 0, 0
        
        # 根据配置的上下方比例分配
        # upper_lower_ratio = 0.5 表示上下方各50%
        # upper_lower_ratio = 0.3 表示上方30%，下方70%
        upper_count = int(total_orders * self.upper_lower_ratio)
        lower_count = total_orders - upper_count
        
        return upper_count, lower_count
    
    def _get_upper_orders(self, target_levels: List[GridLevel], 
                         current_price: Decimal, count: int) -> List[GridLevel]:
        """获取上方订单（价格 > 当前价格）"""
        upper_levels = [level for level in target_levels 
                       if level.price > current_price 
                       and self._should_place_order_at_level(level, current_price)]
        
        # 按距离当前价格从近到远排序
        upper_levels.sort(key=lambda x: x.price - current_price)
        return upper_levels[:count]
    
    def _get_lower_orders(self, target_levels: List[GridLevel], 
                         current_price: Decimal, count: int) -> List[GridLevel]:
        """获取下方订单（价格 < 当前价格）"""
        lower_levels = [level for level in target_levels 
                       if level.price < current_price 
                       and self._should_place_order_at_level(level, current_price)]
        
        # 按距离当前价格从近到远排序
        lower_levels.sort(key=lambda x: current_price - x.price)
        return lower_levels[:count]
    
    def get_close_orders_to_create(self) -> List[GridLevel]:
        """获取需要创建的平仓单"""
        return [level for level in self.levels_by_state[GridLevelStates.OPEN_ORDER_FILLED]
                if level.state == GridLevelStates.OPEN_ORDER_FILLED]
    
    def get_open_order_ids_to_cancel(self) -> List[str]:
        """获取需要取消的开仓单ID"""
        # 实现订单取消逻辑
        return []
    
    def get_close_order_ids_to_cancel(self) -> List[str]:
        """获取需要取消的平仓单ID"""
        # 实现订单取消逻辑
        return []
    
    async def execute_order_operations(self, open_orders: List[GridLevel],
                                     close_orders: List[GridLevel],
                                     cancel_open_ids: List[str],
                                     cancel_close_ids: List[str]):
        """执行订单操作"""
        try:
            # 取消订单
            for order_id in cancel_open_ids + cancel_close_ids:
                await self.cancel_order(order_id)
            
            # 创建开仓单
            for level in open_orders:
                tracked_order = await self._place_open_order(level)
                if tracked_order:
                    level.active_open_order = tracked_order
                    level.state = GridLevelStates.OPEN_ORDER_PLACED
                    self._update_level_state(level)
            
            # 创建平仓单
            for level in close_orders:
                tracked_order = await self._place_close_order(level)
                if tracked_order:
                    level.active_close_order = tracked_order
                    level.state = GridLevelStates.CLOSE_ORDER_PLACED
                    self._update_level_state(level)
            
            # 更新时间戳
            if open_orders:
                self.max_open_creation_timestamp = self._get_current_timestamp()
                
        except Exception as e:
            logger.error(f"{self.account_type}执行订单操作失败: {e}")
    
    async def control_shutdown_process(self):
        """控制关闭流程"""
        try:
            # 取消所有挂单
            await self.cancel_all_orders()
            
            # 清理资源
            await self.cleanup()
            
        except Exception as e:
            logger.error(f"{self.account_type}关闭流程异常: {e}")
    
    def update_grid_levels(self):
        """更新网格级别状态"""
        # 重新组织状态字典
        self._initialize_state_dict()
        for level in self.grid_levels:
            self.levels_by_state[level.state].append(level)
    
    def update_metrics(self):
        """更新性能指标"""
        # 实现性能指标更新逻辑
        pass
    
    def _update_level_state(self, level: GridLevel):
        """更新级别状态"""
        level.last_update_time = self._get_current_timestamp()
    
    def get_mid_price(self) -> Decimal:
        """获取当前中间价"""
        # 从市场数据获取当前价格
        return Decimal("0")  # placeholder
    
    def _get_current_timestamp(self) -> float:
        """获取当前时间戳"""
        return time.time()
    
    async def cancel_order(self, order_id: str):
        """取消订单"""
        # 实现订单取消逻辑
        pass
    
    async def cancel_all_orders(self):
        """取消所有订单"""
        # 实现取消所有订单逻辑
        pass
    
    async def initialize(self):
        """初始化执行器"""
        logger.info(f"{self.account_type}执行器初始化完成")
    
    async def cleanup(self):
        """清理资源"""
        logger.info(f"{self.account_type}执行器清理完成")
    
    def get_status(self) -> Dict[str, Any]:
        """获取执行器状态"""
        return {
            'account_type': self.account_type,
            'status': self.status.value,
            'execution_enabled': self.execution_enabled,
            'grid_levels_count': len(self.grid_levels),
            'active_open_orders': len(self.levels_by_state[GridLevelStates.OPEN_ORDER_PLACED]),
            'active_close_orders': len(self.levels_by_state[GridLevelStates.CLOSE_ORDER_PLACED])
        }
```

### 4.2 多头执行器（特化实现）

**文件位置**：`core/long_account_executor.py`

```python
from typing import Optional
from decimal import Decimal
from core.hedge_grid_executor import HedgeGridExecutor, GridLevel, TrackedOrder
from utils.logger import logger

class LongAccountExecutor(HedgeGridExecutor):
    """
    多头账户执行器 - 专注做多策略
    实现抽象方法，定义具体的买入开仓、卖出平仓逻辑
    """
    
    def __init__(self, config: 'GridExecutorConfig'):
        account_type = 'SINGLE' if config.is_single_mode else 'DUAL'
        super().__init__(account_type, config)
    
    async def _place_open_order(self, level: GridLevel) -> Optional[TrackedOrder]:
        """
        多头开仓：下买单
        """
        try:
            order_candidate = self._create_buy_order_candidate(level)
            self.adjust_order_candidates(self.config.connector_name, [order_candidate])
            
            if order_candidate.amount > 0:
                order_id = self.place_order(
                    connector_name=self.config.connector_name,
                    trading_pair=self.config.trading_pair,
                    order_type=self.config.open_order_type,
                    amount=order_candidate.amount,
                    price=order_candidate.price,
                    side='BUY',  # 多头开仓：买入
                    position_action='OPEN',
                )
                logger.info(f"多头执行器下买单: {order_id}, 价格: {order_candidate.price}")
                return TrackedOrder(order_id=order_id)
        except Exception as e:
            logger.error(f"多头执行器下买单失败: {e}")
        return None
    
    async def _place_close_order(self, level: GridLevel) -> Optional[TrackedOrder]:
        """
        多头平仓：下卖单止盈
        """
        try:
            entry_price = level.active_open_order.price
            quantity = level.active_open_order.executed_amount_base
            
            # 计算止盈价格
            take_profit_price = entry_price * (1 + self.config.grid_spacing_pct)
            
            order_candidate = self._create_sell_order_candidate(level, take_profit_price, quantity)
            self.adjust_order_candidates(self.config.connector_name, [order_candidate])
            
            if order_candidate.amount > 0:
                order_id = self.place_order(
                    connector_name=self.config.connector_name,
                    trading_pair=self.config.trading_pair,
                    order_type=self.config.close_order_type,
                    amount=order_candidate.amount,
                    price=order_candidate.price,
                    side='SELL',  # 多头平仓：卖出
                    position_action='CLOSE',
                )
                logger.info(f"多头执行器下卖单止盈: {order_id}, 价格: {order_candidate.price}")
                return TrackedOrder(order_id=order_id)
        except Exception as e:
            logger.error(f"多头执行器下卖单止盈失败: {e}")
        return None
    
    def _should_place_order_at_level(self, level: GridLevel, current_price: Decimal) -> bool:
        """
        多头挂单策略：上下方都可以挂买单
        - 下方买单：等待价格下跌后买入（主要策略）
        - 上方买单：等待价格回调后买入（辅助策略）
        """
        # 检查激活范围
        if self.activation_bounds:
            distance_pct = abs(level.price - current_price) / current_price
            if distance_pct > self.activation_bounds:
                return False
        
        # 多头策略：上下方都可以挂买单
        return True
    
    def _create_buy_order_candidate(self, level: GridLevel):
        """创建买单候选"""
        entry_price = level.price
        
        # 如果网格价格不利于开仓，使用市场价格加安全边距
        current_price = self.get_mid_price()
        if entry_price >= current_price:
            entry_price = current_price * (1 - self.config.safe_extra_spread)
        
        # 创建订单候选对象（简化实现）
        return {
            'trading_pair': self.config.trading_pair,
            'order_type': self.config.open_order_type,
            'order_side': 'BUY',
            'amount': level.amount_quote / current_price,
            'price': entry_price
        }
    
    def _create_sell_order_candidate(self, level: GridLevel, price: Decimal, amount: Decimal):
        """创建卖单候选"""
        return {
            'trading_pair': self.config.trading_pair,
            'order_type': self.config.close_order_type,
            'order_side': 'SELL',
            'amount': amount,
            'price': price
        }
```

### 4.3 空头执行器（特化实现）

**文件位置**：`core/short_account_executor.py`

```python
from typing import Optional
from decimal import Decimal
from core.hedge_grid_executor import HedgeGridExecutor, GridLevel, TrackedOrder
from utils.logger import logger

class ShortAccountExecutor(HedgeGridExecutor):
    """
    空头账户执行器 - 专注做空策略
    实现抽象方法，定义具体的卖出开仓、买入平仓逻辑
    """
    
    def __init__(self, config: 'GridExecutorConfig'):
        super().__init__('DUAL', config)
    
    async def _place_open_order(self, level: GridLevel) -> Optional[TrackedOrder]:
        """
        空头开仓：下卖单
        """
        try:
            order_candidate = self._create_sell_order_candidate(level)
            self.adjust_order_candidates(self.config.connector_name, [order_candidate])
            
            if order_candidate.amount > 0:
                order_id = self.place_order(
                    connector_name=self.config.connector_name,
                    trading_pair=self.config.trading_pair,
                    order_type=self.config.open_order_type,
                    amount=order_candidate.amount,
                    price=order_candidate.price,
                    side='SELL',  # 空头开仓：卖出
                    position_action='OPEN',
                )
                logger.info(f"空头执行器下卖单: {order_id}, 价格: {order_candidate.price}")
                return TrackedOrder(order_id=order_id)
        except Exception as e:
            logger.error(f"空头执行器下卖单失败: {e}")
        return None
    
    async def _place_close_order(self, level: GridLevel) -> Optional[TrackedOrder]:
        """
        空头平仓：下买单止盈
        """
        try:
            entry_price = level.active_open_order.price
            quantity = level.active_open_order.executed_amount_base
            
            # 计算止盈价格
            take_profit_price = entry_price * (1 - self.config.grid_spacing_pct)
            
            order_candidate = self._create_buy_order_candidate(level, take_profit_price, quantity)
            self.adjust_order_candidates(self.config.connector_name, [order_candidate])
            
            if order_candidate.amount > 0:
                order_id = self.place_order(
                    connector_name=self.config.connector_name,
                    trading_pair=self.config.trading_pair,
                    order_type=self.config.close_order_type,
                    amount=order_candidate.amount,
                    price=order_candidate.price,
                    side='BUY',  # 空头平仓：买入
                    position_action='CLOSE',
                )
                logger.info(f"空头执行器下买单止盈: {order_id}, 价格: {order_candidate.price}")
                return TrackedOrder(order_id=order_id)
        except Exception as e:
            logger.error(f"空头执行器下买单止盈失败: {e}")
        return None
    
    def _should_place_order_at_level(self, level: GridLevel, current_price: Decimal) -> bool:
        """
        空头挂单策略：上下方都可以挂卖单
        - 上方卖单：等待价格上涨后卖出（主要策略）
        - 下方卖单：等待价格反弹后卖出（辅助策略）
        """
        # 检查激活范围
        if self.activation_bounds:
            distance_pct = abs(level.price - current_price) / current_price
            if distance_pct > self.activation_bounds:
                return False
        
        # 空头策略：上下方都可以挂卖单
        return True
    
    def _create_sell_order_candidate(self, level: GridLevel):
        """创建卖单候选"""
        entry_price = level.price
        
        # 如果网格价格不利于开仓，使用市场价格加安全边距
        current_price = self.get_mid_price()
        if entry_price <= current_price:
            entry_price = current_price * (1 + self.config.safe_extra_spread)
        
        return {
            'trading_pair': self.config.trading_pair,
            'order_type': self.config.open_order_type,
            'order_side': 'SELL',
            'amount': level.amount_quote / current_price,
            'price': entry_price
        }
    
    def _create_buy_order_candidate(self, level: GridLevel, price: Decimal, amount: Decimal):
        """创建买单候选（用于平仓）"""
        return {
            'trading_pair': self.config.trading_pair,
            'order_type': self.config.close_order_type,
            'order_side': 'BUY',
            'amount': amount,
            'price': price
        }
```

### 4.4 执行器工厂

**文件位置**：`core/executor_factory.py`

```python
import copy
from typing import List, Tuple, Optional, Dict
from decimal import Decimal
from dataclasses import dataclass
from core.long_account_executor import LongAccountExecutor
from core.short_account_executor import ShortAccountExecutor

@dataclass
class GridExecutorConfig:
    """
    网格执行器配置参数（借鉴Hummingbot设计）
    """
    # 基础参数
    connector_name: str                    # 交易所连接器名称
    trading_pair: str                      # 交易对
    account_mode: str                      # 'SINGLE' | 'DUAL'
    
    # 网格参数（从SharedGridEngine获取）
    start_price: Decimal                   # 网格起始价格
    end_price: Decimal                     # 网格结束价格
    grid_spacing_pct: Decimal              # 网格间距百分比
    total_amount_quote: Decimal            # 总资金量
    
    # 挂单控制参数（参考Hummingbot）
    max_open_orders: int = 4               # 最大同时挂单数
    max_orders_per_batch: int = 2          # 每批最大下单数
    order_frequency: float = 10.0          # 下单频率控制（秒）
    activation_bounds: Optional[Decimal] = None  # 激活范围
    
    # 上下方分布参数（核心改进）
    upper_lower_ratio: Decimal = Decimal("0.5")  # 上方挂单比例
    
    # 订单类型
    open_order_type: str = "LIMIT"
    close_order_type: str = "LIMIT"
    
    # 安全参数
    safe_extra_spread: Decimal = Decimal("0.001")  # 安全边距
    leverage: int = 1                      # 杠杆倍数
    
    # 兼容性参数
    is_single_mode: bool = True            # 是否单账号模式

class GridExecutorFactory:
    """
    执行器工厂 - 支持单账号和双账号模式
    """
    
    @staticmethod
    def create_executors(config: GridExecutorConfig) -> Tuple[List, Optional]:
        """
        根据配置创建执行器
        
        Returns:
            (executors_list, sync_controller)
        """
        if config.account_mode == 'SINGLE':
            # 单账号模式：只创建多头执行器
            long_executor = LongAccountExecutor(config)
            return [long_executor], None
        
        elif config.account_mode == 'DUAL':
            # 双账号模式：创建双执行器和同步控制器
            long_config = copy.deepcopy(config)
            short_config = copy.deepcopy(config)
            
            # 为不同账户设置不同的挂单策略
            long_config.upper_lower_ratio = Decimal("0.3")   # 多头：上方30%，下方70%
            short_config.upper_lower_ratio = Decimal("0.7")  # 空头：上方70%，下方30%
            
            long_executor = LongAccountExecutor(long_config)
            short_executor = ShortAccountExecutor(short_config)
            
            # 注意：这里暂时返回None，实际需要导入SyncController
            return [long_executor, short_executor], None
        
        else:
            raise ValueError(f"不支持的账号模式: {config.account_mode}")

    @staticmethod
    def create_config_presets() -> Dict[str, GridExecutorConfig]:
        """创建预设配置"""
        return {
            'conservative': GridExecutorConfig(
                connector_name='binance',
                trading_pair='BTC-USDT',
                account_mode='SINGLE',
                start_price=Decimal("30000"),
                end_price=Decimal("35000"),
                grid_spacing_pct=Decimal("0.01"),
                total_amount_quote=Decimal("1000"),
                max_open_orders=2,
                upper_lower_ratio=Decimal("0.0"),  # 只下方挂单
                activation_bounds=Decimal("0.02")
            ),
            'balanced': GridExecutorConfig(
                connector_name='binance',
                trading_pair='BTC-USDT',
                account_mode='DUAL',
                start_price=Decimal("30000"),
                end_price=Decimal("35000"),
                grid_spacing_pct=Decimal("0.01"),
                total_amount_quote=Decimal("2000"),
                max_open_orders=4,
                upper_lower_ratio=Decimal("0.5"),  # 上下方各50%
                activation_bounds=Decimal("0.03")
            ),
            'aggressive': GridExecutorConfig(
                connector_name='binance',
                trading_pair='BTC-USDT',
                account_mode='DUAL',
                start_price=Decimal("30000"),
                end_price=Decimal("35000"),
                grid_spacing_pct=Decimal("0.01"),
                total_amount_quote=Decimal("5000"),
                max_open_orders=8,
                upper_lower_ratio=Decimal("0.25"),  # 上方25%，下方75%
                activation_bounds=Decimal("0.05")
            )
        }
```

---

**文件位置**：`core/hedge_grid_executor.py`

```python
import asyncio
from typing import Dict, Any, List, Optional
from core.market_data import MarketDataProvider
from core.order_manager import OrderManager
from core.risk_controller import RiskController
from utils.logger import logger

class HedgeGridExecutor:
    """对冲网格执行器 - 基于共享参数执行单账户网格策略"""
    
    def __init__(self, account_type: str, account_config: Dict,
                 market_data_provider: MarketDataProvider,
                 order_manager: OrderManager,
                 risk_controller: RiskController):
        
        self.account_type = account_type.upper()
        self.account_config = account_config
        self.market_data_provider = market_data_provider
        self.order_manager = order_manager
        self.risk_controller = risk_controller
        
        # 执行状态
        self.current_grid_params = {}
        self.target_orders = []
        self.execution_enabled = False
        self.last_execution_time = 0
        
        # 锁机制
        self.execution_lock = asyncio.Lock()
        
        logger.info(f"{self.account_type}账户网格执行器初始化完成")
    
    async def update_grid_parameters(self, shared_params: Dict[str, Any]):
        """更新网格参数（从共享引擎接收）"""
        try:
            self.current_grid_params = shared_params
            
            # 重新计算目标订单
            await self._calculate_target_orders()
            
            logger.info(f"{self.account_type}账户网格参数已更新")
            
        except Exception as e:
            logger.error(f"{self.account_type}账户更新网格参数失败: {e}")
    
    async def _calculate_target_orders(self):
        """根据当前参数计算目标订单"""
        try:
            if not self.current_grid_params:
                logger.warning(f"{self.account_type}账户没有可用的网格参数")
                return
            
            self.target_orders = []
            current_price = self.current_grid_params.get('current_price', 0)
            target_levels = self.current_grid_params.get('target_levels', [])
            grid_amount = self.current_grid_params.get('grid_amount_data', {}).get('base_quantity', 0)
            
            if self.account_type == 'LONG':
                # 多头账户：在所有网格点位挂买单
                for level in target_levels:
                    if level.get('entry_price', 0) < current_price:  # 只在当前价格下方挂买单
                        order = {
                            'side': 'buy',
                            'price': level['entry_price'],
                            'quantity': grid_amount,
                            'position_side': 'LONG',
                            'type': 'limit',
                            'level_info': level
                        }
                        self.target_orders.append(order)
                        
            elif self.account_type == 'SHORT':
                # 空头账户：在所有网格点位挂卖单
                for level in target_levels:
                    if level.get('entry_price', 0) > current_price:  # 只在当前价格上方挂卖单
                        order = {
                            'side': 'sell',
                            'price': level['entry_price'],
                            'quantity': grid_amount,
                            'position_side': 'SHORT',
                            'type': 'limit',
                            'level_info': level
                        }
                        self.target_orders.append(order)
            
            logger.debug(f"{self.account_type}账户计算出{len(self.target_orders)}个目标订单")
            
        except Exception as e:
            logger.error(f"{self.account_type}账户计算目标订单失败: {e}")
    
    async def execute_grid_strategy(self):
        """执行网格策略"""
        async with self.execution_lock:
            try:
                if not self.execution_enabled:
                    logger.debug(f"{self.account_type}账户执行未启用")
                    return
                
                # 防止频繁执行
                current_time = time.time()
                if current_time - self.last_execution_time < 3:
                    return
                
                # 风险检查
                if not self.risk_controller.check_position_limits():
                    logger.warning(f"{self.account_type}账户风险检查失败，暂停执行")
                    return
                
                # 获取当前订单
                current_orders = self.order_manager.get_open_orders()
                
                # 同步订单
                await self._sync_orders(current_orders, self.target_orders)
                
                self.last_execution_time = current_time
                
            except Exception as e:
                logger.error(f"{self.account_type}账户执行网格策略失败: {e}")
    
    async def _sync_orders(self, current_orders: List[Dict], target_orders: List[Dict]):
        """同步当前订单与目标订单"""
        try:
            # 分析当前订单
            current_prices = {round(float(order.get('price', 0)), 6) 
                            for order in current_orders 
                            if self._is_relevant_order(order)}
            
            # 分析目标订单
            target_prices = {round(order['price'], 6) for order in target_orders}
            
            # 计算需要新增的订单
            new_prices = target_prices - current_prices
            if new_prices:
                logger.info(f"{self.account_type}账户需要新增{len(new_prices)}个订单")
                for target_order in target_orders:
                    if round(target_order['price'], 6) in new_prices:
                        await self._place_grid_order(target_order)
            
            # 计算需要取消的订单
            cancel_prices = current_prices - target_prices
            if cancel_prices:
                logger.info(f"{self.account_type}账户需要取消{len(cancel_prices)}个订单")
                for current_order in current_orders:
                    if (round(float(current_order.get('price', 0)), 6) in cancel_prices 
                        and self._is_relevant_order(current_order)):
                        await self._cancel_grid_order(current_order)
            
        except Exception as e:
            logger.error(f"{self.account_type}账户同步订单失败: {e}")
    
    def _is_relevant_order(self, order: Dict) -> bool:
        """判断订单是否与当前账户策略相关"""
        order_side = order.get('side', '').lower()
        position_side = order.get('info', {}).get('positionSide', '')
        
        if self.account_type == 'LONG':
            return order_side == 'buy' and position_side == 'LONG'
        elif self.account_type == 'SHORT':
            return order_side == 'sell' and position_side == 'SHORT'
        
        return False
    
    async def _place_grid_order(self, order_info: Dict):
        """下网格订单"""
        try:
            result = self.order_manager.place_order(
                side=order_info['side'],
                price=order_info['price'],
                quantity=order_info['quantity'],
                position_side=order_info['position_side'],
                order_type=order_info.get('type', 'limit')
            )
            
            if result:
                logger.info(f"{self.account_type}账户下单成功: {order_info['side']} "
                          f"{order_info['quantity']} @ {order_info['price']:.6f}")
            
        except Exception as e:
            logger.error(f"{self.account_type}账户下单失败: {e}")
    
    async def _cancel_grid_order(self, order_info: Dict):
        """取消网格订单"""
        try:
            order_id = order_info.get('id')
            if order_id:
                await self.order_manager.cancel_order(order_id)
                logger.info(f"{self.account_type}账户取消订单: {order_id}")
                
        except Exception as e:
            logger.error(f"{self.account_type}账户取消订单失败: {e}")
    
    def enable_execution(self):
        """启用执行"""
        self.execution_enabled = True
        logger.info(f"{self.account_type}账户网格执行已启用")
    
    def disable_execution(self):
        """禁用执行"""
        self.execution_enabled = False
        logger.info(f"{self.account_type}账户网格执行已禁用")
    
    async def cleanup_all_orders(self):
        """清理所有订单"""
        try:
            current_orders = self.order_manager.get_open_orders()
            relevant_orders = [order for order in current_orders if self._is_relevant_order(order)]
            
            for order in relevant_orders:
                await self._cancel_grid_order(order)
            
            logger.info(f"{self.account_type}账户订单清理完成")
            
        except Exception as e:
            logger.error(f"{self.account_type}账户清理订单失败: {e}")
```

### 4.2 止盈订单管理器

```python
class TakeProfitManager:
    """止盈订单管理器 - 处理网格止盈逻辑"""
    
    def __init__(self, account_type: str, order_manager: OrderManager):
        self.account_type = account_type.upper()
        self.order_manager = order_manager
        self.active_take_profits = {}  # 跟踪活跃的止盈单
    
    async def handle_order_fill(self, filled_order: Dict):
        """处理订单成交事件"""
        try:
            if not self._is_entry_order(filled_order):
                return
            
            # 为成交的入场单创建止盈单
            await self._create_take_profit_order(filled_order)
            
        except Exception as e:
            logger.error(f"{self.account_type}账户处理订单成交失败: {e}")
    
    def _is_entry_order(self, order: Dict) -> bool:
        """判断是否为入场订单"""
        side = order.get('side', '').lower()
        position_side = order.get('info', {}).get('positionSide', '')
        reduce_only = order.get('reduceOnly', False)
        
        # 入场单：非reduce_only，且方向匹配账户类型
        if reduce_only:
            return False
        
        if self.account_type == 'LONG':
            return side == 'buy' and position_side == 'LONG'
        elif self.account_type == 'SHORT':
            return side == 'sell' and position_side == 'SHORT'
        
        return False
    
    async def _create_take_profit_order(self, entry_order: Dict):
        """创建止盈订单"""
        try:
            entry_price = float(entry_order.get('price', 0))
            quantity = float(entry_order.get('filled', 0))
            
            if entry_price <= 0 or quantity <= 0:
                logger.warning(f"{self.account_type}账户入场订单信息不完整")
                return
            
            # 计算止盈价格（基于网格间距）
            grid_spacing = 0.005  # 默认0.5%，实际应从配置获取
            
            if self.account_type == 'LONG':
                # 多头止盈：卖出价格 = 入场价格 + 网格间距
                take_profit_price = entry_price * (1 + grid_spacing)
                side = 'sell'
                position_side = 'LONG'
            elif self.account_type == 'SHORT':
                # 空头止盈：买入价格 = 入场价格 - 网格间距  
                take_profit_price = entry_price * (1 - grid_spacing)
                side = 'buy'
                position_side = 'SHORT'
            else:
                return
            
            # 下止盈单
            result = self.order_manager.place_order(
                side=side,
                price=take_profit_price,
                quantity=quantity,
                position_side=position_side,
                is_reduce_only=True,
                order_type='limit'
            )
            
            if result:
                order_id = result.get('orderId')
                self.active_take_profits[order_id] = {
                    'entry_order_id': entry_order.get('id'),
                    'entry_price': entry_price,
                    'take_profit_price': take_profit_price,
                    'quantity': quantity,
                    'timestamp': time.time()
                }
                
                logger.info(f"{self.account_type}账户止盈单已创建: "
                          f"{side} {quantity} @ {take_profit_price:.6f} "
                          f"(入场价: {entry_price:.6f})")
            
        except Exception as e:
            logger.error(f"{self.account_type}账户创建止盈单失败: {e}")
    
    async def cleanup_expired_take_profits(self, max_age: int = 3600):
        """清理过期的止盈单"""
        try:
            current_time = time.time()
            expired_orders = []
            
            for order_id, tp_info in self.active_take_profits.items():
                if current_time - tp_info['timestamp'] > max_age:
                    expired_orders.append(order_id)
            
            for order_id in expired_orders:
                try:
                    await self.order_manager.cancel_order(order_id)
                    del self.active_take_profits[order_id]
                    logger.info(f"{self.account_type}账户清理过期止盈单: {order_id}")
                except:
                    pass
                    
        except Exception as e:
            logger.error(f"{self.account_type}账户清理过期止盈单失败: {e}")
```

## 5. 同步控制器架构（升级版）

### 5.1 升级版同步控制器

**文件位置**：`core/sync_controller_v2.py`

```python
import asyncio
from typing import Dict, Any, List, Optional
from core.long_account_executor import LongAccountExecutor
from core.short_account_executor import ShortAccountExecutor
from core.shared_grid_engine import SharedGridEngine
from utils.logger import logger

class SyncController:
    """
    双执行器同步控制器 - 升级版
    负责协调多头和空头执行器的同步执行
    """
    
    def __init__(self, long_executor: LongAccountExecutor, 
                 short_executor: ShortAccountExecutor):
        self.long_executor = long_executor
        self.short_executor = short_executor
        self.shared_grid_engine = SharedGridEngine()
        
        # 同步状态
        self.sync_enabled = True
        self.monitoring_enabled = True
        self.should_stop = False
        
        # 执行器列表
        self.executors = [self.long_executor, self.short_executor]
        
        # 风险控制参数
        self.max_position_imbalance = 0.2
        self.emergency_stop_threshold = 0.1
        
    async def start_hedge_strategy(self):
        """
        启动对冲策略
        """
        try:
            logger.info("启动双账户对冲网格策略")
            
            # 1. 初始化共享网格参数
            await self.shared_grid_engine.initialize_grid_parameters()
            
            # 2. 注入共享引擎到执行器
            self.long_executor.shared_grid_engine = self.shared_grid_engine
            self.short_executor.shared_grid_engine = self.shared_grid_engine
            
            # 3. 启动双执行器
            await asyncio.gather(
                self.long_executor.start(),
                self.short_executor.start()
            )
            
            # 4. 启动同步监控
            await self.start_sync_monitoring()
            
        except Exception as e:
            logger.error(f"启动对冲策略失败: {e}")
            await self.stop_hedge_strategy()
            raise
    
    async def stop_hedge_strategy(self):
        """
        停止对冲策略
        """
        try:
            logger.info("停止双账户对冲网格策略")
            
            # 1. 设置停止标志
            self.should_stop = True
            
            # 2. 停止执行器
            await asyncio.gather(
                self.long_executor.stop(),
                self.short_executor.stop(),
                return_exceptions=True
            )
            
            # 3. 清理资源
            await self.cleanup()
            
            logger.info("对冲策略已成功停止")
            
        except Exception as e:
            logger.error(f"停止对冲策略失败: {e}")
    
    async def start_sync_monitoring(self):
        """
        同步监控循环
        """
        logger.info("启动同步监控")
        
        while not self.should_stop:
            try:
                if self.sync_enabled:
                    # 同步网格参数
                    await self.sync_grid_parameters()
                    
                    # 风险控制检查
                    await self.check_hedge_risk()
                    
                    # 状态同步
                    await self.sync_executor_states()
                
                if self.monitoring_enabled:
                    # 性能监控
                    await self.monitor_performance()
                
                await asyncio.sleep(1)
                
            except Exception as e:
                logger.error(f"同步监控异常: {e}")
                await asyncio.sleep(5)
        
        logger.info("同步监控已停止")
    
    async def sync_grid_parameters(self):
        """
        同步网格参数到双执行器
        """
        try:
            # 从共享引擎获取最新网格参数
            grid_params = await self.shared_grid_engine.get_current_grid_params()
            
            if grid_params:
                # 更新执行器网格参数
                self.long_executor.update_grid_levels(grid_params.get('long_levels', []))
                self.short_executor.update_grid_levels(grid_params.get('short_levels', []))
                
        except Exception as e:
            logger.error(f"同步网格参数失败: {e}")
    
    async def check_hedge_risk(self):
        """
        对冲风险控制检查
        """
        try:
            # 获取执行器状态
            long_status = self.long_executor.get_status()
            short_status = self.short_executor.get_status()
            
            # 检查持仓不平衡
            position_imbalance = self._calculate_position_imbalance(long_status, short_status)
            
            if position_imbalance > self.max_position_imbalance:
                logger.warning(f"持仓不平衡超过阈值: {position_imbalance:.2%}")
                await self._handle_position_imbalance()
            
            # 检查紧急停止条件
            if self._should_emergency_stop(long_status, short_status):
                logger.error("触发紧急停止条件")
                await self.emergency_stop()
            
        except Exception as e:
            logger.error(f"对冲风险检查失败: {e}")
    
    def _calculate_position_imbalance(self, long_status: Dict, short_status: Dict) -> float:
        """计算持仓不平衡比例"""
        try:
            long_positions = long_status.get('active_open_orders', 0)
            short_positions = short_status.get('active_open_orders', 0)
            
            total_positions = long_positions + short_positions
            if total_positions == 0:
                return 0.0
            
            imbalance = abs(long_positions - short_positions) / total_positions
            return imbalance
            
        except Exception as e:
            logger.error(f"计算持仓不平衡失败: {e}")
            return 0.0
    
    def _should_emergency_stop(self, long_status: Dict, short_status: Dict) -> bool:
        """判断是否需要紧急停止"""
        try:
            # 检查执行器状态
            long_running = long_status.get('status') == 'RUNNING'
            short_running = short_status.get('status') == 'RUNNING'
            
            # 如果任一执行器异常，触发紧急停止
            if not (long_running and short_running):
                return True
            
            # 其他紧急停止条件可以在这里添加
            return False
            
        except Exception as e:
            logger.error(f"检查紧急停止条件失败: {e}")
            return True
    
    async def _handle_position_imbalance(self):
        """处理持仓不平衡"""
        try:
            logger.info("处理持仓不平衡")
            
            # 暂时禁用执行，等待平衡
            for executor in self.executors:
                executor.execution_enabled = False
            
            # 等待一段时间让持仓自然平衡
            await asyncio.sleep(30)
            
            # 重新启用执行
            for executor in self.executors:
                executor.execution_enabled = True
            
            logger.info("持仓不平衡处理完成")
            
        except Exception as e:
            logger.error(f"处理持仓不平衡失败: {e}")
    
    async def emergency_stop(self):
        """紧急停止"""
        try:
            logger.error("执行紧急停止")
            
            # 立即停止所有执行器
            tasks = [executor.stop() for executor in self.executors]
            await asyncio.gather(*tasks, return_exceptions=True)
            
            # 取消所有挂单
            for executor in self.executors:
                try:
                    await executor.cancel_all_orders()
                except Exception as e:
                    logger.error(f"紧急取消订单失败: {e}")
            
            # 设置停止标志
            self.should_stop = True
            
            logger.error("紧急停止执行完成")
            
        except Exception as e:
            logger.error(f"紧急停止失败: {e}")
    
    async def sync_executor_states(self):
---
## 6. 统一监控模块

### 6.1 对冲监控器

**文件位置**：`core/hedge_monitor.py`

```python
import asyncio
import time
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
from core.dual_account_manager import DualAccountManager
from utils.logger import logger

class HedgeStatus(Enum):
    """对冲状态枚举"""
    BALANCED = "平衡"
    IMBALANCED = "失衡"
    CRITICAL = "严重失衡"
    ERROR = "错误"

@dataclass
class HedgeMetrics:
    """对冲指标数据类"""
    timestamp: float
    long_position: float
    short_position: float
    hedge_ratio: float
    position_imbalance: float
    total_pnl: float
    long_pnl: float
    short_pnl: float
    status: HedgeStatus
    
class HedgeMonitor:
    """对冲策略监控器 - 实时监控双账户对冲效果"""
    
    def __init__(self, dual_account_manager: DualAccountManager, config):
        self.dual_account_manager = dual_account_manager
        self.config = config
        
        # 监控状态
        self.is_monitoring = False
        self.current_metrics = None
        self.metrics_history = []
        self.max_history_size = 1000
        
        # 阈值配置
        self.hedge_ratio_warning = 0.8    # 对冲比例警告线
        self.hedge_ratio_critical = 0.6   # 对冲比例危险线
        self.imbalance_warning = 0.2      # 持仓失衡警告线
        self.imbalance_critical = 0.4     # 持仓失衡危险线
        
        # 监控任务
        self.monitor_task = None
        self.alert_handlers = []
        
        logger.info("对冲监控器初始化完成")
    
    async def start_monitoring(self, interval: int = 10):
        """启动监控"""
        try:
            if self.is_monitoring:
                logger.warning("监控已在运行中")
                return
            
            self.is_monitoring = True
            self.monitor_task = asyncio.create_task(
                self._monitoring_loop(interval)
            )
            
            logger.info(f"对冲监控已启动，监控间隔: {interval}秒")
            
        except Exception as e:
            logger.error(f"启动监控失败: {e}")
    
    async def stop_monitoring(self):
        """停止监控"""
        try:
            self.is_monitoring = False
            
            if self.monitor_task and not self.monitor_task.done():
                self.monitor_task.cancel()
                try:
                    await self.monitor_task
                except asyncio.CancelledError:
                    pass
            
            logger.info("对冲监控已停止")
            
        except Exception as e:
            logger.error(f"停止监控失败: {e}")
    
    async def _monitoring_loop(self, interval: int):
        """监控循环"""
        while self.is_monitoring:
            try:
                # 收集监控数据
                metrics = await self._collect_hedge_metrics()
                
                if metrics:
                    # 更新当前指标
                    self.current_metrics = metrics
                    
                    # 添加到历史记录
                    self._add_to_history(metrics)
                    
                    # 状态分析和告警
                    await self._analyze_and_alert(metrics)
                    
                    # 记录监控日志
                    self._log_metrics(metrics)
                
                await asyncio.sleep(interval)
                
            except Exception as e:
                logger.error(f"监控循环异常: {e}")
                await asyncio.sleep(5)
    
    async def _collect_hedge_metrics(self) -> Optional[HedgeMetrics]:
        """收集对冲指标"""
        try:
            # 获取双账户持仓
            long_risk = self.dual_account_manager.get_risk_controller('LONG')
            short_risk = self.dual_account_manager.get_risk_controller('SHORT')
            
            long_pos, _ = long_risk.get_position()
            _, short_pos = short_risk.get_position()
            
            # 计算对冲比例
            hedge_ratio = self._calculate_hedge_ratio(long_pos, short_pos)
            
            # 计算持仓失衡度
            position_imbalance = self._calculate_position_imbalance(long_pos, short_pos)
            
            # 获取PnL数据
            long_pnl = await self._get_account_pnl('LONG')
            short_pnl = await self._get_account_pnl('SHORT')
            total_pnl = long_pnl + short_pnl
            
            # 确定状态
            status = self._determine_hedge_status(hedge_ratio, position_imbalance)
            
            return HedgeMetrics(
                timestamp=time.time(),
                long_position=long_pos,
                short_position=short_pos,
                hedge_ratio=hedge_ratio,
                position_imbalance=position_imbalance,
                total_pnl=total_pnl,
                long_pnl=long_pnl,
                short_pnl=short_pnl,
                status=status
            )
            
        except Exception as e:
            logger.error(f"收集对冲指标失败: {e}")
            return None
    
    def _calculate_hedge_ratio(self, long_pos: float, short_pos: float) -> float:
        """计算对冲比例"""
        if long_pos == 0 and short_pos == 0:
            return 1.0  # 都没有持仓，视为完全对冲
        
        if long_pos == 0 or short_pos == 0:
            return 0.0  # 单边持仓，无对冲
        
        return min(long_pos, short_pos) / max(long_pos, short_pos)
    
    def _calculate_position_imbalance(self, long_pos: float, short_pos: float) -> float:
        """计算持仓失衡度"""
        total_pos = long_pos + short_pos
        if total_pos == 0:
            return 0.0
        
        return abs(long_pos - short_pos) / total_pos
    
    async def _get_account_pnl(self, account_type: str) -> float:
        """获取账户PnL"""
        try:
            account = self.dual_account_manager.get_account_instance(account_type)
            positions = account.fetch_positions([self.config.SYMBOL])
            
            total_pnl = 0.0
            for position in positions:
                if position['contracts'] != 0:
                    total_pnl += float(position.get('unrealizedPnl', 0))
            
            return total_pnl
            
        except Exception as e:
            logger.error(f"获取{account_type}账户PnL失败: {e}")
            return 0.0
    
    def _determine_hedge_status(self, hedge_ratio: float, position_imbalance: float) -> HedgeStatus:
        """确定对冲状态"""
        if hedge_ratio < self.hedge_ratio_critical or position_imbalance > self.imbalance_critical:
            return HedgeStatus.CRITICAL
        elif hedge_ratio < self.hedge_ratio_warning or position_imbalance > self.imbalance_warning:
            return HedgeStatus.IMBALANCED
        else:
            return HedgeStatus.BALANCED
    
    def _add_to_history(self, metrics: HedgeMetrics):
        """添加到历史记录"""
        self.metrics_history.append(metrics)
        
        # 限制历史记录大小
        if len(self.metrics_history) > self.max_history_size:
            self.metrics_history.pop(0)
    
    async def _analyze_and_alert(self, metrics: HedgeMetrics):
        """分析并发送告警"""
        alerts = []
        
        # 检查对冲比例
        if metrics.hedge_ratio < self.hedge_ratio_critical:
            alerts.append(f"严重警告: 对冲比例过低 {metrics.hedge_ratio:.2f}")
        elif metrics.hedge_ratio < self.hedge_ratio_warning:
            alerts.append(f"警告: 对冲比例偏低 {metrics.hedge_ratio:.2f}")
        
        # 检查持仓失衡
        if metrics.position_imbalance > self.imbalance_critical:
            alerts.append(f"严重警告: 持仓严重失衡 {metrics.position_imbalance:.2f}")
        elif metrics.position_imbalance > self.imbalance_warning:
            alerts.append(f"警告: 持仓失衡 {metrics.position_imbalance:.2f}")
        
        # 发送告警
        for alert in alerts:
            await self._send_alert(alert, metrics)
    
    async def _send_alert(self, message: str, metrics: HedgeMetrics):
        """发送告警"""
        logger.warning(f"对冲监控告警: {message}")
        
        # 调用注册的告警处理器
        for handler in self.alert_handlers:
            try:
                await handler(message, metrics)
            except Exception as e:
                logger.error(f"告警处理器异常: {e}")
    
    def _log_metrics(self, metrics: HedgeMetrics):
        """记录监控指标"""
        if self.config.dual_account.LOG_HEDGE_STATUS:
            logger.info(
                f"对冲监控 - 状态: {metrics.status.value}, "
                f"多头: {metrics.long_position:.2f}, "
                f"空头: {metrics.short_position:.2f}, "
                f"对冲比例: {metrics.hedge_ratio:.3f}, "
                f"失衡度: {metrics.position_imbalance:.3f}, "
                f"总PnL: {metrics.total_pnl:.2f}"
            )
    
    def register_alert_handler(self, handler):
        """注册告警处理器"""
        self.alert_handlers.append(handler)
        logger.info("告警处理器已注册")
    
    def get_current_metrics(self) -> Optional[HedgeMetrics]:
        """获取当前指标"""
        return self.current_metrics
    
    def get_metrics_history(self, limit: int = 100) -> List[HedgeMetrics]:
        """获取历史指标"""
        return self.metrics_history[-limit:] if self.metrics_history else []
    
    def generate_summary_report(self) -> Dict[str, Any]:
        """生成监控摘要报告"""
        if not self.current_metrics:
            return {"error": "没有可用的监控数据"}
        
        # 计算历史统计
        recent_metrics = self.get_metrics_history(100)
        
        avg_hedge_ratio = sum(m.hedge_ratio for m in recent_metrics) / len(recent_metrics) if recent_metrics else 0
        avg_imbalance = sum(m.position_imbalance for m in recent_metrics) / len(recent_metrics) if recent_metrics else 0
        
        return {
            "current_status": {
                "hedge_status": self.current_metrics.status.value,
                "hedge_ratio": self.current_metrics.hedge_ratio,
                "position_imbalance": self.current_metrics.position_imbalance,
                "total_pnl": self.current_metrics.total_pnl,
                "long_position": self.current_metrics.long_position,
                "short_position": self.current_metrics.short_position
            },
            "historical_averages": {
                "avg_hedge_ratio": avg_hedge_ratio,
                "avg_position_imbalance": avg_imbalance,
                "data_points": len(recent_metrics)
            },
            "monitoring_info": {
                "is_active": self.is_monitoring,
                "last_update": self.current_metrics.timestamp,
                "total_history_count": len(self.metrics_history)
            }
        }
```

### 6.2 性能监控器

```python
class PerformanceMonitor:
    """性能监控器 - 监控系统性能和延迟"""
    
    def __init__(self):
        self.execution_times = {}
        self.error_counts = {}
        self.success_counts = {}
        
    def record_execution_time(self, operation: str, execution_time: float):
        """记录执行时间"""
        if operation not in self.execution_times:
            self.execution_times[operation] = []
        
        self.execution_times[operation].append(execution_time)
        
        # 限制记录数量
        if len(self.execution_times[operation]) > 1000:
            self.execution_times[operation].pop(0)
    
    def record_success(self, operation: str):
        """记录成功操作"""
        self.success_counts[operation] = self.success_counts.get(operation, 0) + 1
    
    def record_error(self, operation: str):
        """记录错误操作"""
        self.error_counts[operation] = self.error_counts.get(operation, 0) + 1
    
    def get_performance_stats(self) -> Dict[str, Any]:
        """获取性能统计"""
        stats = {}
        
        for operation, times in self.execution_times.items():
            if times:
                stats[operation] = {
                    "avg_time": sum(times) / len(times),
                    "min_time": min(times),
                    "max_time": max(times),
                    "total_executions": len(times),
                    "success_count": self.success_counts.get(operation, 0),
                    "error_count": self.error_counts.get(operation, 0)
                }
        
        return stats

# 全局性能监控实例
performance_monitor = PerformanceMonitor()
```

### 6.3 监控装饰器

```python
import functools
import time

def monitor_performance(operation_name: str):
    """性能监控装饰器"""
    def decorator(func):
        @functools.wraps(func)
        async def async_wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = await func(*args, **kwargs)
                performance_monitor.record_success(operation_name)
                return result
            except Exception as e:
                performance_monitor.record_error(operation_name)
                raise
            finally:
                execution_time = time.time() - start_time
                performance_monitor.record_execution_time(operation_name, execution_time)
        
        @functools.wraps(func)
        def sync_wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = func(*args, **kwargs)
                performance_monitor.record_success(operation_name)
                return result
            except Exception as e:
                performance_monitor.record_error(operation_name)
                raise
            finally:
                execution_time = time.time() - start_time
                performance_monitor.record_execution_time(operation_name, execution_time)
        
        return async_wrapper if asyncio.iscoroutinefunction(func) else sync_wrapper
    return decorator
```

---
## 7. 启动脚本

### 7.1 主启动脚本

**文件位置**：`hedge_grid_strategy.py`

```python
#!/usr/bin/env python3
"""
双账户对冲网格策略主启动脚本
实现两个币安账户的市场中性对冲网格交易
"""

import asyncio
import sys
import os
from pathlib import Path

# 添加项目根目录到Python路径
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from config.dual_account_config import ConfigManager
from core.sync_controller import SyncController, SignalHandler
from core.hedge_monitor import HedgeMonitor
from utils.logger import logger

class HedgeGridTradingBot:
    """双账户对冲网格交易机器人主类"""
    
    def __init__(self):
        self.config_manager = None
        self.sync_controller = None
        self.hedge_monitor = None
        self.signal_handler = None
        
    async def initialize(self) -> bool:
        """初始化系统"""
        try:
            logger.info("=" * 60)
            logger.info("双账户对冲网格交易机器人启动中...")
            logger.info("=" * 60)
            
            # 1. 初始化配置管理器
            logger.info("1. 初始化配置管理器...")
            self.config_manager = ConfigManager(mode='hedge')
            
            if not self.config_manager.config.dual_account.validate_config():
                logger.error("配置验证失败，请检查环境变量")
                return False
            
            logger.info("✓ 配置管理器初始化完成")
            
            # 2. 初始化同步控制器
            logger.info("2. 初始化同步控制器...")
            self.sync_controller = SyncController(self.config_manager)
            
            if not await self.sync_controller.initialize_system():
                logger.error("同步控制器初始化失败")
                return False
            
            logger.info("✓ 同步控制器初始化完成")
            
            # 3. 初始化监控器
            logger.info("3. 初始化监控器...")
            self.hedge_monitor = HedgeMonitor(
                self.sync_controller.dual_account_manager,
                self.config_manager.config
            )
            
            # 注册告警处理器
            self.hedge_monitor.register_alert_handler(self._handle_alert)
            
            logger.info("✓ 监控器初始化完成")
            
            # 4. 设置信号处理器
            logger.info("4. 设置信号处理器...")
            self.signal_handler = SignalHandler(self.sync_controller)
            logger.info("✓ 信号处理器设置完成")
            
            logger.info("=" * 60)
            logger.info("系统初始化完成，准备启动策略...")
            logger.info("=" * 60)
            
            return True
            
        except Exception as e:
            logger.error(f"系统初始化失败: {e}")
            return False
    
    async def run(self):
        """运行主程序"""
        try:
            # 初始化系统
            if not await self.initialize():
                logger.error("初始化失败，程序退出")
                return False
            
            # 启动监控
            await self.hedge_monitor.start_monitoring(
                interval=self.config_manager.config.dual_account.MONITOR_INTERVAL
            )
            
            # 显示启动信息
            self._display_startup_info()
            
            # 启动策略
            success = await self.sync_controller.start_dual_grid_strategy()
            
            if not success:
                logger.error("策略启动失败")
                return False
            
            return True
            
        except KeyboardInterrupt:
            logger.info("收到键盘中断信号")
            return True
        except Exception as e:
            logger.error(f"运行异常: {e}")
            return False
        finally:
            await self.cleanup()
    
    async def cleanup(self):
        """清理资源"""
        try:
            logger.info("开始清理系统资源...")
            
            # 停止监控
            if self.hedge_monitor:
                await self.hedge_monitor.stop_monitoring()
            
            # 停止策略
            if self.sync_controller:
                await self.sync_controller.stop_dual_grid_strategy()
            
            logger.info("系统资源清理完成")
            
        except Exception as e:
            logger.error(f"清理资源失败: {e}")
    
    def _display_startup_info(self):
        """显示启动信息"""
        config = self.config_manager.config
        
        logger.info("\n" + "=" * 60)
        logger.info("双账户对冲网格策略配置信息")
        logger.info("=" * 60)
        logger.info(f"交易对: {getattr(config, 'SYMBOL', 'Unknown')}")
        logger.info(f"基础杠杆: {getattr(config, 'BASE_LEVERAGE', 'Unknown')}")
        logger.info(f"ATR周期: {getattr(config, 'ATR_PERIOD', 'Unknown')}")
        logger.info(f"ATR倍数: {getattr(config, 'ATR_MULTIPLIER', 'Unknown')}")
        logger.info(f"网格层数: {getattr(config, 'GRID_LEVELS', 'Unknown')}")
        logger.info(f"监控间隔: {config.dual_account.MONITOR_INTERVAL}秒")
        logger.info(f"多头账户: {config.dual_account.LONG_ACCOUNT_NAME}")
        logger.info(f"空头账户: {config.dual_account.SHORT_ACCOUNT_NAME}")
        logger.info("=" * 60)
        logger.info("策略已启动，开始执行对冲网格交易...")
        logger.info("按 Ctrl+C 优雅退出程序")
        logger.info("=" * 60 + "\n")
    
    async def _handle_alert(self, message: str, metrics):
        """处理监控告警"""
        logger.warning(f"🚨 监控告警: {message}")
        
        # 这里可以添加更多告警处理逻辑，如：
        # - 发送邮件通知
        # - 发送微信/钉钉消息
        # - 执行紧急止损
        # - 暂停策略执行等

async def main():
    """主函数"""
    bot = HedgeGridTradingBot()
    
    try:
        success = await bot.run()
        exit_code = 0 if success else 1
    except Exception as e:
        logger.error(f"程序异常退出: {e}")
        exit_code = 1
    
    sys.exit(exit_code)

if __name__ == "__main__":
    # 检查Python版本
    if sys.version_info < (3, 8):
        print("错误: 需要Python 3.8或更高版本")
        sys.exit(1)
    
    # 运行主程序
    asyncio.run(main())
```

### 7.2 Shell启动脚本

**文件位置**：`start_hedge_grid.sh`

```bash
#!/bin/bash

# 双账户对冲网格策略启动脚本

# 脚本配置
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PYTHON_SCRIPT="hedge_grid_strategy.py"
PID_FILE="$SCRIPT_DIR/hedge_grid.pid"
LOG_DIR="$SCRIPT_DIR/log"
LOG_FILE="$LOG_DIR/hedge_grid_startup.log"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 打印带颜色的消息
print_message() {
    local color=$1
    local message=$2
    echo -e "${color}$(date '+%Y-%m-%d %H:%M:%S') - ${message}${NC}"
}

# 检查环境
check_environment() {
    print_message $BLUE "检查运行环境..."
    
    # 检查Python版本
    if ! command -v python3 &> /dev/null; then
        print_message $RED "错误: 未找到python3"
        exit 1
    fi
    
    local python_version=$(python3 -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
    print_message $GREEN "Python版本: $python_version"
    
    # 检查必要文件
    if [ ! -f "$SCRIPT_DIR/$PYTHON_SCRIPT" ]; then
        print_message $RED "错误: 未找到主脚本 $PYTHON_SCRIPT"
        exit 1
    fi
    
    # 检查.env文件
    if [ ! -f "$SCRIPT_DIR/.env" ]; then
        print_message $RED "错误: 未找到配置文件 .env"
        exit 1
    fi
    
    # 创建日志目录
    mkdir -p "$LOG_DIR"
    
    print_message $GREEN "环境检查完成"
}

# 检查是否已在运行
check_if_running() {
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if ps -p $pid > /dev/null 2>&1; then
            print_message $YELLOW "警告: 对冲网格策略已在运行中 (PID: $pid)"
            echo "如需重启，请先运行: ./stop_hedge_grid.sh"
            exit 1
        else
            print_message $YELLOW "发现过期的PID文件，清理中..."
            rm -f "$PID_FILE"
        fi
    fi
}

# 安装依赖
install_dependencies() {
    print_message $BLUE "检查Python依赖..."
    
    if [ -f "$SCRIPT_DIR/requirements.txt" ]; then
        print_message $BLUE "安装依赖包..."
        python3 -m pip install -r "$SCRIPT_DIR/requirements.txt" >> "$LOG_FILE" 2>&1
        
        if [ $? -eq 0 ]; then
            print_message $GREEN "依赖安装完成"
        else
            print_message $RED "依赖安装失败，请检查日志"
            exit 1
        fi
    fi
}

# 启动策略
start_strategy() {
    print_message $BLUE "启动双账户对冲网格策略..."
    
    cd "$SCRIPT_DIR"
    
    # 后台启动策略
    nohup python3 "$PYTHON_SCRIPT" >> "$LOG_FILE" 2>&1 &
    local pid=$!
    
    # 保存PID
    echo $pid > "$PID_FILE"
    
    # 等待几秒钟检查启动状态
    sleep 3
    
    if ps -p $pid > /dev/null 2>&1; then
        print_message $GREEN "策略启动成功! (PID: $pid)"
        print_message $GREEN "日志文件: $LOG_FILE"
        print_message $GREEN "监控日志: tail -f $LOG_DIR/grid_trading.log"
        print_message $BLUE "停止策略: ./stop_hedge_grid.sh"
    else
        print_message $RED "策略启动失败，请检查日志"
        rm -f "$PID_FILE"
        exit 1
    fi
}

# 显示状态
show_status() {
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if ps -p $pid > /dev/null 2>&1; then
            print_message $GREEN "策略运行中 (PID: $pid)"
        else
            print_message $RED "策略已停止（PID文件过期）"
            rm -f "$PID_FILE"
        fi
    else
        print_message $YELLOW "策略未运行"
    fi
}

# 显示帮助
show_help() {
    echo "双账户对冲网格策略启动脚本"
    echo ""
    echo "用法: $0 [选项]"
    echo ""
    echo "选项:"
    echo "  start    启动策略（默认）"
    echo "  status   显示运行状态"
   
    echo "  help     显示此帮助信息"
    echo ""
    echo "环境要求:"
    echo "  - Python 3.8+"
    echo "  - 已配置 .env 文件"
    echo "  - 已安装依赖包"
    echo ""
}

# 主逻辑
main() {
    local action=${1:-start}
    
    case $action in
        "start")
            print_message $BLUE "=== 双账户对冲网格策略启动程序 ==="
            check_environment
            check_if_running
            install_dependencies
            start_strategy
            ;;
        "status")
            show_status
            ;;
        "help"|"-h"|"--help")
            show_help
            ;;
        *)
            print_message $RED "未知选项: $action"
            show_help
            exit 1
            ;;
    esac
}

# 执行主函数
main "$@"
```

### 7.3 停止脚本

**文件位置**：`stop_hedge_grid.sh`

```bash
#!/bin/bash

# 双账户对冲网格策略停止脚本

# 脚本配置
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PID_FILE="$SCRIPT_DIR/hedge_grid.pid"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# 打印带颜色的消息
print_message() {
    local color=$1
    local message=$2
    echo -e "${color}$(date '+%Y-%m-%d %H:%M:%S') - ${message}${NC}"
}

# 停止策略
stop_strategy() {
    if [ ! -f "$PID_FILE" ]; then
        print_message $YELLOW "策略未运行或PID文件不存在"
        return 0
    fi
    
    local pid=$(cat "$PID_FILE")
    
    if ! ps -p $pid > /dev/null 2>&1; then
        print_message $YELLOW "策略进程不存在（PID: $pid），清理PID文件"
        rm -f "$PID_FILE"
        return 0
    fi
    
    print_message $BLUE "正在停止双账户对冲网格策略 (PID: $pid)..."
    
    # 发送SIGTERM信号（优雅退出）
    kill -TERM $pid
    
    # 等待最多30秒让程序优雅退出
    local count=0
    while [ $count -lt 30 ]; do
        if ! ps -p $pid > /dev/null 2>&1; then
            print_message $GREEN "策略已优雅停止"
            rm -f "$PID_FILE"
            return 0
        fi
        sleep 1
        count=$((count + 1))
        if [ $((count % 5)) -eq 0 ]; then
            print_message $YELLOW "等待策略停止... ($count/30秒)"
        fi
    done
    
    # 如果优雅退出失败，强制终止
    print_message $YELLOW "优雅退出超时，强制终止进程..."
    kill -KILL $pid
    
    sleep 2
    if ! ps -p $pid > /dev/null 2>&1; then
        print_message $GREEN "策略已强制停止"
        rm -f "$PID_FILE"
        return 0
    else
        print_message $RED "无法停止策略进程"
        return 1
    fi
}

# 主函数
main() {
    print_message $BLUE "=== 双账户对冲网格策略停止程序 ==="
    stop_strategy
}

# 执行主函数
main "$@"
```

### 7.4 状态检查脚本

**文件位置**：`status_hedge_grid.sh`

```bash
#!/bin/bash

# 双账户对冲网格策略状态检查脚本

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PID_FILE="$SCRIPT_DIR/hedge_grid.pid"
LOG_FILE="$SCRIPT_DIR/log/grid_trading.log"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_message() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# 检查运行状态
check_status() {
    print_message $BLUE "=== 双账户对冲网格策略状态 ==="
    
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if ps -p $pid > /dev/null 2>&1; then
            print_message $GREEN "✓ 策略运行中 (PID: $pid)"
            
            # 显示进程信息
            local start_time=$(ps -o lstart= -p $pid | xargs)
            local cpu_usage=$(ps -o %cpu= -p $pid | xargs)
            local mem_usage=$(ps -o %mem= -p $pid | xargs)
            
            echo ""
            print_message $BLUE "进程信息:"
            echo "  PID: $pid"
            echo "  启动时间: $start_time"
            echo "  CPU使用率: ${cpu_usage}%"
            echo "  内存使用率: ${mem_usage}%"
            
            # 显示最近日志
            if [ -f "$LOG_FILE" ]; then
                echo ""
                print_message $BLUE "最近日志 (最后10行):"
                tail -n 10 "$LOG_FILE"
            fi
            
        else
            print_message $RED "✗ 策略已停止（PID文件过期）"
            rm -f "$PID_FILE"
        fi
    else
        print_message $YELLOW "✗ 策略未运行"
    fi
    
    echo ""
    print_message $BLUE "可用操作:"
    echo "  启动策略: ./start_hedge_grid.sh"
    echo "  停止策略: ./stop_hedge_grid.sh"
    echo "  查看日志: tail -f $LOG_FILE"
}
# 执行检查
check_status
```

---
## 8. 环境变量

### 8.1 .env配置文件

**文件位置**：`.env`

```bash
# ============================================
# 双账户对冲网格策略配置文件
# ============================================

# --------------------------------------------
# 多头账户配置（做多策略）
# --------------------------------------------
LONG_ACCOUNT_API_KEY=your_long_account_api_key_here
LONG_ACCOUNT_SECRET=your_long_account_secret_here
LONG_ACCOUNT_NAME=LongAccount

# --------------------------------------------
# 空头账户配置（做空策略）
# --------------------------------------------
SHORT_ACCOUNT_API_KEY=your_short_account_api_key_here
SHORT_ACCOUNT_SECRET=your_short_account_secret_here
SHORT_ACCOUNT_NAME=ShortAccount

# --------------------------------------------
# 基础交易配置（复用现有配置）
# --------------------------------------------
SYMBOL=DOGEUSDT
COIN_NAME=DOGE
CONTRACT_TYPE=USDT

# --------------------------------------------
# 网格策略配置
# --------------------------------------------
# 基础杠杆
BASE_LEVERAGE=10
# 最大杠杆限制
MAX_LEVERAGE_LIMIT=20
# 是否使用动态杠杆
USE_DYNAMIC_LEVERAGE=false

# 网格层数
GRID_LEVELS=5
# 最大网格层数
MAX_GRID_LEVELS=10

# 初始下单量
INITIAL_QUANTITY=100
# 是否使用动态数量
USE_DYNAMIC_QUANTITY=true

# 基础网格间距（百分比）
BASE_GRID_SPACING=0.5
GRID_SPACING=0.5

# --------------------------------------------
# ATR指标配置
# --------------------------------------------
# ATR周期
ATR_PERIOD=14
# ATR倍数
ATR_MULTIPLIER=2.0
# ATR时间框架
ATR_TIMEFRAME=1h
# 是否启用ATR固定模式
ATR_FIXED_MODE=true
# 是否使用ATR动态网格间距
USE_ATR_GRID_SPACING=true

# --------------------------------------------
# 动态计算配置
# --------------------------------------------
# 是否启用动态计算
ENABLE_DYNAMIC_CALCULATION=true
# 是否启用动态参数重计算
ENABLE_DYNAMIC_RECALCULATION=false

# --------------------------------------------
# 对冲策略特定配置
# --------------------------------------------
# 是否启用对冲模式
ENABLE_HEDGE_MODE=true
# 是否使用共享网格参数
SHARED_GRID_PARAMETERS=true
# 是否同步执行
SYNC_EXECUTION=true

# 对冲比例容忍度（0.05 = 5%）
HEDGE_RATIO_TOLERANCE=0.05
# 最大持仓不平衡比例（0.2 = 20%）
MAX_POSITION_IMBALANCE=0.2
# 紧急止损比例（0.1 = 10%）
EMERGENCY_STOP_LOSS=0.1

# --------------------------------------------
# 风险控制配置
# --------------------------------------------
# 持仓阈值
POSITION_THRESHOLD=500
# 持仓限制
POSITION_LIMIT=1000
# 最大开仓订单数
MAX_OPEN_ORDERS=20

# --------------------------------------------
# 时间控制配置
# --------------------------------------------
# 同步时间间隔（秒）
SYNC_TIME=10
# 首单间隔时间（秒）
ORDER_FIRST_TIME=30
# Ticker更新间隔（秒）
TICKER_UPDATE_INTERVAL=0.5
# 监控间隔（秒）
MONITOR_INTERVAL=10

# --------------------------------------------
# 日志配置
# --------------------------------------------
# 是否记录对冲状态
LOG_HEDGE_STATUS=true
# 日志级别 (DEBUG, INFO, WARNING, ERROR)
LOG_LEVEL=INFO

# --------------------------------------------
# WebSocket配置
# --------------------------------------------
# WebSocket URL
WEBSOCKET_URL=wss://fstream.binance.com/ws
# WebSocket重连间隔（秒）
WEBSOCKET_RECONNECT_INTERVAL=5
# WebSocket超时时间（秒）
WEBSOCKET_TIMEOUT=30

# --------------------------------------------
# 测试和调试配置
# --------------------------------------------
# 是否启用测试模式
TEST_MODE=false
# 是否启用调试模式
DEBUG_MODE=false
# 是否启用模拟交易
SIMULATION_MODE=false
```

### 8.2 环境变量说明文档

**文件位置**：`docs/environment_variables.md`

```markdown
# 环境变量配置说明

## 必需配置项

### 账户配置
- `LONG_ACCOUNT_API_KEY`: 多头账户API密钥
- `LONG_ACCOUNT_SECRET`: 多头账户API密钥
- `SHORT_ACCOUNT_API_KEY`: 空头账户API密钥  
- `SHORT_ACCOUNT_SECRET`: 空头账户API密钥

### 基础交易配置
- `SYMBOL`: 交易对符号，如DOGEUSDT
- `COIN_NAME`: 币种名称，如DOGE
- `CONTRACT_TYPE`: 合约类型，通常为USDT

## 可选配置项

### 网格策略参数
- `GRID_LEVELS`: 网格层数，建议5-10
- `BASE_GRID_SPACING`: 基础网格间距百分比
- `INITIAL_QUANTITY`: 初始下单量

### ATR指标参数
- `ATR_PERIOD`: ATR计算周期，建议14
- `ATR_MULTIPLIER`: ATR倍数，建议2.0
- `ATR_TIMEFRAME`: ATR时间框架，建议1h

### 对冲控制参数
- `HEDGE_RATIO_TOLERANCE`: 对冲比例容忍度
- `MAX_POSITION_IMBALANCE`: 最大持仓不平衡比例

## 配置验证

启动前请确保：
1. 所有必需的API密钥已正确配置
2. 账户具有期货交易权限
3. 账户已启用双向持仓模式
4. 账户有足够的余额进行交易
```

---

## 9. 其他必需模块

### 9.1 错误处理和重试机制

**文件位置**：`core/error_handler.py`

```python
import asyncio
import functools
from typing import Callable, Any, Optional
from utils.logger import logger

class RetryableError(Exception):
    """可重试的错误"""
    pass

class FatalError(Exception):
    """致命错误（不可重试）"""
    pass

def retry_on_failure(max_retries: int = 3, 
                    delay: float = 1.0, 
                    backoff_factor: float = 2.0,
                    exceptions: tuple = (Exception,)):
    """重试装饰器"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        async def async_wrapper(*args, **kwargs) -> Any:
            last_exception = None
            current_delay = delay
            
            for attempt in range(max_retries + 1):
                try:
                    return await func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e
                    
                    if isinstance(e, FatalError):
                        logger.error(f"致命错误，停止重试: {e}")
                        raise
                    
                    if attempt < max_retries:
                        logger.warning(f"第{attempt + 1}次尝试失败: {e}, {current_delay}秒后重试")
                        await asyncio.sleep(current_delay)
                        current_delay *= backoff_factor
                    else:
                        logger.error(f"重试{max_retries}次后仍失败: {e}")
                        
            raise last_exception
        
        @functools.wraps(func)
        def sync_wrapper(*args, **kwargs) -> Any:
            last_exception = None
            current_delay = delay
            
            for attempt in range(max_retries + 1):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e
                    
                    if isinstance(e, FatalError):
                        logger.error(f"致命错误，停止重试: {e}")
                        raise
                    
                    if attempt < max_retries:
                        logger.warning(f"第{attempt + 1}次尝试失败: {e}, {current_delay}秒后重试")
                        time.sleep(current_delay)
                        current_delay *= backoff_factor
                    else:
                        logger.error(f"重试{max_retries}次后仍失败: {e}")
                        
            raise last_exception
        
        return async_wrapper if asyncio.iscoroutinefunction(func) else sync_wrapper
    return decorator
```

### 9.2 数据持久化模块

**文件位置**：`core/data_persistence.py`

```python
import json
import os
import time
from typing import Dict, Any, Optional
from pathlib import Path
from utils.logger import logger

class DataPersistence:
    """数据持久化管理器"""
    
    def __init__(self, data_dir: str = "data"):
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(exist_ok=True)
        
    def save_grid_parameters(self, params: Dict[str, Any], account_type: str = "shared"):
        """保存网格参数"""
        try:
            filename = f"grid_params_{account_type}_{int(time.time())}.json"
            filepath = self.data_dir / filename
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(params, f, indent=2, default=str)
            
            logger.debug(f"网格参数已保存: {filepath}")
            
        except Exception as e:
            logger.error(f"保存网格参数失败: {e}")
    
    def load_latest_grid_parameters(self, account_type: str = "shared") -> Optional[Dict[str, Any]]:
        """加载最新的网格参数"""
        try:
            pattern = f"grid_params_{account_type}_*.json"
            files = list(self.data_dir.glob(pattern))
            
            if not files:
                return None
            
            # 按时间戳排序，获取最新的
            latest_file = max(files, key=lambda x: x.stat().st_mtime)
            
            with open(latest_file, 'r', encoding='utf-8') as f:
                return json.load(f)
                
        except Exception as e:
            logger.error(f"加载网格参数失败: {e}")
            return None
    
    def save_monitoring_data(self, metrics: Dict[str, Any]):
        """保存监控数据"""
        try:
            date_str = time.strftime("%Y%m%d")
            filename = f"monitoring_{date_str}.jsonl"
            filepath = self.data_dir / filename
            
            with open(filepath, 'a', encoding='utf-8') as f:
                json.dump(metrics, f, default=str)
                f.write('\n')
                
        except Exception as e:
            logger.error(f"保存监控数据失败: {e}")
```

### 9.3 安全检查模块

**文件位置**：`core/security_checker.py`

```python
import os
import hashlib
from typing import Dict, List, Tuple
from utils.logger import logger

class SecurityChecker:
    """安全检查器"""
    
    @staticmethod
    def validate_api_credentials(api_key: str, secret: str) -> bool:
        """验证API凭据格式"""
        if not api_key or not secret:
            return False
        
        # 币安API密钥通常是64字符的十六进制字符串
        if len(api_key) != 64 or not all(c in '0123456789ABCDEFabcdef' for c in api_key):
            logger.warning("API密钥格式可能不正确")
            return False
        
        # 币安API密钥通常是64字符
        if len(secret) != 64:
            logger.warning("API密钥格式可能不正确")
            return False
        
        return True
    
    @staticmethod
    def check_environment_security() -> List[str]:
        """检查环境安全性"""
        warnings = []
        
        # 检查.env文件权限
        env_file = ".env"
        if os.path.exists(env_file):
            stat = os.stat(env_file)
            if stat.st_mode & 0o077:  # 检查其他用户是否有读写权限
                warnings.append(".env文件权限过于宽松，建议设置为600")
        
        # 检查是否在生产环境中启用了调试模式
        if os.getenv('DEBUG_MODE', '').lower() == 'true':
            warnings.append("生产环境中不应启用调试模式")
        
        return warnings
    
    @staticmethod
    def mask_sensitive_data(data: str) -> str:
        """掩码敏感数据"""
        if len(data) <= 8:
            return "*" * len(data)
        return data[:4] + "*" * (len(data) - 8) + data[-4:]
```

---

## 10. 部署和运维指南

### 10.1 系统要求

- **操作系统**: Linux (Ubuntu 20.04+ 推荐)
- **Python版本**: 3.8+
- **内存**: 最低2GB，推荐4GB+
- **存储**: 最低10GB可用空间
- **网络**: 稳定的网络连接，低延迟到币安服务器

### 10.2 部署步骤

1. **克隆代码库**
```bash
git clone <repository_url>
cd GirdBot
```

2. **安装依赖**
```bash
pip install -r requirements.txt
```

3. **配置环境变量**
```bash
cp .env.example .env
# 编辑.env文件，填入正确的API密钥和配置
```

4. **设置文件权限**
```bash
chmod 600 .env
chmod +x *.sh
```

5. **启动策略**
```bash
./start_hedge_grid.sh
```

### 10.3 监控和维护

- **日志监控**: `tail -f log/grid_trading.log`
- **状态检查**: `./status_hedge_grid.sh`
- **停止策略**: `./stop_hedge_grid.sh`
- **重启策略**: `./stop_hedge_grid.sh && ./start_hedge_grid.sh`

### 10.4 故障排除

1. **连接失败**: 检查API密钥和网络连接
2. **权限错误**: 确认账户已启用期货交易和双向持仓
3. **余额不足**: 确保双账户都有足够的USDT余额
4. **参数错误**: 检查.env文件中的配置参数

---

## 结语

本技术栈文档详细说明了双账户对冲网格策略的完整实现方案。该方案基于现有的单账户ATR网格系统进行扩展，通过模块化设计实现了：

1. **风险对冲**: 双账户多空对冲，降低单向市场风险
2. **参数共享**: 统一计算网格参数，确保策略一致性  
3. **同步执行**: 协调双账户的启停和执行过程
4. **实时监控**: 全面监控对冲效果和系统状态
5. **优雅退出**: 支持信号处理和资源清理

该技术栈具有良好的可扩展性和稳定性，适用于专业的量化交易场景。
