



### **网格对冲策略：执行与监控阶段逻辑**

**“双向挂单补仓”**逻辑说明:

- **最大同时挂单数控制**: 通过 `max_open_orders` 参数（如设置为2）控制同时活跃的订单数量
- **距离优先原则**: 优先激活距离当前市价最近的网格订单，确保交易机会最大化
- **双向覆盖保证**: 
  - **多头账户**：确保在市价上方和下方均有买单（买入做多）
    - `max_open_orders=2`: 市价上方挂1个买单，下方挂1个买单
    - `max_open_orders=4`: 市价上方挂2个买单，下方挂2个买单
    - **补仓机制**：价格回调时可以成交，实现补仓效果
  - **空头账户**：确保在市价上方和下方均有卖单（卖出做空）
    - `max_open_orders=2`: 市价上方挂1个卖单，下方挂1个卖单
    - `max_open_orders=4`: 市价上方挂2个卖单，下方挂2个卖单
    - **补仓机制**：价格上涨时可以成交，实现补仓效果
- **双向补仓策略**: 
  - 无论价格向哪个方向移动，都能通过预设的限价单实现自动补仓
  - 提高资金利用效率，增强网格策略的盈利能力
- **订单分布算法**: 
  - 按距离当前价格的远近排序所有网格点
  - 在上方和下方各分配 `max_open_orders/2` 个订单
  - 如果是奇数，优先分配给距离更近的方向

核心的止盈原理依然适用：**任何一个开仓单成交后，都必须生成一个对应的平仓（止盈）单。**

1. **更新 GridLevel 数据结构**：使其能够管理更复杂的订单状态。
2. **创建核心的 handle_order_filled 函数**：这是所有止盈逻辑的入口，它能处理任何方向的开仓单成交事件。
3. **开发辅助函数**：用于计算止盈价格和重置网格。
4. **修改 manage_grid_orders**：确保它只管理那些尚未持有仓位的网格。

------



### 一、数据结构更新

首先，我们需要一个更强大的 GridLevel 数据结构来跟踪每个网格的完整生命周期，特别是它是否已经持有仓位。



```
      # 位于 3.2.1 核心数据结构

from dataclasses import dataclass, field
from decimal import Decimal
from typing import Optional, List
import time

@dataclass
class GridLevel:
    """网格层级数据结构 (已更新，支持双向挂单)"""
    level_id: str                    # 网格层级ID
    price: Decimal                   # 网格价格
    quantity: Decimal                # 网格数量
    side: str                        # 方向: "LONG" 或 "SHORT"
    account_type: str                # 账户类型: "long_account" 或 "short_account"
    
    # 订单状态
    open_order_id: Optional[str] = None      # 开仓订单ID
    close_order_id: Optional[str] = None     # 止盈平仓订单ID
    
    # 状态机，比简单的字符串更清晰
    # INACTIVE: 空闲，可挂开仓单
    # PENDING_OPEN: 开仓单已挂出
    # HOLDING: 已持仓，等待挂止盈单或止盈单已挂出
    # PENDING_CLOSE: 止盈单已挂出
    status: str = "INACTIVE"                 
    
    # 成交信息
    is_holding: bool = False                 # 明确标识是否持有该层级的仓位
    filled_quantity: Decimal = Decimal("0")  # 已成交数量
    avg_fill_price: Decimal = Decimal("0")   # 平均成交价格
    
    # 时间戳
    created_time: float = field(default_factory=time.time)
    filled_time: Optional[float] = None      # 开仓成交时间
    closed_time: Optional[float] = None      # 平仓成交时间

# GridStrategy 和 DualAccountGridManager 保持不变
    
```

**关键变更**：

- 我们用一个更清晰的 status 字段来代替 open_order_status 和 close_order_status。
- 增加了 is_holding 字段，这是区分一个网格是否可以用来挂开仓单的核心标志。

------



### 二、核心止盈逻辑：订单生命周期管理

这部分是全新的内容，应该被添加到 DualAccountGridManager 类中。

```
      # 位于 DualAccountGridManager 类中

async def handle_order_filled(self, account_type: str, order_data: dict):
    """
    处理所有订单成交事件，是开仓和止盈的核心中枢。
    适用于双向挂单逻辑。
    """
    async with self.sync_lock:
        order_id = order_data['orderId']
        side = order_data['side']  # "BUY" or "SELL"
        position_side = order_data['positionSide']  # "LONG" or "SHORT"
        filled_qty = Decimal(order_data['executedQty'])
        avg_price = Decimal(order_data['avgPrice'])
        
        # 识别订单类型
        is_opening_order = (side == "BUY" and position_side == "LONG") or \
                           (side == "SELL" and position_side == "SHORT")
                           
        is_closing_order = (side == "SELL" and position_side == "LONG") or \
                           (side == "BUY" and position_side == "SHORT")

        if is_opening_order:
            # --- 开仓单成交 ---
            grid = self.find_grid_by_order_id(order_id, 'open')
            if not grid:
                logger.warning(f"未找到与开仓订单 {order_id} 匹配的网格")
                return

            logger.info(f"✅ 开仓成交: 账户={account_type}, 方向={position_side}, 价格={avg_price}, 数量={filled_qty}")

            # 1. 更新网格状态为“已持仓”
            grid.status = "HOLDING"
            grid.is_holding = True
            grid.filled_quantity = filled_qty
            grid.avg_fill_price = avg_price
            grid.filled_time = time.time()
            
            # 2. 【核心】立即为这笔成交创建止盈单
            await self.create_take_profit_order(grid)

        elif is_closing_order:
            # --- 止盈单成交 ---
            grid = self.find_grid_by_order_id(order_id, 'close')
            if not grid:
                logger.warning(f"未找到与止盈订单 {order_id} 匹配的网格")
                return

            pnl = (avg_price - grid.avg_fill_price) * filled_qty if position_side == "LONG" else (grid.avg_fill_price - avg_price) * filled_qty
            logger.info(f"💰 止盈成交: 账户={account_type}, 方向={position_side}, 价格={avg_price}, 利润={pnl:.4f}")

            # 1. 累加已实现盈利
            self.total_realized_pnl += pnl

            # 2. 【核心】重置网格，使其变回“空闲”状态，可以再次被用于挂开仓单
            await self.reset_grid_level(grid)


async def create_take_profit_order(self, filled_grid: GridLevel):
    """为一个已成交的开仓网格创建对应的止盈订单"""
    
    # 1. 确定止盈目标价格（相邻的下一个网格）
    target_price = self.find_take_profit_price(filled_grid)
    if not target_price:
        logger.warning(f"无法为价格为 {filled_grid.price} 的网格找到止盈目标，可能是边界网格。")
        filled_grid.status = "HOLDING" # 标记为持仓，但不挂止盈单
        return

    # 2. 确定下单账户和方向
    account = self.long_account if filled_grid.account_type == "long_account" else self.short_account
    close_side = "SELL" if filled_grid.side == "LONG" else "BUY"
    position_side = "LONG" if filled_grid.side == "LONG" else "SHORT"

    try:
        # 3. 下达止盈订单（关键参数：reduce_only=True）
        order = await account.place_limit_order(
            symbol=self.config.symbol,
            side=close_side,
            position_side=position_side,
            quantity=filled_grid.filled_quantity,
            price=target_price,
            reduce_only=True
        )
        
        # 4. 更新网格状态
        filled_grid.close_order_id = order['orderId']
        filled_grid.status = "PENDING_CLOSE" # 状态更新为“等待平仓”
        
        logger.info(f"创建止盈单成功: 网格价={filled_grid.price}, 止盈价={target_price}, 订单ID={order['orderId']}")

    except Exception as e:
        logger.error(f"创建止盈单失败: {e}. 网格 {filled_grid.level_id} 仍处于 HOLDING 状态。")
        # 需要有重试或告警机制


def find_take_profit_price(self, filled_grid: GridLevel) -> Optional[Decimal]:
    """根据当前成交的网格，查找其止盈价格（即相邻的下一个网格价格）"""
    grids = self.grid_strategy.long_grids if filled_grid.account_type == "long_account" else self.grid_strategy.short_grids
    grids.sort(key=lambda g: g.price)
    
    try:
        current_index = [i for i, g in enumerate(grids) if g.level_id == filled_grid.level_id][0]
        
        if filled_grid.side == "LONG":
            if current_index + 1 < len(grids): return grids[current_index + 1].price
        elif filled_grid.side == "SHORT":
            if current_index - 1 >= 0: return grids[current_index - 1].price
    except IndexError:
        logger.error(f"在网格列表中未找到ID为 {filled_grid.level_id} 的网格")
    return None


async def reset_grid_level(self, closed_grid: GridLevel):
    """当一个网格止盈后，重置其状态，使其能够被重新挂开仓单"""
    logger.info(f"重置网格层级: 价格={closed_grid.price}")
    
    closed_grid.is_holding = False
    closed_grid.status = "INACTIVE"
    closed_grid.filled_quantity = Decimal("0")
    closed_grid.avg_fill_price = Decimal("0")
    closed_grid.filled_time = None
    closed_grid.closed_time = time.time()
    closed_grid.open_order_id = None
    closed_grid.close_order_id = None


def find_grid_by_order_id(self, order_id: str, order_type: str) -> Optional[GridLevel]:
    """通过订单ID查找对应的网格层级"""
    attr_to_check = 'open_order_id' if order_type == 'open' else 'close_order_id'
    
    for grid in self.grid_strategy.long_grids + self.grid_strategy.short_grids:
        if getattr(grid, attr_to_check) == order_id:
            return grid
    return None
    
```



------



### 三、挂单逻辑修改

现在，我们需要修改您提供的挂单逻辑，让它**只对状态为 INACTIVE 的网格进行操作**，避免为已经持仓或已挂单的网格重复挂单。

```
      # 位于 3.3.2 动态网格调整

async def manage_long_buy_orders_bidirectional(self, current_price: Decimal, max_orders: int):
    """管理多头账户的买单（市价上方和下方都挂买单，实现双向补仓）"""
    
    # 【修改】筛选条件增加：只选择尚未持仓的网格
    # 获取市价上方的网格点
    above_grids = [
        grid for grid in self.grid_strategy.long_grids 
        if grid.price > current_price and not grid.is_holding
    ]
    above_grids.sort(key=lambda x: x.price)
    
    # 获取市价下方的网格点
    below_grids = [
        grid for grid in self.grid_strategy.long_grids 
        if grid.price < current_price and not grid.is_holding
    ]
    below_grids.sort(key=lambda x: x.price, reverse=True)
    
    orders_above = max_orders // 2
    orders_below = max_orders - orders_above
    
    await self.manage_grid_orders(above_grids, orders_above, self.long_account, "ABOVE")
    await self.manage_grid_orders(below_grids, orders_below, self.long_account, "BELOW")


async def manage_short_sell_orders_bidirectional(self, current_price: Decimal, max_orders: int):
    """管理空头账户的卖单（市价上方和下方都挂卖单，实现双向补仓）"""
    
    # 【修改】筛选条件增加：只选择尚未持仓的网格
    # 获取市价上方的网格点
    above_grids = [
        grid for grid in self.grid_strategy.short_grids 
        if grid.price > current_price and not grid.is_holding
    ]
    above_grids.sort(key=lambda x: x.price)
    
    # 获取市价下方的网格点
    below_grids = [
        grid for grid in self.grid_strategy.short_grids 
        if grid.price < current_price and not grid.is_holding
    ]
    below_grids.sort(key=lambda x: x.price, reverse=True)
    
    orders_above = max_orders // 2
    orders_below = max_orders - orders_above
    
    await self.manage_grid_orders(above_grids, orders_above, self.short_account, "ABOVE")
    await self.manage_grid_orders(below_grids, orders_below, self.short_account, "BELOW")


async def manage_grid_orders(self, grids: list, target_count: int, account, direction: str):
    """通用的网格订单管理函数 (已更新)"""
    
    # 检查当前已挂出的【开仓单】
    active_open_orders = [
        grid for grid in grids 
        if grid.status == "PENDING_OPEN"
    ]
    
    # 如果活跃订单少于目标数量，添加新订单
    if len(active_open_orders) < target_count:
        needed_orders = target_count - len(active_open_orders)
        
        # 从【空闲】的网格中选择
        available_grids = [grid for grid in grids if grid.status == "INACTIVE"]

        for grid in available_grids[:needed_orders]:
            # 【假设】place_grid_order会下单并更新grid状态
            await self.place_grid_order(grid, account) 
            logger.info(f"激活{direction}方向网格订单: 价格={grid.price}, 账户={account.name}")
    
    # 如果活跃订单超过目标数量，取消距离最远的订单
    elif len(active_open_orders) > target_count:
        excess_orders = len(active_open_orders) - target_count
        
        # active_open_orders 已经按价格排好序，末尾就是最远的
        orders_to_cancel = active_open_orders[-excess_orders:]
        for grid in orders_to_cancel:
            # 【假设】cancel_order会撤单并更新grid状态
            await self.cancel_order(account, grid.open_order_id)
            logger.info(f"取消{direction}方向网格订单: 价格={grid.price}, 账户={account.name}")

# 【新增】下单和撤单的具体实现，需要与GridLevel状态同步
async def place_grid_order(self, grid: GridLevel, account):
    """下单并更新网格状态"""
    try:
        # 具体下单逻辑，取决于您的交易所API封装
        order = await account.place_limit_order(...)
        grid.open_order_id = order['orderId']
        grid.status = "PENDING_OPEN"
    except Exception as e:
        logger.error(f"下单失败: {e}")
        grid.status = "INACTIVE" # 失败则恢复为空闲

async def cancel_order(self, account, order_id):
    """撤单并更新对应网格的状态"""
    grid = self.find_grid_by_order_id(order_id, 'open')
    try:
        await account.cancel_order(order_id)
        if grid:
            grid.open_order_id = None
            grid.status = "INACTIVE"
    except Exception as e:
        logger.error(f"撤单失败: {e}")
        # 状态可能不一致，需要同步机制来校准
    
```



### 四、总结与工作流程

整个策略的工作流程如下：

1. **初始化**: 创建所有 GridLevel 对象，初始状态均为 INACTIVE。
2. **挂开仓单**: dynamic_grid_adjustment 循环运行。它会检查所有 INACTIVE 的网格，并根据双向挂单逻辑，在市价上下方选择 max_open_orders 个网格，调用 place_grid_order 下开仓单，并将它们的状态更新为 PENDING_OPEN。
3. **开仓成交**: 交易所推送订单成交消息。handle_order_filled 被调用，识别出是开仓单成交。
4. **挂止盈单**: handle_order_filled 将该网格状态更新为 HOLDING，然后立即调用 create_take_profit_order，在相邻网格挂一个止盈单，并将状态更新为 PENDING_CLOSE。
5. **止盈成交**: 交易所再次推送成交消息。handle_order_filled 识别出是平仓单成交。
6. **网格重置**: handle_order_filled 调用 reset_grid_level，将该网格的所有信息清空，状态重新设置为 INACTIVE。
7. **循环**: 这个状态变为 INACTIVE 的网格，在下一次 dynamic_grid_adjustment 运行时，又可以被重新选中用来挂开仓单了。

这个流程完整地实现了在“双向补仓”策略基础上的自动化止盈，确保了每一笔仓位都有对应的平仓逻辑，并且网格可以被循环利用。